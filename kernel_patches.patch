diff --no-dereference -ruN linux-master/arch/arm/boot/compressed/head.S linux-master-mod/arch/arm/boot/compressed/head.S
--- linux-master/arch/arm/boot/compressed/head.S	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/boot/compressed/head.S	2024-10-17 22:52:46.246034611 +0300
@@ -187,6 +187,106 @@
  AR_CLASS(	.arm	)
 start:
 		.type	start,#function
+		
+# 		_loop1:
+# 		ldr r0, =0x31
+# 		ldr r6, =0x20090000
+# 		_wait1:	
+# 		ldr r0, [r6, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait1
+# # 		
+# 		str r0, [r6]
+# 		_wait2:	
+# 		ldr r0, [r6, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait2
+# 		ldr r0, =0x32
+# 		str r0, [r6]
+# 		_wait3:	
+# 		ldr r0, [r6, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait3
+# 		ldr r0, =0x0A
+# 		str r0, [r6]
+# 		_wait4:	
+# 		ldr r0, [r6, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait4
+# 		ldr r0, =0x0D
+# 		str r0, [r6]
+# 		_wait5:	
+# 		ldr r0, [r6, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait5
+		# mov pc, lr
+# 		b _loop1
+# 		# bl __uart_print_char
+
+
+
+
+# 		@ Data cache might be active.
+# 		@ Be sure to flush kernel binary out of the cache,
+# 		@ whatever state it is, before it is turned off.
+# 		@ This is done by fetching through currently executed
+# 		@ memory to be sure we hit the same cache.
+# 		bic	r2, pc, #0x1f
+# 		add	r3, r2, #0x10000	@ 64 kb is quite enough...
+# 1:		ldr	r0, [r2], #32
+# 		teq	r2, r3
+# 		bne	1b
+# 		mcr	p15, 0, r0, c7, c10, 4	@ drain WB
+# 		mcr	p15, 0, r0, c7, c7, 0	@ flush I & D caches
+# 
+# 		@ disabling MMU and caches
+# 		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+# 		bic	r0, r0, #0x05		@ clear DC, MMU
+# 		bic	r0, r0, #0x1000		@ clear Icache
+# 		mcr	p15, 0, r0, c1, c0, 0
+		
+		
+
+		
+		@Startup code(dont know how this shit works) (but kernel don't loading with u-boot 'go' command without this)
+# 		sub	lr, pc, #8
+# 		adr sp, _initst  @Set stack pointer to initial vals
+# 		pop	{r4, r5, r6}  @Load 3 vals from stack
+# 		mov	r12, r5 @r5 = 0xc2000000
+# 		add	r4, r4, lr @r4 = 0x00000064 + pc-8
+# 		bl	_subr1 
+# 		ldmia	sp, {r5, r6}
+# 		ldr	r10, [r6, #4]
+# 		teq	r10, r5
+# 		movne	r10, #0
+# 		movne	r4, #2
+# 		stmneia	r6, {r4, r5, r10}
+# 		mov	pc, r12
+# 		
+# _subr1: 	ldmia	r4!, {r7, r8, r9, r10}
+# 		stmia	r5!, {r7, r8, r9, r10}
+# 		ldmia	r4!, {r7, r8, r9, r10}
+# 		stmia	r5!, {r7, r8, r9, r10}
+# 		subs	r6, r6, #32
+# 		bcs	_subr1
+# 		mov	pc, lr
+# 		
+# _initst:
+# 		.word 0x00000064  @r4
+# 		.word 0xc2000000  @r5
+# 		.word 0x0038c7f0  @r6
+# 		.word 0x54410001  @r5
+# 		.word 0xc2000000  @r6
+
+
+#ifdef CONFIG_ARCH_HI3515V100
+		#retarded bootloader provides wrong values? Just hardcode them! 
+		ldr r1, =0x00000183
+		ldr r2, =0xC0000100
+#endif
+		
+		
+		
 		/*
 		 * These 7 nops along with the 1 nop immediately below for
 		 * !THUMB2 form 8 nops that make the compressed kernel bootable
@@ -210,6 +310,7 @@
   M_CLASS(	nop.w			)	@ M: already in Thumb2 mode
 		.thumb
 #endif
+
 		W(b)	1f
 
 		.word	_magic_sig	@ Magic numbers to help the loader
@@ -257,6 +358,7 @@
 		 */
 
 		.text
+		
 
 #ifdef CONFIG_AUTO_ZRELADDR
 		/*
@@ -801,6 +903,7 @@
 		mov	r9, r0, lsr #18
 		mov	r9, r9, lsl #18		@ start of RAM
 		add	r10, r9, #0x10000000	@ a reasonable RAM size
+		mvncs   r10, #0			@ check overflow by chanjinn
 		mov	r1, #0x12		@ XN|U + section mapping
 		orr	r1, r1, #3 << 10	@ AP=11
 		add	r2, r3, #16384
@@ -1432,9 +1535,42 @@
 #endif /* CONFIG_ARM_VIRT_EXT */
 
 __enter_kernel:
+# 		ldr r0, =0x31
+# 		ldr r1, =0x20090000
+# 		_wait11:	
+# 		ldr r0, [r1, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait11
+# # 		
+# 		str r0, [r1]
+# 		_wait12:	
+# 		ldr r0, [r1, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait12
+# 		ldr r0, =0x32
+# 		str r0, [r1]
+# 		_wait13:	
+# 		ldr r0, [r1, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait13
+# 		ldr r0, =0x0A
+# 		str r0, [r1]
+# 		_wait14:	
+# 		ldr r0, [r1, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait14
+# 		ldr r0, =0x0D
+# 		str r0, [r1]
+# 		_wait15:	
+# 		ldr r0, [r1, #0x18]       @UART_FR
+# 			ands r0, r0, #0b101000
+# 			bne _wait15
 		mov	r0, #0			@ must be 0
+		mov	r0, #0			@ must be zero
 		mov	r1, r7			@ restore architecture number
-		mov	r2, r8			@ restore atags pointer
+		@ldr r1, =0x00000183
+		mov	r2, r8			@ restore atags pointer 8275221223 3221225728
+		@ldr r2, =3221225728
  ARM(		mov	pc, r4		)	@ call kernel
  M_CLASS(	add	r4, r4, #1	)	@ enter in Thumb mode for M class
  THUMB(		bx	r4		)	@ entry point is always ARM for A/R classes
@@ -1529,3 +1665,4 @@
 		.section ".stack", "aw", %nobits
 .L_user_stack:	.space	4096
 .L_user_stack_end:
+
diff --no-dereference -ruN linux-master/arch/arm/boot/dts/hisilicon/hi3515v100-avtech-dr082.dts linux-master-mod/arch/arm/boot/dts/hisilicon/hi3515v100-avtech-dr082.dts
--- linux-master/arch/arm/boot/dts/hisilicon/hi3515v100-avtech-dr082.dts	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/boot/dts/hisilicon/hi3515v100-avtech-dr082.dts	2024-11-23 18:25:41.404055479 +0300
@@ -0,0 +1,138 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+ 
+/dts-v1/;
+#include "hi3515v100.dtsi"
+
+/ {
+	model = "HiSilicon HI3515 AVTECH DR082/DR083 DVR BOARD";
+	compatible = "hisilicon,hi3515v100";
+
+	aliases {
+		serial0 = &uart0;
+	};
+	
+	chosen {
+		bootargs = "earlycon=pl011,0x20090000 root=/dev/mtdblock4 rootfstype=jffs2 console=ttyAMA0 no_console_suspend";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x10000000>;
+	};
+	
+	flash@80000000 {
+		compatible = "cfi-flash", "jedec-flash";
+		reg = <0x80000000 0x01000000>;
+		bank-width = <1>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		
+		bootloader@0 {
+			label = "bootloader";
+			reg = <0x00000000 0x00040000>;
+			read-only;
+		};
+		bmplogo@40000 {
+			label = "bmplogo";
+			reg = <0x00040000 0x00020000>;
+		};
+		factorydef@A0000 {
+			label = "factorydefault";
+			reg = <0x000A0000 0x00060000>;
+		};
+		kernel@100000 {
+			label = "kernel";
+			reg = <0x00100000 0x00500000>;
+		};
+		root@600000 {
+			label = "root";
+			reg = <0x00600000 0x00900000>;
+		};
+		xml@F00000 {
+			label = "xml";
+			reg = <0x00F00000 0x00100000>;
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&dual_timer01 {
+	status = "okay";
+};
+
+&dual_timer23 {
+	status = "okay";
+};
+
+&smi {
+	status = "okay";
+};
+
+&mdio {
+	status = "okay";
+};
+
+&hisi_femac {
+	status = "okay";
+	local-mac-address = [ 01 23 45 66 66 66 ];
+};
+
+&mmc {
+	status = "okay";
+};
+
+&ahci {
+	status = "okay";
+};
+
+&ehci {
+	status = "okay";
+};
+
+&ohci {
+	status = "okay";
+};
+
+&i2c {
+	status = "okay";
+	clock-frequency = <10000>;
+	tw2868: tw2868@28 {
+		compatible = "renesas,tw2868";
+		#sound-dai-cells = <0>;
+		reg = <0x28>;
+		amp-en-gpio = <&gpio3 6 0>;
+	};
+	avtkbd: keyboard@18 {
+		compatible = "avtech,kbd";
+		trigger-gpio = <&gpio1 5 0>;
+		ce-gpio = <&gpio1 6 0>;
+		pinctrl-0 = <&mux_VI2S_GPIO>;
+		reg = <0x18>;
+	};
+};
+
+&fb {
+	status = "okay";
+};
+
+&sio0 {
+	status = "okay";
+};
+
+&sio1 {
+	status = "okay";
+};
+
+&sound_card {
+	status = "okay";
+	
+	codec_dai: simple-audio-card,codec {
+		sound-dai = <&tw2868>;
+	};
+};
diff --no-dereference -ruN linux-master/arch/arm/boot/dts/hisilicon/hi3515v100.dtsi linux-master-mod/arch/arm/boot/dts/hisilicon/hi3515v100.dtsi
--- linux-master/arch/arm/boot/dts/hisilicon/hi3515v100.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/boot/dts/hisilicon/hi3515v100.dtsi	2024-11-24 14:30:05.068212036 +0300
@@ -0,0 +1,827 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+ 
+#include <dt-bindings/clock/hi3515-clock.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	chosen { };
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,arm926ej-s";
+			reg = <0>;
+			clocks = <&clk_cpu>;
+		};
+		
+	};
+	
+	ref_clk: ref_clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		clock-output-names = "ref_clk";
+	};
+	
+	slow_ref_clk: slow_ref_clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <46800>;
+		clock-output-names = "slow_ref_clk";
+	};
+	
+	clk_3m: clk_3m {
+		compatible = "fixed-factor-clock";
+		clocks = <&ref_clk>;
+		clock-div = <8>;
+		clock-mult = <1>;
+		#clock-cells = <0>;
+		clock-output-names = "clk_3m";
+	};
+	
+	amba@0 {
+		//AMBA/APB BUS
+		compatible = "simple-bus", "arm,amba-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x10000000 0x64000000>;
+		
+		pinmux: pinmux@100F0000 {
+			compatible = "pinctrl-single";
+			reg = <0x100F0000 0x1000>;
+			#pinctrl-cells = <1>;
+			pinctrl-single,register-width = <32>;
+			pinctrl-single,function-mask = <0x3>;
+			
+			mux_VI0S_VI0S: mux_VI0S_VI0S {
+				function = "VI0S";
+				groups = "VI0SPINS";
+				pinctrl-single,pins = 	<0x0000 0x0>, //VI0HS
+							<0x0004 0x0>; //VI0VS
+			};
+			
+			mux_VI0S_UART2: mux_VI0S_UART2 {
+				function = "UART2";
+				groups = "VI0SPINS";
+				pinctrl-single,pins = 	<0x0000 0x1>, //URXD2
+							<0x0004 0x1>; //UTXD2
+			};
+			
+			mux_VI0S_GPIO: mux_VI0S_GPIO {
+				function = "GPIO";
+				groups = "VI0SPINS";
+				pinctrl-single,pins = 	<0x0000 0x2>, //GPIO1_3
+							<0x0004 0x2>; //GPIO1_4
+			};
+			
+			mux_VI1_VI1: mux_VI1_VI1 {
+				function = "VI1";
+				groups = "VI1PINS";
+				pinctrl-single,pins = 	<0x0008 0x0>, //VI1D0
+							<0x000C 0x0>,
+							<0x0010 0x0>,
+							<0x0014 0x0>,
+							<0x0018 0x0>,
+							<0x001C 0x0>,
+							<0x0020 0x0>,
+							<0x0024 0x0>; //VI1DAT7
+			};
+			
+			mux_VI1_GPIO: mux_VI1_GPIO {
+				function = "GPIO";
+				groups = "VI1PINS";
+				pinctrl-single,pins = 	<0x0008 0x1>, //GPIO3_0
+							<0x000C 0x1>,
+							<0x0010 0x1>,
+							<0x0014 0x1>,
+							<0x0018 0x1>,
+							<0x001C 0x1>,
+							<0x0020 0x1>,
+							<0x0024 0x1>; //GPIO3_7
+			};
+			
+			mux_VI2S_VI2S: mux_VI2S_VI2S {
+				function = "VI2S";
+				groups = "VI2SPINS";
+				pinctrl-single,pins = 	<0x0028 0x0>, //VI2HS
+							<0x002C 0x0>; //VI2VS
+			};
+			
+			mux_VI2S_UART3: mux_VI2S_UART3 {
+				function = "UART3";
+				groups = "VI2SPINS";
+				pinctrl-single,pins = 	<0x0028 0x1>, //URXD3
+							<0x002C 0x1>; //UTXD3
+			};
+			
+			mux_VI2S_GPIO: mux_VI2S_GPIO {
+				function = "GPIO";
+				groups = "VI2SPINS";
+				pinctrl-single,pins = 	<0x0028 0x2>, //GPIO1_5
+							<0x002C 0x2>; //GPIO1_6
+			};
+			
+			mux_VI2_VI2: mux_VI2_VI2 {
+				function = "VI2";
+				groups = "VI2PINS";
+				pinctrl-single,pins = 	<0x0030 0x0>, //VI2D0
+							<0x0034 0x0>,
+							<0x0038 0x0>,
+							<0x003C 0x0>,
+							<0x0040 0x0>,
+							<0x0044 0x0>,
+							<0x0048 0x0>,
+							<0x004C 0x0>; //VI2D7
+			};
+			
+			mux_VI2_GPIO: mux_VI2_GPIO {
+				function = "GPIO";
+				groups = "VI2PINS";
+				pinctrl-single,pins = 	<0x0030 0x1>, //GPIO4_0
+							<0x0034 0x1>,
+							<0x0038 0x1>,
+							<0x003C 0x1>,
+							<0x0040 0x1>,
+							<0x0044 0x1>,
+							<0x0048 0x1>,
+							<0x004C 0x1>; //GPIO4_7
+			};
+			
+			mux_VI3_VI3: mux_VI3_VI3 {
+				function = "VI3";
+				groups = "VI3PINS";
+				pinctrl-single,pins = 	<0x0050 0x0>, //VI3D0
+							<0x0054 0x0>,
+							<0x0058 0x0>,
+							<0x005C 0x0>,
+							<0x0060 0x0>,
+							<0x0064 0x0>,
+							<0x0068 0x0>,
+							<0x006C 0x0>; //VI3D7
+			};
+			
+			mux_VI3_GPIO: mux_VI3_GPIO {
+				function = "GPIO";
+				groups = "VI3PINS";
+				pinctrl-single,pins = 	<0x0050 0x1>, //GPIO5_0
+							<0x0054 0x1>,
+							<0x0058 0x1>,
+							<0x005C 0x1>,
+							<0x0060 0x1>,
+							<0x0064 0x1>,
+							<0x0068 0x1>,
+							<0x006C 0x1>; //GPIO5_7
+			};
+			
+			mux_VO_VO: mux_VO_VO {
+				function = "VO";
+				groups = "VOPINS";
+				pinctrl-single,pins = 	<0x0070 0x0>, //VOCK
+							<0x0074 0x0>, //VOD0
+							<0x0078 0x0>,
+							<0x007C 0x0>,
+							<0x0080 0x0>,
+							<0x0084 0x0>,
+							<0x0088 0x0>,
+							<0x008C 0x0>,
+							<0x0090 0x0>; //VOD7
+			};
+			
+			mux_VO_GPIO: mux_VO_GPIO {
+				function = "GPIO";
+				groups = "VOPINS";
+				pinctrl-single,pins = 	<0x0070 0x1>, //GPIO1_7
+							<0x0074 0x1>, //GPIO2_0
+							<0x0078 0x1>,
+							<0x007C 0x1>,
+							<0x0080 0x1>,
+							<0x0084 0x1>,
+							<0x0088 0x1>, //GPIO2_5
+							<0x008C 0x1>, //SATALED0
+							<0x0090 0x1>; //SATALED1
+			};
+			
+			mux_VO_SDIO: mux_VO_SDIO {
+				function = "SDIO";
+				groups = "VOPINS";
+				pinctrl-single,pins = 	<0x0070 0x2>, //SDIOCK
+							<0x0074 0x2>, //SDIOCMD
+							<0x0078 0x2>, //SDIOD0
+							<0x007C 0x2>,
+							<0x0080 0x2>,
+							<0x0084 0x2>, //SDIOD3
+							<0x0088 0x2>, //SDIODETC
+							<0x008C 0x1>, //SATALED0
+							<0x0090 0x1>; //SATALED1
+			};
+			
+			mux_VO_SPI: mux_VO_SPI {
+				function = "SPI";
+				groups = "VOPINS";
+				pinctrl-single,pins = 	<0x0070 0x3>, //SPICK
+							<0x0074 0x3>, //SPIDI
+							<0x0078 0x3>, //SPIDO
+							<0x007C 0x3>, //SPICS0
+							<0x0080 0x3>, //SPICS1
+							<0x0084 0x1>, //GPIO2_4
+							<0x0088 0x1>, //GPIO2_5
+							<0x008C 0x1>, //SATALED0
+							<0x0090 0x1>; //SATALED1
+			};
+			
+			mux_I2C_I2C: mux_I2C_I2C {
+				function = "I2C";
+				groups = "I2CPINS";
+				pinctrl-single,pins = 	<0x0094 0x0>, //SDA
+							<0x0098 0x0>; //SCL
+			};
+			
+			mux_I2C_GPIO: mux_I2C_GPIO {
+				function = "GPIO";
+				groups = "I2CPINS";
+				pinctrl-single,pins = 	<0x0094 0x1>, //GPIO0_0
+							<0x0098 0x1>; //GPIO0_1
+			};
+			
+			mux_SIO_SIO: mux_SIO_SIO {
+				function = "SIO";
+				groups = "SIOPINS";
+				pinctrl-single,pins = 	<0x009C 0x0>, //SIO0XFS
+							<0x00A0 0x0>, //SIO0XCK
+							<0x00A4 0x0>; //ACKOUT
+			};
+			
+			mux_SIO_GPIO: mux_SIO_GPIO {
+				function = "GPIO";
+				groups = "SIOPINS";
+				pinctrl-single,pins = 	<0x009C 0x1>, //GPIO0_2
+							<0x00A0 0x1>,
+							<0x00A4 0x1>; //GPIO0_4
+			};
+			
+			mux_EBI_EBI: mux_EBI_EBI {
+				function = "EBI";
+				groups = "EBIPINS";
+				pinctrl-single,pins = 	<0x00A8 0x0>, //SMICS1N
+							<0x00AC 0x0>, //NFCS1N
+							<0x00B0 0x0>, //NFRB
+							<0x00B4 0x0>; //EBIRDYN
+			};
+			
+			mux_EBI_GPIO: mux_EBI_GPIO {
+				function = "GPIO";
+				groups = "EBIPINS";
+				pinctrl-single,pins = 	<0x00A8 0x1>, //GPIO0_5
+							<0x00AC 0x1>, //GPIO0_6
+							<0x00B0 0x1>, //GPIO0_7
+							<0x00B4 0x2>; //GPIO1_0
+			};
+			
+			mux_EBI_IR: mux_EBI_IR {
+				function = "IR";
+				groups = "EBIPINS";
+				pinctrl-single,pins = 	<0x00A8 0x0>, //SMICS1N
+							<0x00AC 0x0>, //NFCS1N
+							<0x00B0 0x0>, //NFRB
+							<0x00B4 0x1>; //IRRX
+			};
+			
+			mux_ETH_ETH: mux_ETH_ETH {
+				function = "ETH";
+				groups = "ETHPINS";
+				pinctrl-single,pins = 	<0x00B8 0x0>, //ECOL
+							<0x00BC 0x0>; //ECRS
+			};
+			
+			mux_ETH_GPIO: mux_ETH_GPIO {
+				function = "GPIO";
+				groups = "ETHPINS";
+				pinctrl-single,pins = 	<0x00B8 0x1>, //GPIO1_1
+							<0x00BC 0x1>; //GPIO1_2
+			};
+			
+		};
+		
+		gpio0: gpio@10150000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x10150000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupts = <6>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+		};
+		
+		gpio1: gpio@10160000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x10160000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupts = <7>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+		};
+		
+		gpio2: gpio@10170000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x10170000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupts = <8>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+		};
+		
+		gpio3: gpio@10180000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x10180000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupts = <8>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+		};
+		
+		gpio4: gpio@10190000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x10190000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupts = <8>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+		};
+		
+		gpio5: gpio@101A0000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x101A0000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupts = <8>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+		};
+		
+		sysctrl: system-controller@10050000 {
+			compatible = "hisilicon,hi3515sysctrl", "syscon", "simple-mfd";
+			reg = <0x10050000 0x1000>;
+			
+			clk_bus2: clk_bus2 {
+				compatible = "fixed-factor-clock";
+				clocks = <&clk_bus>;
+				clock-div = <2>;
+				clock-mult = <1>;
+				#clock-cells = <0>;
+				clock-output-names = "clk_bus2";
+			};
+			
+			clk_i2c: clk_i2c {
+				compatible = "fixed-factor-clock";
+				clocks = <&clk_bus>;
+				clock-div = <1000>;
+				clock-mult = <375>;
+				#clock-cells = <0>;
+				clock-output-names = "clk_i2c";
+			};
+			
+			wdt_clock_mux: wdt_clockmux@23 {
+				compatible = "hisilicon,hi3515-mux-clock";
+				#clock-cells = <0>;
+				clocks = <&clk_3m>, <&clk_bus2>;
+				regnum = <0x0>;
+				clock-output-names = "wdt_clock_mux";
+				bit-shift = <23>;
+			};
+			
+			tmr3_mux: tmr3_clockmux@22 {
+				compatible = "hisilicon,hi3515-mux-clock";
+				#clock-cells = <0>;
+				clocks = <&clk_3m>, <&clk_bus2>;
+				regnum = <0x0>;
+				clock-output-names = "tmr3_clock_mux";
+				bit-shift = <22>;
+			};
+			
+			tmr2_mux: tmr2_clockmux@20 {
+				compatible = "hisilicon,hi3515-mux-clock";
+				#clock-cells = <0>;
+				clocks = <&clk_3m>, <&clk_bus2>;
+				regnum = <0x0>;
+				clock-output-names = "tmr2_clock_mux";
+				bit-shift = <20>;
+			};
+			
+			tmr1_mux: tmr1_clockmux@18 {
+				compatible = "hisilicon,hi3515-mux-clock";
+				#clock-cells = <0>;
+				clocks = <&clk_3m>, <&clk_bus2>;
+				regnum = <0x0>;
+				clock-output-names = "tmr1_clock_mux";
+				bit-shift = <18>;
+				defval = <0>;
+			};
+			
+			tmr0_mux: tmr0_clockmux@16 {
+				compatible = "hisilicon,hi3515-mux-clock";
+				#clock-cells = <0>;
+				clocks = <&clk_3m>, <&clk_bus2>;
+				regnum = <0x0>;
+				clock-output-names = "tmr0_clock_mux";
+				bit-shift = <16>;
+				defval = <0>;
+			};
+			
+			reboot {
+				compatible = "syscon-reboot";
+				offset = <0x4>;
+				mask = <0xdeadbeef>;
+			};
+			
+			//datasheet recommends this to be fixed, so we wont be managing APLL and EPLL for now
+			apll: pll@0 {
+				clk_cpu: clk_cpu {
+					compatible = "fixed-factor-clock";
+					clocks = <&ref_clk>;
+					clock-div = <12>;
+					clock-mult = <200>;
+					#clock-cells = <0>;
+					clock-output-names = "clk_cpu";
+				};
+				clk_bus: clk_bus {
+					compatible = "fixed-factor-clock";
+					clocks = <&clk_cpu>;
+					clock-div = <6>;
+					clock-mult = <4>;
+					#clock-cells = <0>;
+					clock-output-names = "clk_bus";
+				};
+			};
+			
+			epll: pll@6 {
+				clk_eth1: clk_eth@1 {
+					compatible = "fixed-factor-clock";
+					clocks = <&ref_clk>;
+					clock-div = <6>;
+					clock-mult = <125>;
+					#clock-cells = <0>;
+					clock-output-names = "clk_eth1";
+				};
+				clk_eth2: clk_eth@2 {
+					compatible = "fixed-factor-clock";
+					clocks = <&ref_clk>;
+					clock-div = <2>;
+					clock-mult = <1>;
+					#clock-cells = <0>;
+					clock-output-names = "clk_eth2";
+				};
+				clk_eth3: clk_eth@3 {
+					compatible = "fixed-factor-clock";
+					clocks = <&ref_clk>;
+					clock-div = <4>;
+					clock-mult = <1>;
+					#clock-cells = <0>;
+					clock-output-names = "clk_eth3";
+				};
+			};
+			
+			//VPLL0&VPLL1 use FOUTPOSTDIV as frequency output pin( <&vpll0> )
+			vpll0: vpll0@2 {
+				compatible = "hisilicon,hi3515pllctl";
+				regnum = <0x0034>;
+				clocks = <&ref_clk>;
+				clock-names = "fref";
+				#clock-cells = <0>;
+				clock-output-names = "vpll0_FOUTPOSTDIV";
+			};
+			vpll1: vpll1@4 {
+				compatible = "hisilicon,hi3515pllctl";
+				regnum = <0x003C>;
+				clocks = <&ref_clk>;
+				clock-names = "fref";
+				#clock-cells = <0>;
+				clock-output-names = "vpll1_FOUTPOSTDIV";
+			};
+			
+			perclkctl: clock-controller@24 {
+				compatible = "hisilicon,hi3515clockctl";
+				clocks = <&clk_bus>;
+				#reset-cells = <1>;
+				#clock-cells = <1>;
+			};
+			
+		};
+		
+		intc: interrupt-controller@00070000 {
+			compatible = "arm,pl192-vic", "arm,primecell";
+			#interrupt-cells = <1>;
+			interrupt-controller;
+			valid-mask = <0x77DFFFFF>;
+			reg = <0x00070000 0x1000>;
+		};
+		
+		dmac0: dmac@000D0000 {
+			compatible = "arm,pl080", "arm,primecell";
+			reg = <0x000D0000 0x1000>;
+			interrupts = <15>;
+			interrupt-names = "dmac-int";
+			resets = <&perclkctl HI3515_SOFTRST_DMA>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+			lli-bus-interface-ahb2;
+			mem-bus-interface-ahb2;
+			memcpy-burst-size = <256>;
+			memcpy-bus-width = <32>;
+			#dma-cells = <2>;
+			dma-channels = <8>;
+		};
+		
+		
+		
+		cipher: cipher@000C0000 {
+			compatible = "hisilicon,hi3515cipher";
+			reg = <0x000C0000 0x1000>;
+			interrupts = <28>;
+			interrupt-names = "cipher-int";
+			resets = <&perclkctl HI3515_SOFTRST_CIPHER>;
+			clocks = <&perclkctl HI3515_PER_CLK_CIPHER>;
+			clock-names = "apb_pclk";
+			status = "okay";
+		};
+		
+		watchdog: wdt@10040000 {
+			compatible = "arm,sp805-wdt", "arm,primecell";
+			reg = <0x10040000 0x1000>;
+			clocks = <&wdt_clock_mux>, <&wdt_clock_mux>;
+			clock-names = "apb_pclk", "wdog_clk";
+			interrupts = <0>;
+			interrupt-names = "wdt-int";
+			status = "okay";
+		};
+		
+		rtc: rtc@10060000 {
+			compatible = "arm,rtc-pl031", "arm,primecell";
+			reg = <0x10060000 0x1000>;
+			clocks = <&clk_bus>;
+			clock-names = "apb_pclk";
+			interrupts = <10>;
+			interrupt-names = "rtc-int";
+			resets = <&perclkctl HI3515_SOFTRST_RTC>;
+			status = "okay";
+		};
+		
+		dual_timer01: timer@10000000  {
+			compatible = "arm,sp804", "arm,primecell";
+			interrupts = <4>;
+			reg = <0x10000000 0x1000>;
+			clocks = <&tmr0_mux>, <&tmr1_mux>;
+			clock-names = "apb_pclk";
+			status = "okay";
+		};
+
+		dual_timer23: timer@10010000 {
+			compatible = "arm,sp804", "arm,primecell";
+			interrupts = <5>;
+			reg = <0x10010000 0x1000>;
+			clocks = <&tmr2_mux>, <&tmr3_mux>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+		
+		nand: nand@00000000 {
+			compatible = "hisilicon,504-nfc";
+			reg = <0x00000000 0x1000>,
+				<0x60000000 0x04000000>;
+			interrupts = <30>;
+			nand-bus-width = <8>;
+			nand-ecc-mode = "hw";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			clocks = <&perclkctl HI3515_PER_CLK_NANDC>;
+			resets = <&perclkctl HI3515_SOFTRST_NANDC>;
+			status = "disabled";
+		};
+		
+		smi: nor@001000000 {
+			compatible = "hisilicon,hi3515smi";
+			reg = <0x001000000 0x1000>;
+			clocks = <&perclkctl HI3515_PER_CLK_SMI>;
+			clock-names = "smi0-clk";
+			resets = <&perclkctl HI3515_SOFTRST_SSMC>;
+			status = "disabled";
+		};
+		
+		mdio: mdio@00091100 {
+			compatible = "hisilicon,hisi-femac-mdio";
+			reg = <0x00091100 0x20>;
+			clocks = <&perclkctl HI3515_PER_CLK_ETH>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			phy0: phy@1 {
+				reg = <1>;
+			};
+			
+		};
+		
+		hisi_femac: ethernet@00090000 {
+			compatible = "hisilicon,hi3515-femac","hisilicon,hisi-femac-v1";
+			reg = <0x00090000 0x1000>, <0x00091300 0x200>;
+			interrupts = <14>;
+			clocks = <&perclkctl HI3515_PER_CLK_ETH>;
+			resets = <&perclkctl HI3515_SOFTRST_ETH>;
+			reset-names = "mac";
+			phy-mode = "mii";
+			phy-handle = <&phy0>;
+			hisilicon,phy-reset-delays-us = <10000 20000 20000>;
+			status = "disabled";
+		};
+		
+		mmc: mmc@00030000 {
+			compatible = "snps,dw-mshc";
+			reg = <0x00030000 0x1000>;
+			interrupts = <24>;
+			clocks = <&perclkctl HI3515_PER_CLK_MMC>, <&perclkctl HI3515_PER_CLK_MMC>;
+			clock-names = "biu", "ciu";
+			dmas = <&dmac0 HI3515_DMAREQ_MMC_RX 1>, <&dmac0 HI3515_DMAREQ_MMC_TX 1>;
+			dma-names = "rx", "tx";
+			resets = <&perclkctl HI3515_SOFTRST_MMC>;
+			reset-names = "reset";
+			pinctrl-0 = <&mux_VO_SDIO>;
+			status = "disabled";
+		};
+		
+		ahci: sata@00110000 {
+			compatible = "generic-ahci";
+			reg = <0x00110000 0x10000>;
+			interrupts = <29>;
+			clocks = <&perclkctl HI3515_PER_CLK_SATA>;
+			resets = <&perclkctl HI3515_SOFTRST_SATA>, <&perclkctl HI3515_SOFTRST_SATABUS>, <&perclkctl HI3515_SOFTRST_SATAPHY>, <&perclkctl HI3515_SOFTRST_SATATX0>, <&perclkctl HI3515_SOFTRST_SATATX1>, <&perclkctl HI3515_SOFTRST_SATARX0>, <&perclkctl HI3515_SOFTRST_SATARX1>, <&perclkctl HI3515_SOFTRST_SATAALIVE>;
+			status = "disabled";
+		};
+		
+		ehci: usb@000B0000 {
+			compatible = "generic-ehci";
+			reg = <0x000B0000 0x10000>;
+			interrupts = <23>;
+			clocks = <&perclkctl HI3515_PER_CLK_USB>;
+			resets = <&perclkctl HI3515_SOFTRST_USB>, <&perclkctl HI3515_SOFTRST_USBPORT>;
+			status = "disabled";
+		};
+		
+		ohci: usb@000A0000 {
+			compatible = "generic-ohci";
+			reg = <0x000A0000 0x10000>;
+			interrupts = <22>;
+			clocks = <&perclkctl HI3515_PER_CLK_USB>;
+			resets = <&perclkctl HI3515_SOFTRST_USB>, <&perclkctl HI3515_SOFTRST_USBPORT>;
+			status = "disabled";
+		};
+		
+		i2c: i2c@100D0000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x100D0000 0x1000>;
+			interrupts = <16>;
+			clocks = <&clk_i2c>;
+			resets = <&perclkctl HI3515_SOFTRST_I2C>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mux_I2C_I2C>;
+			status = "disabled";
+		};
+		
+		uart0: serial@10090000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x10090000 0x1000>;
+			interrupts = <12>;
+			clocks = <&perclkctl HI3515_PER_CLK_UART0>;
+			resets = <&perclkctl HI3515_SOFTRST_UART0>;
+			clock-names = "apb_pclk";
+			dmas = <&dmac0 HI3515_DMAREQ_UART0_RX 1>, <&dmac0 HI3515_DMAREQ_UART0_TX 1>;
+			dma-names = "rx", "tx";
+			status = "okay";
+		};
+		
+		uart1: serial@100A0000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x100A0000 0x1000>;
+			interrupts = <12>;
+			clocks = <&perclkctl HI3515_PER_CLK_UART1>;
+			resets = <&perclkctl HI3515_SOFTRST_UART1>;
+			clock-names = "apb_pclk";
+			dmas = <&dmac0 HI3515_DMAREQ_UART1_RX 1>, <&dmac0 HI3515_DMAREQ_UART1_TX 1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+		
+		uart2: serial@100B0000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x100B0000 0x1000>;
+			interrupts = <13>;
+			clocks = <&perclkctl HI3515_PER_CLK_UART2>;
+			resets = <&perclkctl HI3515_SOFTRST_UART2>;
+			clock-names = "apb_pclk";
+			dmas = <&dmac0 HI3515_DMAREQ_UART2_RX 1>, <&dmac0 HI3515_DMAREQ_UART2_TX 1>;
+			dma-names = "rx", "tx";
+			pinctrl-0 = <&mux_VI0S_UART2>;
+			status = "disabled";
+		};
+		
+		uart3: serial@100C0000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x100C0000 0x1000>;
+			interrupts = <13>;
+			clocks = <&perclkctl HI3515_PER_CLK_UART3>;
+			resets = <&perclkctl HI3515_SOFTRST_UART3>;
+			clock-names = "apb_pclk";
+			pinctrl-0 = <&mux_VI2S_UART3>;
+			status = "disabled";
+		};
+		
+		spi: spi@100E0000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x100E0000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <11>;
+			resets = <&perclkctl HI3515_SOFTRST_SPI>;
+			dmas = <&dmac0 HI3515_DMAREQ_SPI_RX 1>, <&dmac0 HI3515_DMAREQ_SPI_TX 1>;
+			dma-names = "rx", "tx";
+			pinctrl-0 = <&mux_VO_SPI>;
+			status = "disabled";
+		};
+		
+		ir: ir@100700000 {
+			compatible = "hisilicon,hix5hd2-ir";
+			reg = <0x10070000 0x1000>;
+			interrupts = <9>;
+			clocks = <&perclkctl HI3515_PER_CLK_IR>;
+			resets = <&perclkctl HI3515_SOFTRST_IR>;
+			pinctrl-0 = <&mux_EBI_IR>;
+			status = "disabled";
+		};
+		
+		fb: fb@10130000 {
+			compatible = "hisilicon,hi3515vgafb";
+			reg = <0x10130000 0x10000>;
+			interrupts = <19>;
+			clocks = <&perclkctl HI3515_PER_CLK_VOBUS>, <&perclkctl HI3515_PER_CLK_VOHD>, <&perclkctl HI3515_PER_CLK_VDAC0>, <&perclkctl HI3515_PER_CLK_VDAC1>, <&vpll1>;
+			clock-names = "bus", "vohd", "vdac0", "vdac1", "vpll1";
+			resets = <&perclkctl HI3515_SOFTRST_VOBUS>, <&perclkctl HI3515_SOFTRST_VOHD>;
+			status = "disabled";
+		};
+		
+		sio0: sio@000400000 {
+			compatible = "hisilicon,hi3515sio";
+			reg = <0x00040000 0x1000>;
+			interrupts = <25>;
+			clocks = <&perclkctl HI3515_PER_CLK_SIO0>;
+			clock-names = "bus";
+			resets = <&perclkctl HI3515_SOFTRST_SIO0>;
+			dmas = <&dmac0 HI3515_DMAREQ_SIO0_RX 1>, <&dmac0 HI3515_DMAREQ_SIO0_TX 1>;
+			dma-names = "rx", "tx";
+			pinctrl-0 = <&mux_SIO_SIO>;
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+		
+		sio1: sio@000500000 {
+			compatible = "hisilicon,hi3515sio";
+			reg = <0x00050000 0x1000>;
+			interrupts = <26>;
+			clocks = <&perclkctl HI3515_PER_CLK_SIO1>;
+			clock-names = "bus";
+			resets = <&perclkctl HI3515_SOFTRST_SIO1>;
+			dmas = <&dmac0 HI3515_DMAREQ_SIO1_RX 1>, <&dmac0 HI3515_DMAREQ_SIO1_TX 1>;
+			dma-names = "rx", "tx";
+			pinctrl-0 = <&mux_SIO_SIO>;
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+		
+	};
+	
+	sound_card: sound {
+		compatible = "simple-audio-card";
+		label = "snd-hi3515";
+		simple-audio-card,name = "snd-hi3515";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&cpu_dai>;
+		simple-audio-card,frame-master = <&cpu_dai>;
+		
+		cpu_dai: simple-audio-card,cpu@0 {
+			sound-dai = <&sio0>;
+		};
+		
+
+	};
+};
diff --no-dereference -ruN linux-master/arch/arm/boot/dts/hisilicon/Makefile linux-master-mod/arch/arm/boot/dts/hisilicon/Makefile
--- linux-master/arch/arm/boot/dts/hisilicon/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/boot/dts/hisilicon/Makefile	2024-10-17 18:53:21.409915995 +0300
@@ -11,3 +11,5 @@
 	hisi-x5hd2-dkb.dtb
 dtb-$(CONFIG_ARCH_SD5203) += \
 	sd5203.dtb
+dtb-$(CONFIG_ARCH_HI3515V100) += \
+	hi3515v100-avtech-dr082.dtb
diff --no-dereference -ruN linux-master/arch/arm/configs/hi3515v100_full_release_defconfig linux-master-mod/arch/arm/configs/hi3515v100_full_release_defconfig
--- linux-master/arch/arm/configs/hi3515v100_full_release_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/configs/hi3515v100_full_release_defconfig	2024-10-15 00:47:12.582553543 +0300
@@ -0,0 +1,1600 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24
+# Fri Nov 20 09:15:27 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_HISILICON_ARM926ejs=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-rt1-hi3515v100"
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_CGROUPS is not set
+# CONFIG_FAIR_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+# CONFIG_RADIX_TREE_CONCURRENT is not set
+# CONFIG_HAVE_IMMEDIATE is not set
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Linux Trace Toolkit
+#
+CONFIG_LTT_TIMESTAMP=y
+# CONFIG_HAVE_LTT_UNSTABLE_TSC is not set
+# CONFIG_HAVE_LTT_CLOCK is not set
+CONFIG_HAVE_LTT_SYNTHETIC_TSC=y
+# CONFIG_HAVE_LTT_DUMP_TABLES is not set
+# CONFIG_HAVE_OPROFILE is not set
+# CONFIG_HAVE_KPROBES is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_LSF=y
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=m
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=m
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_ARCH_hi3515v100=y
+
+#
+# Board Features
+#
+CONFIG_HISILICON_KCONSOLE=0
+CONFIG_HISILICON_EDB_LEVEL=255
+CONFIG_DEFAULT_MPLLIN=24000000
+CONFIG_DEFAULT_BUSCLK=230000000
+CONFIG_CPUCLK_MULTI=2
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT_DESKTOP is not set
+# CONFIG_PREEMPT_RT is not set
+# CONFIG_PREEMPT_SOFTIRQS is not set
+# CONFIG_PREEMPT_HARDIRQS is not set
+# CONFIG_PREEMPT_BKL is not set
+CONFIG_CLASSIC_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=32M console=ttyAMA0"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=m
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_TUNNEL=m
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_SCH_FIFO=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+CONFIG_CFG80211=m
+# CONFIG_NL80211 is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_MAC80211=m
+CONFIG_MAC80211_RCSIMPLE=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+CONFIG_IEEE80211_SOFTMAC=m
+# CONFIG_IEEE80211_SOFTMAC_DEBUG is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+CONFIG_MTD_OOPS=y
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x80000000
+CONFIG_MTD_PHYSMAP_LEN=0x4000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=1
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_HINAND=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_UB=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=4096
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+CONFIG_MISC_DEVICES=y
+CONFIG_EEPROM_93CX6=m
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+# CONFIG_SCSI_FC_TGT_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_LIBSAS_DEBUG=y
+CONFIG_SCSI_SRP_ATTRS=m
+# CONFIG_SCSI_SRP_TGT_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_SVW is not set
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_NETDEVICES_MULTIQUEUE=y
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+CONFIG_VITESSE_PHY=m
+CONFIG_SMSC_PHY=m
+CONFIG_BROADCOM_PHY=m
+CONFIG_ICPLUS_PHY=m
+CONFIG_FIXED_PHY=m
+CONFIG_FIXED_MII_10_FDX=y
+CONFIG_FIXED_MII_100_FDX=y
+# CONFIG_FIXED_MII_1000_FDX is not set
+CONFIG_FIXED_MII_AMNT=1
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+# CONFIG_LIBERTAS is not set
+CONFIG_USB_ZD1201=m
+CONFIG_RTL8187=m
+CONFIG_P54_COMMON=m
+# CONFIG_P54_USB is not set
+CONFIG_HOSTAP=m
+# CONFIG_HOSTAP_FIRMWARE is not set
+CONFIG_B43=m
+# CONFIG_B43_DEBUG is not set
+CONFIG_B43_DMA=y
+CONFIG_B43_PIO=y
+CONFIG_B43_DMA_AND_PIO_MODE=y
+# CONFIG_B43_DMA_MODE is not set
+# CONFIG_B43_PIO_MODE is not set
+CONFIG_B43LEGACY=m
+# CONFIG_B43LEGACY_DEBUG is not set
+CONFIG_B43LEGACY_DMA=y
+CONFIG_B43LEGACY_PIO=y
+CONFIG_B43LEGACY_DMA_AND_PIO_MODE=y
+# CONFIG_B43LEGACY_DMA_MODE is not set
+# CONFIG_B43LEGACY_PIO_MODE is not set
+CONFIG_ZD1211RW=m
+# CONFIG_ZD1211RW_DEBUG is not set
+CONFIG_RT2X00=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+# CONFIG_RT2X00_DEBUG is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_DM9601 is not set
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+# CONFIG_USB_NET_MCS7830 is not set
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLHC=m
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=m
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=m
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+CONFIG_GAMEPORT=m
+CONFIG_GAMEPORT_NS558=m
+CONFIG_GAMEPORT_L4=m
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_RMEM=y
+CONFIG_ALLOC_RTSJ_MEM=m
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PARPORT_LIGHT=m
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_TAOS_EVM is not set
+CONFIG_I2C_STUB=m
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+CONFIG_SENSORS_DS1337=m
+CONFIG_SENSORS_DS1374=m
+# CONFIG_DS1682 is not set
+CONFIG_SENSORS_EEPROM=m
+CONFIG_SENSORS_PCF8574=m
+CONFIG_SENSORS_PCA9539=m
+CONFIG_SENSORS_PCF8591=m
+CONFIG_SENSORS_MAX6875=m
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_AT25=m
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+CONFIG_SSB=m
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=m
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=m
+CONFIG_FB_SYS_COPYAREA=m
+CONFIG_FB_SYS_IMAGEBLIT=m
+CONFIG_FB_SYS_FOPS=m
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_VIRTUAL=m
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_LTV350QV is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=m
+# CONFIG_BACKLIGHT_CORGI is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+CONFIG_USB_SERIAL_AIRPRIME=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP2101=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_OTI6858 is not set
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_EZUSB=y
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+# CONFIG_USB_ADUTUX is not set
+CONFIG_USB_AUERSWALD=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+# CONFIG_USB_BERRY_CHARGE is not set
+CONFIG_USB_LED=m
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+CONFIG_USB_IDMOUSE=m
+# CONFIG_USB_FTDI_ELAN is not set
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_LD=m
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+CONFIG_USB_TEST=m
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+CONFIG_USB_GADGET_M66592=y
+CONFIG_USB_M66592=m
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=m
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=m
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL031 is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+CONFIG_REISERFS_PROC_INFO=y
+# CONFIG_REISERFS_FS_XATTR is not set
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+# CONFIG_JFS_SECURITY is not set
+# CONFIG_JFS_DEBUG is not set
+CONFIG_JFS_STATISTICS=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_XFS_FS=m
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+CONFIG_GFS2_FS=m
+CONFIG_GFS2_FS_LOCKING_NOLOCK=m
+CONFIG_GFS2_FS_LOCKING_DLM=m
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=m
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_JFFS2_RUBIN=y
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
+CONFIG_CIFS=m
+CONFIG_CIFS_STATS=y
+# CONFIG_CIFS_STATS2 is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+CONFIG_DLM=m
+# CONFIG_DLM_DEBUG is not set
+CONFIG_INSTRUMENTATION=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_EVENT_TRACE is not set
+# CONFIG_WAKEUP_TIMING is not set
+# CONFIG_CRITICAL_IRQSOFF_TIMING is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_FORCED_INLINING is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SAMPLES is not set
+
+#
+# GCOV coverage profiling
+#
+# CONFIG_GCOV_PROFILE is not set
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=m
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_FCRYPT is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --no-dereference -ruN linux-master/arch/arm/Kconfig linux-master-mod/arch/arm/Kconfig
--- linux-master/arch/arm/Kconfig	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/Kconfig	2024-10-17 18:51:42.454978408 +0300
@@ -146,7 +146,7 @@
 	select PCI_SYSCALL if PCI
 	select PERF_USE_VMALLOC
 	select RTC_LIB
-	select SPARSE_IRQ if !(ARCH_FOOTBRIDGE || ARCH_RPC)
+	select SPARSE_IRQ if !(ARCH_FOOTBRIDGE || ARCH_RPC || ARCH_HI3515V100)
 	select SYS_SUPPORTS_APM_EMULATION
 	select THREAD_INFO_IN_TASK
 	select TIMER_OF if OF
@@ -255,6 +255,9 @@
 config FIQ
 	bool
 
+config HISILICON_ARM926ejs
+	bool
+
 config ARCH_MTD_XIP
 	bool
 
@@ -355,6 +358,9 @@
 # Kconfigs may be included either alphabetically (according to the
 # plat- suffix) or along side the corresponding mach-* source.
 #
+
+source "arch/arm/mach-hi3515v100/Kconfig"
+
 source "arch/arm/mach-actions/Kconfig"
 
 source "arch/arm/mach-alpine/Kconfig"
diff --no-dereference -ruN linux-master/arch/arm/Kconfig.debug linux-master-mod/arch/arm/Kconfig.debug
--- linux-master/arch/arm/Kconfig.debug	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/Kconfig.debug	2024-10-17 22:45:54.893882662 +0300
@@ -1355,6 +1355,12 @@
 		  Note that the system will appear to hang during boot if there
 		  is nothing connected to read from the DCC.
 
+	config DEBUG_HI3515
+		bool "Kernel low-level debugging via HI3515 UART"
+		help
+		  Say Y here if you want the debug print routines to direct
+		  their output to the HI3515 uart block
+
 	config DEBUG_SEMIHOSTING
 		bool "Kernel low-level debug output via semihosting I/O"
 		help
@@ -1486,6 +1492,7 @@
 	default "debug/pl01x.S" if DEBUG_LL_UART_PL01X || DEBUG_UART_PL01X
 	default "debug/exynos.S" if DEBUG_EXYNOS_UART
 	default "debug/icedcc.S" if DEBUG_ICEDCC
+	default "debug/hi3515-debug-macro.S" if DEBUG_HI3515
 	default "debug/imx.S" if DEBUG_IMX1_UART || \
 				 DEBUG_IMX25_UART || \
 				 DEBUG_IMX27_UART || \
@@ -1811,7 +1818,7 @@
 
 config UNCOMPRESS_INCLUDE
 	string
-	default "mach/uncompress.h" if ARCH_FOOTBRIDGE || ARCH_RPC || ARCH_SA1100
+	default "mach/uncompress.h" if ARCH_FOOTBRIDGE || ARCH_RPC || ARCH_SA1100 || ARCH_HI3515V100
 	default "debug/uncompress.h"
 
 config EARLY_PRINTK
diff --no-dereference -ruN linux-master/arch/arm/kernel/head-common.S linux-master-mod/arch/arm/kernel/head-common.S
--- linux-master/arch/arm/kernel/head-common.S	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/kernel/head-common.S	2024-10-15 00:59:02.570289615 +0300
@@ -237,3 +237,52 @@
 1:	mov	r0, r0
 	b	1b
 ENDPROC(__error)
+
+
+
+@__uart_print_char:
+@    ldr r3, =0x20090000
+@    str r4, [r3]
+@_wait:	
+@    ldr r4, [r3, #0x18]       @UART_FR
+@	ands r4, r4, #0b1000
+@	bne _wait
+@	mov pc, lr
+@	
+@__uart_print_int:
+@    @int in r4
+@    str lr, [sp, #-4]!
+@    str r0, [sp, #-4]!
+@    str r1, [sp, #-4]!
+@    str r2, [sp, #-4]!
+@    str r3, [sp, #-4]!
+@    mov r6, #10
+@_conv:
+@    mov r0, r4
+@    bl idiv
+@    mov r4, r2
+@    add r4, #0x30
+@    bl __uart_print_char
+@    mov r4, r1
+@    subs r6, r6, #1
+@    bne _conv
+@
+@    ldr r3, [sp], #4
+@    ldr r2, [sp], #4
+@    ldr r1, [sp], #4
+@    ldr r0, [sp], #4
+@    ldr lr, [sp], #4
+@    mov pc, lr
+    
+@ Entry  r0: numerator (lo) must be signed positive
+@idiv:
+@        ldr    r3,=0xcccccccd
+@        umull  r1,r2,r0,r3
+@        mov    r1,r2,lsr #3
+@        mov r2, r1
+@        mov r3, #10
+@        mul r2, r2, r3
+@        sub r2, r0, r2
+@        mov pc, lr @ return
+@ Exit   r1: quotient (lo)
+@        r2: remainder (hi)
diff --no-dereference -ruN linux-master/arch/arm/kernel/head.S linux-master-mod/arch/arm/kernel/head.S
--- linux-master/arch/arm/kernel/head.S	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/kernel/head.S	2024-10-16 17:17:54.807260387 +0300
@@ -171,7 +171,11 @@
 	ret	r12
 1:	b	__enable_mmu
 ENDPROC(stext)
+
 	.ltorg
+	
+	
+
 
 /*
  * Setup the initial page tables.  We only setup the barest
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/ahb-clock.c linux-master-mod/arch/arm/mach-hi3515v100/ahb-clock.c
--- linux-master/arch/arm/mach-hi3515v100/ahb-clock.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/ahb-clock.c	2024-10-15 22:23:15.967541845 +0300
@@ -0,0 +1,164 @@
+/* linux/arch/arm/mach-hi3515_v100/ahb-clock.c
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+
+#include <linux/semaphore.h>
+#include <linux/clk.h>
+
+#include <mach/system.h>
+#include <mach/clock.h>
+#include <mach/early-debug.h>
+
+static unsigned long hil_def_ahbclk = CONFIG_DEFAULT_BUSCLK;
+static unsigned long set_busclk = 0;
+
+static int __init hil_setup_bus_clock(char *s)
+{
+	hil_def_ahbclk = simple_strtoul(s, NULL, 0);
+	set_busclk = 1;
+	
+	return 0;
+}
+__setup("busclk=", hil_setup_bus_clock);
+
+unsigned long get_ahbclk_hw(void)
+{
+#if 0
+	unsigned long pllc = RD_PLLC();
+
+	return PLLC_TO_AHBCLK(pllc);
+#endif
+	if (set_busclk)
+	{
+		return hil_def_ahbclk;
+	}
+
+	/* read clk from PLL */
+	return CONFIG_DEFAULT_BUSCLK;
+}
+
+static int ahb_clock_notifier(struct clk *clk, 
+		unsigned int cmd, unsigned long wparam, unsigned long lparam)
+{
+	int ret = 0;
+	ulong pllc;
+	struct clk *p;
+
+	switch(cmd) {
+	case HISILICON_CLK_REGISTER:
+		edb_trace(1);
+
+		clk->rate = get_ahbclk_hw() ;
+		clk_notify_childs(clk, HISILICON_CLK_PARENT_SETRATE, clk->rate, lparam);
+
+		hisilicon_trace(2,"AHB clock is %lu HZ", clk->rate);
+		break;
+
+	case HISILICON_CLK_SETRATE:
+	case HISILICON_CLK_PARENT_SETRATE:
+		printk(KERN_INFO "currently do not support busclk change!\n");
+		break;
+
+	default:
+		ret =  hisilicon_clk_default_notifier(clk, cmd, wparam, lparam);
+		break;
+	}
+
+	return ret;
+}
+
+static int armcore_clock_notifier(struct clk *clk, 
+		unsigned int cmd, unsigned long wparam, unsigned long lparam)
+{
+	int ret = 0;
+	struct clk *p;
+	
+	switch(cmd) {
+	case HISILICON_CLK_REGISTER:
+		p = clk_get_parent(clk);
+		if(p)
+			clk->rate = BUSCLK_TO_CPUCLK(clk_get_rate(p));
+		break;
+
+	case HISILICON_CLK_SETRATE:
+		p = clk_get_parent(clk);
+		if(p)
+			clk_set_rate(p, BUSCLK_TO_CPUCLK(wparam));
+		clk_notify_childs(clk, HISILICON_CLK_PARENT_SETRATE, clk->rate, lparam);
+		break;
+
+	case HISILICON_CLK_PARENT_SETRATE:
+		clk->rate = BUSCLK_TO_CPUCLK(wparam);
+		clk_notify_childs(clk, HISILICON_CLK_PARENT_SETRATE, clk->rate, lparam);
+		break;
+
+	default:
+		ret =  hisilicon_clk_default_notifier(clk, cmd, wparam, lparam);
+		break;
+	}
+
+	return ret;
+}
+
+static struct clk xtal_clk = {
+	.name		= "PLLIN",
+	.rate		= CONFIG_DEFAULT_MPLLIN,
+};
+
+static struct clk ahb_clk = {
+	.name		= "BUSCLK",
+	.rate		= CONFIG_DEFAULT_BUSCLK,
+	//.parent_name	= "PLLIN",
+	//.notifier	= ahb_clock_notifier,
+};
+
+static struct clk armcore_clk = {
+	.name		= "CPUCLK",
+	.rate		= BUSCLK_TO_CPUCLK(CONFIG_DEFAULT_BUSCLK),
+	//.parent_name	= "BUSCLK",
+	//.notifier	= armcore_clock_notifier,
+};
+
+static struct clk timer2_clk = {
+	.name		= "TIMER2CLK",
+	.parent_name = "BUSCLK",
+};
+
+
+static int __init ahbclk_init(void)
+{
+	ahb_clk.rate = get_ahbclk_hw();
+	armcore_clk.rate = BUSCLK_TO_CPUCLK(get_ahbclk_hw());
+	clk_register(&xtal_clk);
+	clk_register(&ahb_clk);
+	clk_register(&armcore_clk);
+	clk_register(&timer2_clk);
+
+	return 0;
+}
+
+subsys_initcall(ahbclk_init);
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/clock.c linux-master-mod/arch/arm/mach-hi3515v100/clock.c
--- linux-master/arch/arm/mach-hi3515v100/clock.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/clock.c	2024-10-16 23:08:52.223032734 +0300
@@ -0,0 +1,350 @@
+/* linux/arch/arm/mach-hi3515_v100/clock.c
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+
+#include <linux/string.h>
+
+#include <linux/semaphore.h>
+#include <linux/clk.h>
+
+#include <mach/system.h>
+#include <mach/clock.h>
+#include <mach/early-debug.h>
+
+#include <linux/proc_fs.h>
+
+static LIST_HEAD(clocks);
+static DEFINE_SEMAPHORE(clocks_sem, 1);
+
+typedef int (*clk_walker_t)(struct clk*, int, unsigned long []);
+
+int hisilicon_clk_default_notifier(struct clk *clk, 
+		unsigned int cmd, unsigned long wparam, unsigned long lparam)
+{
+	int ret = 0;
+
+	switch(cmd)
+	{
+	case HISILICON_CLK_PARENT_DEL:
+		hisilicon_trace(2,"HISILICON_CLK_PARENT_DEL: %s, P: %s", clk->name, clk->parent_name);
+		break;
+
+	case HISILICON_CLK_SETRATE:
+		clk->rate = wparam;
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int __clk_walk_r(struct list_head *clk_list, clk_walker_t __walk_callback, int level, unsigned long data[])
+{
+	struct clk *p;
+	int ret = 0;
+
+	list_for_each_entry(p, clk_list, list)
+	{
+		if(__walk_callback(p, level, data))
+			break;
+		ret = __clk_walk_r(&p->child_list, __walk_callback,level+1, data);
+		if(ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int __clk_walk(clk_walker_t __walk_callback, unsigned long data[])
+{
+	if(__walk_callback == NULL)
+		return 0;
+
+	return __clk_walk_r(&clocks, __walk_callback, 0, data);
+}
+
+static int __clk_get_walker(struct clk *clk, int level, unsigned long data[])
+{
+	const char *name = (const char*)data[0];
+
+	if (strcmp(name, clk->name) == 0 && try_module_get(clk->owner))
+	{
+		data[1] = (unsigned long)clk;
+		return 1;
+	}
+
+	return 0;
+}
+static struct clk *__clk_get(struct device *dev, const char *name)
+{
+	unsigned long _clk_get_data[2] = {(unsigned long)name, 0};
+
+	if(name==NULL)
+		return NULL;
+	if(strlen(name)==0)
+		return NULL;
+
+	__clk_walk(__clk_get_walker, _clk_get_data);
+
+	return (struct clk*)_clk_get_data[1];
+}
+struct clk *clk_get(struct device *dev, const char *name)
+{
+	printk("CLKGET: 0x%x  %s\n",(uint32_t)dev, name);
+	struct clk *clk = NULL;
+
+	down(&clocks_sem);
+	clk = __clk_get(dev, name);
+	up(&clocks_sem);
+	
+	printk("CLKGET: RET 0x%x\n",(uint32_t)clk);
+
+	return clk;
+}
+
+static int __clk_info_walker(struct clk *clk, int level, unsigned long data[])
+{
+	char *buf = (char*)data[0];
+	int len=(int)data[1];
+	int pos=0;
+
+	while(level-- && len>pos)
+		pos += snprintf(buf+pos,len-pos,".   ");
+
+	pos += snprintf(buf+pos,len-pos,"|---");
+	pos += snprintf(buf+pos,len-pos," %s, %lu, %s\n", clk->name, clk->rate, clk->parent_name);
+
+	if(pos>=len)
+	{
+		pos=len;
+		buf[pos-1]='\0';
+	}
+	data[0]=(unsigned long)buf+pos;
+	data[1]=len-pos;
+	data[2]++;
+
+	return pos>=len;
+}
+int clk_info(char *buf, int len)
+{
+	unsigned long _clk_info_data[3] = {(unsigned long)buf, len, 0};
+	int t;
+
+	down(&clocks_sem);
+	__clk_walk(__clk_info_walker, _clk_info_data);
+
+	t = (int)_clk_info_data[1];
+	t -= snprintf((char*)_clk_info_data[0],t, "%d clocks total\n", (int)_clk_info_data[2]);
+	if(t<=0)
+	{
+		t = 0;
+		buf[len-1] = '\0';
+	}
+	up(&clocks_sem);
+
+	return len-t;
+}
+
+
+void clk_put(struct clk *clk)
+{
+	printk("CLKPUT: 0x%x 0x%x\n",(uint32_t)clk, (uint32_t)clk->owner);
+	module_put(clk->owner);
+}
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+
+void clk_disable(struct clk *clk)
+{
+}
+
+int clk_use(struct clk *clk)
+{
+	return 0;
+}
+
+void clk_unuse(struct clk *clk)
+{
+}
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return rate;
+}
+
+int clk_notify_childs(struct clk *clk, unsigned int cmd, unsigned long wparam, unsigned long lparam)
+{
+	struct clk *p;
+
+	list_for_each_entry(p, &clk->child_list, list)
+		p->notifier(p, cmd, wparam, lparam);
+
+	return 0;
+}
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->notifier(clk, HISILICON_CLK_SETRATE, rate, clk_get_rate(clk));
+}
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	down(&clocks_sem);
+	if(!list_empty(&clk->list))
+		list_del(&clk->list);
+	list_add(&clk->list, &parent->child_list);
+	strcpy(clk->parent_name, parent->name);
+	up(&clocks_sem);
+
+	return 0;
+}
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+	return clk_get(NULL, clk->parent_name);
+}
+
+int clk_register(struct clk *clk)
+{
+	struct list_head *_clk_head = &clocks;
+	struct clk *parent = NULL;
+
+	hisilicon_trace(2,"%s", clk->name);
+
+	if(clk_get(NULL, clk->name))
+	{
+		printk(KERN_WARNING "clock %s exist, register failed.\n", clk->name);
+		clk_put(clk);
+		return -1;
+	}
+
+	if(strlen(clk->parent_name)==0)
+		strcpy(clk->parent_name, "<NULL>");
+	parent = clk_get(NULL, clk->parent_name);
+	if(parent)
+		_clk_head = &parent->child_list;
+
+	INIT_LIST_HEAD(&clk->child_list);
+	if(clk->notifier == NULL)
+		clk->notifier = hisilicon_clk_default_notifier;
+
+	down(&clocks_sem);
+	list_add(&clk->list, _clk_head);
+	up(&clocks_sem);
+
+	if(parent)
+		clk_put(parent);
+
+	//return clk->notifier(clk, HISILICON_CLK_REGISTER, 0, 0);
+	return 0;
+}
+
+void clk_unregister(struct clk *clk)
+{
+	hisilicon_trace(2,"%s", clk->name);
+
+	down(&clocks_sem);
+	list_del(&clk->list);
+	up(&clocks_sem);
+
+	if(list_empty(&clk->child_list))
+		return;
+
+	while(!list_empty(&clk->child_list))
+	{
+		struct clk *p;
+
+		down(&clocks_sem);
+		p = list_entry(clk->child_list.next, struct clk, list);
+		list_del(&p->list);
+		list_add(&p->list, &clocks);
+		up(&clocks_sem);
+
+		p->notifier(p, HISILICON_CLK_PARENT_DEL, 0, 0);
+	}
+	
+}
+
+#ifdef CONFIG_PROC_FS
+
+// static int clk_proc_get_info(char *buf, char **start, off_t off, int count)
+static ssize_t clk_proc_get_info(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	return clk_info(buf, count);
+}
+
+static const struct proc_ops hiclocks_proc_ops = {
+	.proc_read	= clk_proc_get_info,
+	.proc_lseek	= default_llseek,
+};
+
+static int __init clk_info_init(void)
+{
+	// create_proc_info_entry("clocks", 0444, NULL, clk_proc_get_info);
+	proc_create("clocks", 0444, NULL, &hiclocks_proc_ops);
+
+	return 0;
+}
+
+module_init(clk_info_init);
+
+#endif /* CONFIG_PROC_FS */
+
+static int __init clk_init(void)
+{
+	printk(KERN_INFO "Hisilicon clock system V0.01\n");
+
+	return 0;
+}
+arch_initcall(clk_init);
+
+
+EXPORT_SYMBOL(clk_register);
+EXPORT_SYMBOL(clk_unregister);
+EXPORT_SYMBOL(clk_set_rate);
+EXPORT_SYMBOL(clk_get_rate);
+EXPORT_SYMBOL(clk_round_rate);
+EXPORT_SYMBOL(clk_use);
+EXPORT_SYMBOL(clk_unuse);
+EXPORT_SYMBOL(clk_enable);
+EXPORT_SYMBOL(clk_disable);
+EXPORT_SYMBOL(clk_get);
+EXPORT_SYMBOL(clk_put);
+EXPORT_SYMBOL(clk_set_parent);
+EXPORT_SYMBOL(clk_get_parent);
+EXPORT_SYMBOL(clk_info);
+EXPORT_SYMBOL(clk_notify_childs);
+EXPORT_SYMBOL(hisilicon_clk_default_notifier);
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/core.c linux-master-mod/arch/arm/mach-hi3515v100/core.c
--- linux-master/arch/arm/mach-hi3515v100/core.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/core.c	2024-10-17 22:41:07.529541395 +0300
@@ -0,0 +1,727 @@
+/* linux/arch/arm/mach-hi3515v100/core.c
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+// #include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/device.h>
+// #include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/amba/bus.h>
+// #include <linux/amba/clcd.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/sched_clock.h>
+
+// #include <asm/hardware/arm_timer.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/map.h>
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#include <mach/io.h>
+#include <mach/timer.h>
+#include <mach/led.h>
+#include <mach/early-debug.h>
+#include <asm/proc-fns.h>
+// #include <asm/cpu-single.h>
+#include <asm/irq.h>
+// #include <asm/leds.h>
+// #include <asm/system.h>
+// #include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+
+#include <asm/exception.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define ioaddr_intc(x) (void*)IO_ADDRESS(REG_BASE_INTC + (x))
+unsigned long hisilicon_irq_prio_masks[8] = {
+	(1<<INTNR_VOU) | (1<<INTNR_VIU),
+	(1<<INTNR_DMAC) | (1<<INTNR_VEDU),
+	(1<<INTNR_TDE),
+	(1<<INTNR_ETH) | (1<<INTNR_SATA) | (1<<INTNR_SDIO),
+	~0,
+	0,
+};
+#ifdef CONFIG_HI_PRIO_IRQ
+extern int hi_vic_status;
+extern unsigned int hi_vic_mask[HI_NR_IRQS];
+extern unsigned int hi_prio_stack[HI_NR_IRQS];
+extern struct hi_irq_prio hi_irq_prio_array[HI_NR_IRQS];
+#endif 
+
+#define do_level_IRQ    handle_level_irq
+static void hil_ack_irq(struct irq_data *data)
+{
+        data->irq -= INTNR_IRQ_START;
+        writel(1<<(data->irq), ioaddr_intc(REG_INTC_INTENCLEAR));
+}
+
+static void hil_mask_irq(struct irq_data *data)
+{
+	data->irq -= INTNR_IRQ_START;
+#ifdef CONFIG_HI_PRIO_IRQ
+	if(hi_vic_status >= 0){
+		int mask = ~(1 << data->irq);
+		int i;
+		for(i = hi_vic_status; i >= 0; i--){
+			hi_vic_mask[i] &= mask;
+		}
+	}
+#endif
+	writel(1<<(data->irq), ioaddr_intc(REG_INTC_INTENCLEAR));
+}
+
+static void hil_unmask_irq(struct irq_data *data)
+{
+	data->irq -= INTNR_IRQ_START;
+#ifdef CONFIG_HI_PRIO_IRQ
+	if(hi_vic_status >= 0 ){
+		/* Get current irq's priority from hi_irq_prio_array */
+		int prio = hi_irq_prio_array[data->irq].prio;
+		int i;
+
+		/* from top because high prio at top */
+		for (i = hi_vic_status; i >=0; i--){
+			/* find if this irq's priority unmasked by vic disable*/
+			if(hi_prio_stack[i] < prio){
+				hi_vic_mask[i] |= (1 << data->irq);
+				return;
+			}
+		}
+	}
+#endif 
+	writel(1<<(data->irq), ioaddr_intc(REG_INTC_INTENABLE));
+}
+
+static struct irq_chip hic_chip = {
+	.irq_ack	= hil_ack_irq,
+	.irq_mask	= hil_mask_irq,
+	.irq_unmask	= hil_unmask_irq,
+	.irq_disable 	= hil_mask_irq,
+};
+
+static struct irq_domain *idomain;
+static struct device_node *idevnode;
+static void __iomem *hi_intc_base;
+
+static bool irq_domain_is_nomap(struct irq_domain *domain)
+{
+	return IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&
+	       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);
+}
+
+static void __exception_irq_entry hisi_intc_handle_irq(struct pt_regs *regs)
+{
+	u32 stat = readl_relaxed(hi_intc_base + REG_INTC_IRQSTATUS);
+	u32 hwirq;
+
+	while (stat) {
+		hwirq = __fls(stat);
+
+		generic_handle_domain_irq(idomain, hwirq);
+		
+		
+		
+		
+// 		struct irq_desc *desc = NULL;
+// 		struct irq_data *data;
+// 
+// 		/* Look for default domain if necessary */
+// 		if (idomain != NULL) {
+// 			early_printk("IA\n");
+// 			// domain = irq_default_domain;
+// 
+// 			if (irq_domain_is_nomap(idomain)) {
+// 				early_printk("IB\n");
+// 				if (hwirq < idomain->hwirq_max) {
+// 					early_printk("IC\n");
+// 					data = irq_domain_get_irq_data(idomain, hwirq);
+// 					if (data && data->hwirq == hwirq)
+// 						desc = irq_data_to_desc(data);
+// 				}
+// 			} else {
+// 				early_printk("ID\n");
+// 				rcu_read_lock();
+// 				/* Check if the hwirq is in the linear revmap. */
+// 				if (hwirq < idomain->revmap_size) {
+// 					data = rcu_dereference(idomain->revmap[hwirq]);
+// 					early_printk("IG\n");
+// 				}
+// 				else {
+// 					data = radix_tree_lookup(&idomain->revmap_tree, hwirq);
+// 					early_printk("IH\n");
+// 				}
+// 				early_printk("IE\n");
+// 				if (likely(data)) {
+// 					early_printk("IF\n");
+// 					desc = irq_data_to_desc(data);
+// 				}
+// 
+// 				rcu_read_unlock();
+// 			}
+// 		}
+// 		
+// 		
+// 		
+// 		
+// 		if(desc) {
+// 			early_printk("I %lu ID_H:%lx\n", hwirq, (uint32_t)desc->handle_irq);
+// 		} else {
+// 			early_printk("I %lu N\n", hwirq);
+// 		}
+// 		handle_irq_desc(desc);
+		stat &= ~BIT(hwirq);
+	}
+	writel(~0, ioaddr_intc(REG_INTC_SOFTINTCLEAR));
+	
+	// while(1) {};
+	
+	// writel(~0, (void*)(CFG_TIMER_VABASE + REG_TIMER1_INTCLR));
+	// writel(~0, (void*)(CFG_TIMER_VABASE + REG_TIMER_INTCLR));
+	
+}
+
+static int hi_irq_map(struct irq_domain *d,
+		       unsigned int virq, irq_hw_number_t hw)
+{
+	early_printk("IDEV NODE MAPPING %d<=>%d\n", virq, hw);
+	irq_set_status_flags(virq, IRQ_LEVEL);
+	irq_set_chip_and_handler(virq, &hic_chip, handle_level_irq);
+	// irq_set_chip_data(virq, d->host_data);
+	irq_set_probe(virq);
+
+	return 0;
+}
+
+static const struct irq_domain_ops hi_irq_domain_ops = {
+	.map = hi_irq_map,
+};
+
+static void __init hisilicon_init_irq(void)
+{
+	unsigned int i;
+
+	edb_trace(1);
+	
+	idevnode = kzalloc(sizeof(struct device_node), GFP_KERNEL);
+	
+	idevnode->name = "HIINTC";
+	idevnode->full_name = "HIINTC";
+	of_node_init(idevnode);
+	
+	void __iomem *mem;
+	if (!request_mem_region(REG_BASE_INTC, 36, "HIINTC"))
+		hi_intc_base = IOMEM_ERR_PTR(-EBUSY);
+
+	hi_intc_base = ioremap(REG_BASE_INTC, 36);
+
+	if (!hi_intc_base) {
+		release_mem_region(REG_BASE_INTC, 36);
+		hi_intc_base = IOMEM_ERR_PTR(-ENOMEM);
+	}
+	
+	if(IS_ERR(hi_intc_base)) {
+		early_printk("IDEV ADDR ERROR: %d\n", PTR_ERR(hi_intc_base));
+	}
+	
+	early_printk("IDEV NODE INITED\n");
+
+	idomain = irq_domain_add_linear(idevnode, 32,
+			&hi_irq_domain_ops, NULL);
+	
+	early_printk("I DOMAIN INITED\n");
+
+	writel(~0, ioaddr_intc(REG_INTC_INTENCLEAR));
+	writel(0, ioaddr_intc(REG_INTC_INTSELECT));
+	writel(~0, ioaddr_intc(REG_INTC_SOFTINTCLEAR));
+	writel(1, ioaddr_intc(REG_INTC_PROTECTION));
+	
+
+	// int ret;
+
+	// ret = irq_alloc_domain_generic_chips(idomain, 32, 1, "HIINTC",
+	// 		handle_level_irq, IRQ_NOREQUEST | IRQ_NOPROBE,
+	// 		IRQ_LEVEL, 0);
+	
+	early_printk("I DOMAIN GC ALLOCATED\n");
+	
+	// if (ret) {
+	// 	pr_warn("Failed to allocate irq chips\n");
+	// 	irq_domain_remove(idomain);
+	// } else {
+	// 	struct irq_chip_generic *gc;
+	// 	struct irq_chip_type *ct;
+ // 
+	// 	gc = irq_get_domain_generic_chip(idomain, 0);
+	// 	gc->reg_base = (void*)REG_BASE_INTC;
+	// 	ct = gc->chip_types;
+ // 
+	// 	ct->type = IRQ_TYPE_LEVEL_MASK;
+ // 
+	// 	ct->chip.irq_ack = hil_ack_irq;
+	// 	ct->chip.irq_mask = hil_mask_irq;
+	// 	ct->chip.irq_unmask = hil_unmask_irq;
+		
+		
+		
+		for (i = INTNR_IRQ_START; i <= INTNR_IRQ_END; i++)
+		{
+			// irq_create_mapping(idomain, i);
+			unsigned int virq = irq_alloc_desc_from(1, of_node_to_nid(idevnode));
+			irq_domain_associate(idomain, i, i);
+			
+			
+		// 	// set_irq_chip(i, &hic_chip );
+		// 	// set_irq_handler(i, do_level_IRQ);
+			// irq_set_chip_and_handler(i, &hic_chip, handle_level_irq);
+		// 	// set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+			// irq_clear_status_flags(i, IRQ_NOREQUEST | IRQ_NOPROBE);
+		}
+		
+		early_printk("I DOMAIN GC CONFIGURED\n");
+
+		// ct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;
+
+		// ct->regs.enable = INTC_MIR_CLEAR0;
+		// ct->regs.disable = INTC_MIR_SET0;
+	// }
+
+	// for (i = INTNR_IRQ_START; i <= INTNR_IRQ_END; i++)
+	// {
+	// 	// set_irq_chip(i, &hic_chip );
+	// 	// set_irq_handler(i, do_level_IRQ);
+	// 	irq_set_chip_and_handler(i, &hic_chip, do_level_IRQ);
+	// 	// set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	// 	irq_clear_status_flags(i, IRQ_NOREQUEST | IRQ_NOPROBE);
+	// }
+	set_handle_irq(hisi_intc_handle_irq);
+}
+
+void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+void arch_reset(char mode)
+{
+	writel(~0x0,hisilicon_sctl_reg(REG_SC_SYSSTAT));
+}
+#define HIL_AMBADEV_NAME(name) hil_ambadevice_##name
+
+#define HIL_AMBA_DEVICE(name,busid,base,platdata)		\
+static struct amba_device HIL_AMBADEV_NAME(name) = {		\
+	.dev		= {					\
+		.coherent_dma_mask = ~0,			\
+		.platform_data = platdata,			\
+	},							\
+	.res		= {					\
+		.start	= REG_BASE_##base,			\
+		.end	= REG_BASE_##base + REG_##base##_IOSIZE -1,	\
+		.flags	= IORESOURCE_IO,			\
+	},							\
+	.irq		= { INTNR_##base, NO_IRQ }		\
+}
+
+#define UART0_IRQ	{ INTNR_UART0, NO_IRQ }
+#define UART1_IRQ	{ INTNR_UART1, NO_IRQ }
+#define UART2_IRQ	{ INTNR_UART2, NO_IRQ }
+
+HIL_AMBA_DEVICE(uart0, "uart:0",  UART0,    NULL);
+HIL_AMBA_DEVICE(uart1, "uart:1",  UART1,    NULL);
+HIL_AMBA_DEVICE(uart2, "uart:2",  UART2,    NULL);
+
+static struct amba_device *amba_devs[] __initdata = {
+#if (CONFIG_HISILICON_KCONSOLE==1)
+	& HIL_AMBADEV_NAME(uart1),
+	& HIL_AMBADEV_NAME(uart0),
+	& HIL_AMBADEV_NAME(uart2),
+#elif (CONFIG_HISILICON_KCONSOLE==2)
+	& HIL_AMBADEV_NAME(uart2),
+	& HIL_AMBADEV_NAME(uart0),
+	& HIL_AMBADEV_NAME(uart1),
+#else
+	& HIL_AMBADEV_NAME(uart0),
+	& HIL_AMBADEV_NAME(uart1),
+//	& HIL_AMBADEV_NAME(uart2),
+#endif
+
+};
+
+extern int hisilicon_register_platform_devices(void);
+
+static void __init hisilicon_init_machine(void)
+{
+	int i;
+
+	edb_trace(1);
+    edb_putstr("A\n");
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+	        edb_trace(1);
+            edb_putstr("B\n");
+		amba_device_register(amba_devs[i], &iomem_resource);
+	}
+	hisilicon_register_platform_devices();
+	edb_trace(1);
+    edb_putstr("C\n");
+    struct device_node* dt_node;
+    dt_node = of_find_node_by_path("/memory@c0000000");
+
+	struct property *pp;
+	u32 reg[6];
+	for_each_property_of_node(dt_node, pp) {
+	printk("property name: %s, length: %d\n", pp->name, pp->length);
+	if (pp->length == 24) {
+	if (!of_property_read_u32_array(dt_node, pp->name, reg, 6))
+		printk("reg: %x %x %x %x\n", reg[0], reg[1], reg[2], reg[3]);
+	}
+	}
+}
+
+#define REG_IOMAP(name) { \
+		IO_ADDRESS(REG_BASE_##name),\
+			  __phys_to_pfn(REG_BASE_##name), \
+			   REG_##name##_IOSIZE, MT_DEVICE }
+
+static struct map_desc hisilicon_io_desc[] __initdata = {
+	REG_IOMAP( NANDC ),
+	REG_IOMAP( SMI ),
+	REG_IOMAP( SDIO ),
+	REG_IOMAP( SIO0 ),
+	REG_IOMAP( SIO1 ),
+	REG_IOMAP( INTC ),
+	REG_IOMAP( ETH ),	
+	REG_IOMAP( USBOHCI ),
+    REG_IOMAP( USBEHCI ),
+    REG_IOMAP( CIPHER ),
+    REG_IOMAP( DMAC ),
+    REG_IOMAP( VEDU0 ),
+    REG_IOMAP( VIU ),
+    REG_IOMAP( TIMER12 ),
+    REG_IOMAP( TIMER34 ),
+    REG_IOMAP( WDG ),
+    REG_IOMAP( SCTL ),
+	REG_IOMAP( IR ),
+	REG_IOMAP( UART0 ),
+	REG_IOMAP( UART1 ),
+	REG_IOMAP( UART2 ),
+	REG_IOMAP( UART3 ),
+	REG_IOMAP( I2C ),
+	REG_IOMAP( SPI ),
+	REG_IOMAP( IO ),
+	REG_IOMAP( DDRC ),
+	REG_IOMAP( VOU ),
+	REG_IOMAP( TDE ),
+	REG_IOMAP( GPIO0 ),
+	REG_IOMAP( GPIO1 ),
+	REG_IOMAP( GPIO2 ),
+	REG_IOMAP( GPIO3 ),
+	REG_IOMAP( GPIO4 ),
+	REG_IOMAP( GPIO5 ),
+	REG_IOMAP( GPIO6 ),
+	REG_IOMAP( GPIO7 ),
+};
+
+static int hisilicon_iomapped = 0;
+
+static void __init hisilicon_map_io(void)
+{
+	int i;
+
+	iotable_init(hisilicon_io_desc, ARRAY_SIZE(hisilicon_io_desc));
+
+	hisilicon_iomapped = 1;
+
+	edb_init();
+
+
+	for(i=0; i<ARRAY_SIZE(hisilicon_io_desc); i++)
+	{
+#if (CONFIG_HISILICON_EDB_LEVEL == 0)
+		edb_putstr(" V: "),	edb_puthex(hisilicon_io_desc[i].virtual);
+		edb_putstr(" P: "),	edb_puthex(hisilicon_io_desc[i].pfn);
+		edb_putstr(" S: "),	edb_puthex(hisilicon_io_desc[i].length);
+		edb_putstr(" T: "),	edb_putul(hisilicon_io_desc[i].type);
+		edb_putstr("\n");
+#endif
+		if(hisilicon_io_desc[i].virtual == IO_ADDRESS(~0)) {
+			edb_putstr("<Bad IoTable> P: ");
+			edb_puthex(hisilicon_io_desc[i].pfn);
+			edb_putstr(" V: "); 
+			edb_puthex(hisilicon_io_desc[i].virtual);
+			edb_putstr("\n");
+		}
+	}
+
+	edb_trace(1);
+}
+
+/* HI-hi3515v100 TIMER0 USING BUS CLK */
+unsigned long hisilicon_timer_reload = BUSCLK_TO_TIMER_RELOAD(CONFIG_DEFAULT_BUSCLK);
+unsigned long timer0_clk_hz = BUSCLK_TO_TIMER0_CLK_HZ(CONFIG_DEFAULT_BUSCLK);
+unsigned long timer1_clk_hz = BUSCLK_TO_TIMER1_CLK_HZ(CONFIG_DEFAULT_BUSCLK);
+unsigned long timer0_clk_khz = BUSCLK_TO_TIMER0_CLK_KHZ(CONFIG_DEFAULT_BUSCLK);
+unsigned long timer1_clk_khz = BUSCLK_TO_TIMER1_CLK_KHZ(CONFIG_DEFAULT_BUSCLK);
+
+/* cycles to nsec conversions 
+ * convert from cycles(64bits) => nanoseconds (64bits)
+ *  basic equation:
+ *		ns = cycles / (freq / ns_per_sec)
+ *		ns = cycles * (ns_per_sec / freq)
+ *		ns = cycles * (10^9 / (cpu_khz * 10^3))
+ *		ns = cycles * (10^6 / cpu_khz)
+ *
+ *	Then we use scaling math (suggested by george at mvista.com) to get:
+ *		ns = cycles * (10^6 * SC / cpu_khz)
+ *		ns = cycles * cyc2ns_scale / SC
+ *      Now we define SC = 2^10
+ */
+static unsigned long long hisi_cycles_2_ns(unsigned long long cyc)
+{
+	unsigned long cyc2ns_scale = (1000000 << 10)/timer1_clk_khz;
+	return (cyc * cyc2ns_scale) >> 10;
+}
+
+static int timer_set_state_periodic(struct clock_event_device *clk) {
+	writel(0, (void*)(CFG_TIMER_VABASE + REG_TIMER_CONTROL));
+	writel(hisilicon_timer_reload, (void*)(CFG_TIMER_VABASE + REG_TIMER_RELOAD));
+	writel(CFG_TIMER_CONTROL, (void*)(CFG_TIMER_VABASE + REG_TIMER_CONTROL));
+	// edb_trace(1);
+	return 0;
+}
+
+static int timer_set_state_oneshot(struct clock_event_device *clk) {
+	writel(0, (void*)(CFG_TIMER_VABASE + REG_TIMER_CONTROL));
+	return 0;
+}
+
+static int timer_set_state_shutdown(struct clock_event_device *clk) {
+	unsigned long ctrl;
+	ctrl = 0;
+	writel(ctrl, (void*)(CFG_TIMER_VABASE + REG_TIMER_CONTROL));
+	return 0;
+}
+
+static int timer_set_next_event(unsigned long evt,
+				struct clock_event_device *unused)
+{
+	// edb_trace(1);
+	writel(evt, (void*)(CFG_TIMER_VABASE + REG_TIMER_RELOAD));
+        writel(CFG_TIMER_ONE_CONTROL, (void*)(CFG_TIMER_VABASE + REG_TIMER_CONTROL));
+	
+	return 0;
+}
+
+static struct clock_event_device hisi_clockevent ={
+	.name		= "hisi_timer0",
+        .shift	        = 32,
+	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_state_periodic = timer_set_state_periodic,
+	.set_state_oneshot = timer_set_state_oneshot,
+	.set_state_shutdown = timer_set_state_shutdown,
+	.set_next_event	= timer_set_next_event,
+};
+
+/*
+ * IRQ handler for systimer and hrtimer
+ */
+// static irqreturn_t hisilicon_systimer_interrupt(int irq, void *dev_id)
+// {
+// 	edb_putstr("STI\n");
+// 	if((readl((void*)(CFG_TIMER_VABASE+REG_TIMER_RIS)))&0x1)
+// 	{
+// 		writel(~0, (void*)(CFG_TIMER_VABASE + REG_TIMER_INTCLR));
+// 		hisi_clockevent.event_handler(&hisi_clockevent);
+// 	}
+// 	
+// 	return IRQ_HANDLED;
+// }
+
+static unsigned long free_timer_overflows=0;
+
+static irqreturn_t hisilicon_freetimer_interrupt(int irq, void *dev_id)
+{
+	// edb_putstr("TI\n");
+	if((readl((void*)(CFG_TIMER_VABASE+REG_TIMER_RIS)))&0x1)
+// 	{
+		writel(~0, (void*)(CFG_TIMER_VABASE + REG_TIMER_INTCLR));
+		hisi_clockevent.event_handler(&hisi_clockevent);
+// 	}
+	if((readl((void*)(CFG_TIMER_VABASE+REG_TIMER1_RIS)))&0x1)
+	{
+		free_timer_overflows++;
+		writel(~0, (void*)(CFG_TIMER_VABASE + REG_TIMER1_INTCLR));
+        }
+	return IRQ_HANDLED;
+}
+
+// static struct irqaction hisilicon_timer_irq = 
+// {
+// 	.name		= "System Timer and Hrtimer",
+// 	.flags		= IRQF_SHARED | IRQF_TIMER,
+// 	.handler	= hisilicon_systimer_interrupt,
+// };
+
+static struct irqaction hisilicon_freetimer_irq = 
+{
+	.name		= "System Timer and Hrtimer & Free Timer",
+	.flags		= IRQF_SHARED | IRQF_TIMER,
+	.handler	= hisilicon_freetimer_interrupt,
+};
+
+static u64 hisi_get_cycles(struct clocksource *cs)
+{
+	// edb_trace(0);
+	
+	return ~readl((void*)(CFG_TIMER_VABASE + REG_TIMER1_VALUE));
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ * hisi timer 1 ... free running 32-bit clock source and scheduler clock
+ * ---------------------------------------------------------------------------
+ */
+static struct clocksource hisi_clocksource = {
+	.name 		= "hisi_timer1",
+ 	.rating		= 200,
+ 	.read		= hisi_get_cycles,
+	.mask		= CLOCKSOURCE_MASK(32),
+ 	.shift 		= 20,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static unsigned long long sched_clock_read(void)
+{
+	
+	
+	unsigned long long ticks64;
+	unsigned long ticks2,ticks1;
+
+	ticks2 = 0UL - (unsigned long)readl((void*)(CFG_TIMER_VABASE + REG_TIMER1_VALUE));
+	do{
+		ticks1 = ticks2;
+		ticks64 = free_timer_overflows;
+		ticks2 = 0UL - (unsigned long)readl((void*)(CFG_TIMER_VABASE + REG_TIMER1_VALUE));
+	}while(ticks1 > ticks2);
+
+    /* 
+    ** If INT is not cleaned, means the function is called with irq_save.
+    ** The ticks has overflow but 'free_timer_overflows' is not be update.
+    */
+    if(readl((void*)(CFG_TIMER_VABASE + REG_TIMER1_MIS)))
+    {
+        ticks64 += 1;
+        ticks2 = 0UL - (unsigned long)readl((void*)(CFG_TIMER_VABASE + REG_TIMER1_VALUE));
+    }
+	// early_printk("T %llu\n", hisi_cycles_2_ns( (ticks64 << 32) | ticks2));
+
+	return hisi_cycles_2_ns( (ticks64 << 32) | ticks2);
+}
+
+void hisilicon_timer_init(void)
+{
+	early_printk("TIMERINIT\n");
+	
+	edb_trace(1);
+	ulong busclk;
+	
+	/*Init timer1 is periodic running*/
+	writel(0, (void*)(CFG_TIMER_VABASE + REG_TIMER1_CONTROL));
+	writel(0xffffffff, (void*)(CFG_TIMER_VABASE + REG_TIMER1_RELOAD));
+	writel(CFG_TIMER_CONTROL,(void*)(CFG_TIMER_VABASE + REG_TIMER1_CONTROL));
+	
+	// int ret = request_any_context_irq(INTNR_TIMER_0_1, hisilicon_systimer_interrupt,
+	// 		    IRQF_SHARED | IRQF_TIMER, "System Timer and Hrtimer", hisilicon_systimer_interrupt);
+	// if (ret < 0) {
+	// 	pr_err("IRQ %d setup failed (%d)\n", INTNR_TIMER_0_1, ret);
+	// }
+	int ret =  request_irq(INTNR_TIMER_0_1, hisilicon_freetimer_interrupt, IRQF_NOBALANCING | IRQF_TIMER, "Free Timer", NULL);
+	if (ret < 0) {
+		pr_err("IRQ %d setup failed (%d)\n", INTNR_TIMER_0_1, ret);
+	}
+	
+	// busclk = get_ahbclk_hw();
+	busclk = CONFIG_DEFAULT_BUSCLK;
+	hisilicon_timer_reload = BUSCLK_TO_TIMER_RELOAD(busclk);
+	timer0_clk_hz = BUSCLK_TO_TIMER0_CLK_HZ(busclk);
+	timer0_clk_khz = BUSCLK_TO_TIMER0_CLK_KHZ(busclk);
+	timer1_clk_hz = BUSCLK_TO_TIMER1_CLK_HZ(busclk);
+	timer1_clk_khz = BUSCLK_TO_TIMER1_CLK_KHZ(busclk);
+	
+	hisi_clocksource.mult = clocksource_khz2mult(timer1_clk_khz, hisi_clocksource.shift);
+	clocksource_register_hz(&hisi_clocksource, timer1_clk_hz);
+ 
+	hisi_clockevent.mult =
+		div_sc(timer0_clk_hz, NSEC_PER_SEC, hisi_clockevent.shift);	
+    	hisi_clockevent.max_delta_ns =
+		clockevent_delta2ns(0xffffffff, &hisi_clockevent);	
+	hisi_clockevent.min_delta_ns =
+		clockevent_delta2ns(0xf, &hisi_clockevent);
+	hisi_clockevent.cpumask = cpumask_of(0);
+
+	edb_putstr("AB\n");
+	clockevents_register_device(&hisi_clockevent);	
+	edb_putstr("AC\n");
+	sched_clock_register(sched_clock_read, 64, 1000000000);
+	edb_putstr("AD\n");
+}
+
+
+// static struct sys_timer hisilicon_timer = 
+// {
+// 	.init	= hisilicon_timer_init,
+// };
+
+static const char *const hi3515v100_dt_board_compat[] __initconst = {
+	"hisilicon,hi3515v100",
+	NULL
+};
+
+DT_MACHINE_START(hi3515v100, "HI3515v100")
+	// .phys_io	= IO_SPACE_PHYS_START,
+	// .io_pg_offst	= (IO_ADDRESS(IO_SPACE_PHYS_START) >> 18) & 0xfffc, 
+	// .boot_params	= PHYS_OFFSET + 0x100,
+	.nr_irqs	= NR_IRQS,
+	// .map_io		= hisilicon_map_io,
+	// .init_irq	= hisilicon_init_irq,
+	// .timer		= &hisilicon_timer,
+	// .init_time	= hisilicon_timer_init,
+	// .init_machine	= hisilicon_init_machine,
+	.dt_compat	= hi3515v100_dt_board_compat,
+MACHINE_END
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/cpu-freq.c linux-master-mod/arch/arm/mach-hi3515v100/cpu-freq.c
--- linux-master/arch/arm/mach-hi3515v100/cpu-freq.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/cpu-freq.c	2024-10-15 01:11:44.950541295 +0300
@@ -0,0 +1,179 @@
+/* linux/arch/arm/mach-hi3515_v100/cpu-freq.c
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+
+#include <linux/cpufreq.h>
+
+#include <linux/clk.h>
+#include <asm/hardware.h>
+
+#include <asm/arch/system.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/early-debug.h>
+
+static int hisilicon_verify_freq(struct cpufreq_policy *policy)
+{
+	hisilicon_trace(4,"policy->min %u, policy->max %u", policy->min, policy->max);
+
+	if (policy->cpu)
+		return -EINVAL;
+
+	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq, policy->cpuinfo.max_freq);
+
+	return 0;
+}
+
+static unsigned int hisilicon_get_freq(unsigned int cpu)
+{
+	struct clk *clk;
+	unsigned int freq;
+
+	if (cpu)
+		return 0;
+
+	clk = clk_get(NULL, "ARMCORECLK");
+	if(clk == NULL)
+		return 0;
+
+	freq = clk_get_rate(clk)/KHZ;
+
+	hisilicon_trace(4,"cur_freq = %u", freq);
+
+	return freq;
+}
+
+#define CPU_FREQ_ALIGN_H(freq,align) ((((freq)+(align)-1)/(align))*(align))
+#define CPU_FREQ_ALIGN_L(freq,align) (((freq)/(align))*(align))
+
+static unsigned int calc_cpu_target_freq(struct cpufreq_policy *policy,
+			 unsigned int target_freq,
+			 unsigned int relation)
+{
+	if(strcmp(policy->governor->name, "userspace") ==0) {
+		if(target_freq > policy->cpuinfo.max_freq)
+			printk(KERN_WARNING "Warning: %uMHZ > %uMHZ, cpu-freq may overlade!\n",
+					target_freq/KHZ ,policy->cpuinfo.max_freq/KHZ);
+		if(target_freq < policy->cpuinfo.min_freq)
+			printk(KERN_WARNING "Warning: %uMHZ < %uMHZ, cpu-freq underflow!\n",
+					target_freq/KHZ ,policy->cpuinfo.min_freq/KHZ);
+		return target_freq;
+	}
+
+	switch(relation)
+	{
+	case CPUFREQ_RELATION_L:
+		target_freq = CPU_FREQ_ALIGN_H(target_freq, HISILICON_OSC_CLOCK/(9*KHZ));
+		break;
+
+	case CPUFREQ_RELATION_H:
+		target_freq = CPU_FREQ_ALIGN_L(target_freq, HISILICON_OSC_CLOCK/(9*KHZ));
+		break;
+	}
+
+	if(target_freq > policy->cpuinfo.max_freq)
+		target_freq = policy->cpuinfo.max_freq;
+	if(target_freq < policy->cpuinfo.min_freq)
+		target_freq = policy->cpuinfo.min_freq;
+
+	return target_freq;
+}
+
+static int hisilicon_cpu_target(struct cpufreq_policy *policy,
+			 unsigned int target_freq,
+			 unsigned int relation)
+{
+	struct clk *clk = clk_get(NULL, "ARMCORECLK");
+	struct cpufreq_freqs freqs;
+
+	if(clk==NULL)
+		return -EIO;
+
+	hisilicon_trace(4,"target_freq %u", target_freq);
+
+	target_freq = calc_cpu_target_freq(policy, target_freq, relation);
+
+	freqs.old = hisilicon_get_freq(0);
+	freqs.new = target_freq;
+	freqs.cpu = 0;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	clk_set_rate(clk, target_freq*KHZ);
+	freqs.new = hisilicon_get_freq(0);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return 0;
+}
+
+
+static int __init hisilicon_cpu_init(struct cpufreq_policy *policy)
+{
+	struct clk *clk;
+
+	hisilicon_trace(4,"policy->cpu %u", policy->cpu);
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+	clk = clk_get(NULL, "ARMCORECLK");
+	if(clk == NULL)
+	{
+		printk(KERN_WARNING "ARMCORECLK not found!");
+		return -1;
+	}
+
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.min_freq = AHBCLK_TO_ARMCORE(20*MHZ)/KHZ;
+	policy->cpuinfo.max_freq = AHBCLK_TO_ARMCORE(HISILICON_OSC_CLOCK*4)/KHZ;
+	policy->cpuinfo.transition_latency = 500*1000;
+
+	policy->cur = clk_get_rate(clk)/KHZ;
+	policy->min = policy->cpuinfo.min_freq;
+	policy->max = policy->cpuinfo.max_freq;
+
+	hisilicon_trace(4,"policy->cur %u", policy->cur);
+
+	return 0;
+}
+
+static struct cpufreq_driver hisilicon_cpu_driver = {
+	.flags		= CPUFREQ_STICKY,
+	.verify		= hisilicon_verify_freq,
+	.target		= hisilicon_cpu_target,
+	.get		= hisilicon_get_freq,
+	.init		= hisilicon_cpu_init,
+	.name		= "Hisilicon SOC",
+};
+
+static int __init hisilicon_cpufreq_init(void)
+{
+	printk(KERN_INFO "Hisilicon CPU-Freq\n");
+
+	return cpufreq_register_driver(&hisilicon_cpu_driver);
+}
+
+module_init(hisilicon_cpufreq_init);
+
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/entry-macro.S linux-master-mod/arch/arm/mach-hi3515v100/entry-macro.S
--- linux-master/arch/arm/mach-hi3515v100/entry-macro.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/entry-macro.S	2010-03-16 05:41:14.000000000 +0300
@@ -0,0 +1,55 @@
+/* linux/include/asm/arch-hi3515v100/entry-macro.S
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+#include <linux/autoconf.h>
+#include <asm/arch/hardware.h>
+#define NR_IRQS 32
+/* VO > VI > DMAC > VEDU > MDU > DSU > ETH > PCI > MMC */
+#define HI_INTTERUPT_PRIO_HIGH ( (1<<INTNR_VOU)	| ( 1 << INTNR_VIU) )	
+
+#define HI_INTTERUPT_PRIO_MEDIUM ( (1<<INTNR_DMAC)| (1<<INTNR_VEDU) | (1<<INTNR_TDE) )	
+
+		.macro	disable_fiq
+		.endm
+	        
+		.macro  get_irqnr_preamble, base, tmp
+        	.endm
+
+	        .macro  arch_ret_to_user, tmp1, tmp2
+        	.endm
+
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =IO_ADDRESS(REG_BASE_INTC)
+		ldr	\tmp, [\base, #REG_INTC_IRQSTATUS]	@ get masked status
+
+		ldr	\irqstat,	=HI_INTTERUPT_PRIO_HIGH	
+		ands	\irqstat, \tmp, \irqstat
+
+		ldreq	\irqstat,	=HI_INTTERUPT_PRIO_MEDIUM 
+		andeqs	\irqstat, \tmp, \irqstat
+
+		/* normal priority */
+		moveqs	\irqstat, \tmp
+
+		clzne	\irqnr, \irqstat
+		rsbne	\irqnr, #(NR_IRQS-1)
+
+		.endm
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/debug/hi3515-debug-macro.S linux-master-mod/arch/arm/mach-hi3515v100/include/debug/hi3515-debug-macro.S
--- linux-master/arch/arm/mach-hi3515v100/include/debug/hi3515-debug-macro.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/debug/hi3515-debug-macro.S	2024-10-16 17:10:16.251912273 +0300
@@ -0,0 +1,48 @@
+/* linux/include/asm-arm/arch-hi3515v100/debug-macro.S
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <linux/amba/serial.h>
+
+#include <mach/hardware.h>
+
+		.macro	addruart,rp, rv, tmp
+		# mrc	p15, 0, \rx, c1, c0
+		# tst	\rx, #1			@ MMU enabled?
+		# ldreq	\rx, =BOOTUP_UART_BASE
+		# ldrne	\rx, =IO_ADDRESS(BOOTUP_UART_BASE)
+		ldr \rp, =BOOTUP_UART_BASE
+		ldr \rv, =IO_ADDRESS(BOOTUP_UART_BASE)
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx, #UART01x_DR]
+		.endm
+
+		.macro	waituarttxrdy,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]	@ UARTFLG
+		tst	\rd, #1 << 5		@ UARTFLGUTXFF - 1 when full
+		bne	1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]	@ UARTFLG
+		tst	\rd, #1 << 3		@ UARTFLGUBUSY - 1 when busy
+		bne	1001b
+		.endm
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/clock.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/clock.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/clock.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/clock.h	2024-10-15 22:23:11.647615191 +0300
@@ -0,0 +1,90 @@
+/* linux/include/asm-arm/arch-hi3515v100/clock.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef __ASM_ARCH_CLOCK_H
+#define __ASM_ARCH_CLOCK_H
+
+struct module;
+
+#define MAX_CLK_NAME	16
+struct clk {
+	struct list_head	list;
+	struct list_head	child_list;
+
+	unsigned long		rate;
+
+	char			name[MAX_CLK_NAME];
+	char 			parent_name[MAX_CLK_NAME];
+
+	struct module		*owner;
+	void			*data;
+
+	int (*notifier)(struct clk *clk, unsigned int cmd, unsigned long wparam, unsigned long lparam);
+};
+
+
+#define HISILICON_CLK_REGISTER		0x001
+#define HISILICON_CLK_UNREGISTER	0x002
+#define HISILICON_CLK_PARENT_DEL	0x003
+#define HISILICON_CLK_SETRATE		0x004
+#define HISILICON_CLK_PARENT_SETRATE	0x005
+
+int hisilicon_clk_default_notifier(struct clk *clk, unsigned int cmd, unsigned long wparam, unsigned long lparam);
+
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
+int clk_info(char *buf, int len);
+int clk_notify_childs(struct clk *clk, unsigned int cmd, unsigned long wparam, unsigned long lparam);
+
+unsigned long get_ahbclk_hw(void);
+
+static inline long __pow(long a, unsigned int x)
+{
+	if(x==0)
+		return 1;
+	for(;x!=1;x--)
+		a = a*a;
+	return a;
+}
+
+#define RD_PLLC() readl(hisilicon_sctl_reg(0x18))
+#define WR_PLLC(x) do{\
+			unsigned long irqs; int i=PLLC_TO_ARMCORE(x)/1000/4; \
+			local_irq_save(irqs);\
+			writel(x, hisilicon_sctl_reg(0x18));\
+			while(i--) __asm__ __volatile__("nop");\
+			local_irq_restore(irqs);\
+		}while(0)
+
+#define PLLC_TO_ARMCORE(x) ({unsigned long __pllc=(x), __freq; \
+		__freq=(HISILICON_OSC_CLOCK*((__pllc>>4)&0x0FF))/( max_t(unsigned long,__pllc&0x0F,1) * __pow(2, ((__pllc>>12)&0x03)) ); \
+		__freq; })
+#define PLLC_TO_AHBCLK(x) (PLLC_TO_ARMCORE(x)/HISILICON_ARMCORECLK_SCALE)
+#define AHBCLK_TO_ARMCORE(x) ((x)*HISILICON_ARMCORECLK_SCALE)
+#define ARMCORE_TO_AHBCLK(x) ((x)/HISILICON_ARMCORECLK_SCALE)
+
+#define MIN_AHBCLK	(10*MHZ)
+#define MAX_AHBCLK	(150*MHZ)
+
+#define CHECK_AHBCLK(x) ((x)>MIN_AHBCLK && (x)<MAX_AHBCLK)
+
+#endif /* __ASM_ARCH_CLOCK_H */
+
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/dma.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/dma.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/dma.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/dma.h	2024-10-15 19:35:47.570437708 +0300
@@ -0,0 +1,27 @@
+/* linux/include/asm-arm/arch-hi3515v100/dma.h
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef __ASM_ARCH_DMA_H__
+#define __ASM_ARCH_DMA_H__
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* __ASM_ARCH_DMA_H__ */
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/early-debug.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/early-debug.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/early-debug.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/early-debug.h	2024-10-15 19:35:57.273610404 +0300
@@ -0,0 +1,142 @@
+/* linux/include/asm-arm/arch-hi3515v100/early-debug.h
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <mach/system.h>
+
+#ifndef __ASM_ARCH_EARLY_DEBUG_H
+#define __ASM_ARCH_EARLY_DEBUG_H
+
+#if (CONFIG_HISILICON_EDB_LEVEL==255)
+
+#define edb_init()
+#define edb_cleanup()
+#define edb_putc(x)
+#define edb_putul(x)
+#define edb_putstr(x)
+#define edb_puthex(x)
+#define edb_trace(x)
+#define edb_put_strul(x,y)
+
+#define hisilicon_trace(level,s,param...)
+
+#else /* (CONFIG_HISILICON_EDB_LEVEL<255) */
+
+
+#define edb_init()	do{ \
+				edb_putstr("Kernel Early-Debug on Level "); \
+				edb_putul(CONFIG_HISILICON_EDB_LEVEL);\
+				edb_putstr(" \n"); \
+			}while(0)
+				
+#define edb_cleanup()
+
+
+#define AMBA_UART_DR	(*(volatile unsigned char *)IO_ADDRESS(BOOTUP_UART_BASE + 0x000))
+#define AMBA_UART_LCRH	(*(volatile unsigned char *)IO_ADDRESS(BOOTUP_UART_BASE + 0x02C))
+#define AMBA_UART_CR	(*(volatile unsigned char *)IO_ADDRESS(BOOTUP_UART_BASE + 0x030))
+#define AMBA_UART_FR	(*(volatile unsigned char *)IO_ADDRESS(BOOTUP_UART_BASE + 0x018))
+
+static inline void edb_putc(char c)
+{
+	while (AMBA_UART_FR & (1 << 5));
+	AMBA_UART_DR = c;
+	while (AMBA_UART_FR & (1 << 3));
+}
+
+static void __edb_putul(unsigned long num)
+{
+	if(num == 0)
+		return;
+//	__edb_putul(num/10);
+//	edb_putc('0'+(num%10));
+}
+
+static inline void edb_putul(unsigned long num)
+{
+	if(num == 0)
+	{
+		edb_putc('0');
+		return;
+	}
+	__edb_putul(num);
+}
+
+
+static inline void edb_putstr(const char *s)
+{
+	while (*s) {
+		while (AMBA_UART_FR & (1 << 5));
+
+		AMBA_UART_DR = *s;
+
+		if (*s == '\n') {
+			while (AMBA_UART_FR & (1 << 5));
+
+			AMBA_UART_DR = '\r';
+		}
+		s++;
+	}
+	while (AMBA_UART_FR & (1 << 3));
+}
+
+static inline void edb_puthex(unsigned long h)
+{
+	int i;
+	char c;
+
+	edb_putstr("0x");
+	for(i=0; i<8; i++)
+	{
+		c = (h>>28)&0x0F;
+
+		if(c>=10)
+			c = (c-10)+'A';
+		else c = c+'0';
+
+		edb_putc(c);
+
+		h = h<<4;
+	}
+}
+
+
+#define EDB_TRACE_LEVEL CONFIG_HISILICON_EDB_LEVEL
+
+#define edb_trace(level) do{\
+				if(level >= EDB_TRACE_LEVEL){\
+					edb_putstr(__FUNCTION__);\
+					edb_putstr("\t");\
+					edb_putul(__LINE__);\
+					edb_putstr("\t[");\
+					edb_putstr(__FILE__);\
+					edb_putstr("]\n");\
+				}\
+			}while(0)
+#define edb_put_strul(s,ul) do{ edb_putstr(s); edb_putul(ul); }while(0)
+
+
+#define hisilicon_trace(level,s,param...) do{ \
+		if(level >= EDB_TRACE_LEVEL)\
+			printk(KERN_INFO "[%s, %d]\t" s "\n",__FUNCTION__,__LINE__, param);	}while(0)
+
+#endif /* (CONFIG_HISILICON_EDB_LEVEL==255) */
+
+#endif /* __ASM_ARCH_EARLY_DEBUG_H */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/gpio.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/gpio.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/gpio.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/gpio.h	2024-10-15 19:36:06.663454998 +0300
@@ -0,0 +1,64 @@
+/* linux/include/asm-arm/arch-hi3515v100/gpio.h
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <mach/platform.h>
+#include <mach/hardware.h>
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+/* @g: gpio group, range 0-7 
+ * return gpio group's base address in virtual.
+ * */
+#define HISILICON_GPIO_GBASE(g) IO_ADDRESS(((g)>3)?(HISILICON_GPIO4_7_BASE+0x1000*((g)-4)):(HISILICON_GPIO0_3_BASE+0x1000*(g)))
+
+/* return gpio group's direction mask, ouput when certain bit is '1' */
+#define HISILICON_GPIO_GET_DIR(g) (*(volatile unsigned long*)(HISILICON_GPIO_GBASE(g)+0x400))
+
+/* @dir: group's direction, set to output if the bit is '1' */
+#define HISILICON_GPIO_SET_DIR(dir,g) do{ *(volatile unsigned long*)(HISILICON_GPIO_GBASE(g)+0x400) = dir; }while(0)
+
+/* @b: bits, range 0-7 
+ * return '1' if specific bit is output 
+ * */
+#define HISILICON_GPIO_GET_BITDIR(g,b) ((HISILICON_GPIO_GET_DIR(g)>>(b))&0x01)
+
+/* set bit direction
+ * set the direction of gpio group 'g', bit 'b'
+ * */
+#define HISILICON_GPIO_SET_BITDIR(dir,g,b) HISILICON_GPIO_SET_DIR(((HISILICON_GPIO_GET_DIR(g)&(~(1<<(b)))) | ((dir)<<(b))), g)
+
+/* read specific bits 
+ * @mask: specific the bits you want to read 
+ * */
+#define HISILICON_GPIO_READ(g,mask) (*(volatile unsigned long*)(HISILICON_GPIO_GBASE(g)+((unsigned long)(mask)<<2)))
+
+/* read specific bit */
+#define HISILICON_GPIO_RDBIT(g,b) HISILICON_GPIO_READ(g,1<<(b))
+
+/* write specific bits */
+/* write (v & mask) to a group */
+#define HISILICON_GPIO_WRITE(v,g,mask) do{ *(volatile unsigned long*)(HISILICON_GPIO_GBASE(g)+((unsigned long)(mask)<<2)) = v; }while(0)
+
+/* write specific bit */
+#define HISILICON_GPIO_WRBIT(v,g,b) HISILICON_GPIO_WRITE((v)<<(b),g,1<<(b))
+
+#endif
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/hardware.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/hardware.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/hardware.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/hardware.h	2024-10-15 19:44:37.174733517 +0300
@@ -0,0 +1,85 @@
+/* linux/include/asm-arm/arch-hi3515v100/hardware.h
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+#include <mach/platform.h>
+
+#ifndef __ASM_ARCH_HARDWARE_H 
+#define __ASM_ARCH_HARDWARE_H 
+
+#ifndef CONFIG_HISILICON_OSC_CLOCK
+	#define HISILICON_OSC_CLOCK	24000000
+#else
+	#define HISILICON_OSC_CLOCK	CONFIG_HISILICON_OSC_CLOCK
+#endif
+
+#ifdef CONFIG_HISILICON_ARMCORECLK_SCALE
+	#define HISILICON_ARMCORECLK_SCALE CONFIG_HISILICON_ARMCORECLK_SCALE
+#else
+	#define HISILICON_ARMCORECLK_SCALE 3
+#endif
+
+#ifdef CONFIG_HISILICON_AHBCLK_DEF
+#define HISILICON_AHBCLK_DEFAULT (CONFIG_HISILICON_AHBCLK_DEF)
+#else
+#define HISILICON_AHBCLK_DEFAULT (200*MHZ)
+#endif
+
+#define hisilicon_readl(addr) readl(addr)
+
+#define hisilicon_writel(value,mask,addr)  do{	unsigned long t, flags;\
+	                                        local_irq_save(flags);\
+                                                t = readl(addr);\
+	                                        t &= ~mask;\
+    	                                        t |= value & mask;\
+    	                                        writel(value, addr);\
+                                        	local_irq_restore(flags);\
+                                            }while(0)
+                                            
+
+#define __IO_ADDRESS_INRANGE(x, base, size) ( (((x)>=(base)) && ((x)<((base)+(size))))&0x01 )
+#define __IO_ADDRESS_T(x, base, size, new) ( __IO_ADDRESS_INRANGE(x,base,size)*( (new) + ((x)-(base))) )
+
+#define __IO_ADDRESS(x) ( \
+		__IO_ADDRESS_T(x, 0x10000000, 0x00100000, 0x00100000) + \
+		__IO_ADDRESS_T(x, 0x10100000, 0x00100000, 0x00200000) + \
+		__IO_ADDRESS_T(x, 0x20000000, 0x00100000, 0x00300000) + \
+		__IO_ADDRESS_T(x, 0x20100000, 0x00100000, 0x00400000) + \
+		__IO_ADDRESS_T(x, 0xb0000000, 0x00100000, 0x00500000) + \
+		0 )
+
+#define IO_ADDRESS(x) ( ((__IO_ADDRESS(x)>0)&0x01)*(__IO_ADDRESS(x)+0xFE000000) )
+
+#define BUSCLK_TO_CPUCLK(x) ((x)*CONFIG_CPUCLK_MULTI)
+#define CPUCLK_TO_BUSCLK(x) ((x)/CONFIG_CPUCLK_MULTI)
+/* CIK guesswork */
+#define PCIBIOS_MIN_IO			0xB0010000
+#define PCIBIOS_MIN_MEM			0xB0020000
+#define pcibios_assign_all_busses()     1
+#define SC_LOCK()	writel(0, IO_ADDRESS(REG_BASE_SCTL + REG_SC_PERLOCK))
+#define SC_UNLOCK()	writel(REG_VALUE_SC_NOLOCK, IO_ADDRESS(REG_BASE_SCTL + REG_SC_PERLOCK))
+#define IS_SC_LOCKED()	(readl(IO_ADDRESS(REG_BASE_SCTL + REG_SC_PERLOCK)) == REG_VALUE_SC_LOCKED)
+
+#if (CONFIG_HISILICON_KCONSOLE==1)
+	#define BOOTUP_UART_BASE REG_BASE_UART1	
+#else
+	#define BOOTUP_UART_BASE REG_BASE_UART0	
+#endif
+
+#endif /* __ASM_ARCH_HARDWARE_H */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/io.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/io.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/io.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/io.h	2024-10-15 18:26:13.674161344 +0300
@@ -0,0 +1,37 @@
+/* linux/include/asm-arm/arch-hi3515v100/io.h
+*
+* Copyright (c) 2008 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_PHYS_START	0x10000000
+#define IO_SPACE_LIMIT		0xFF000000
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	        return (void __iomem *)addr;
+}
+
+#define __io(a) __io(a)
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+#endif /* __ASM_ARCH_IO_H */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/irqs.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/irqs.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/irqs.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/irqs.h	2024-10-16 23:01:52.936940814 +0300
@@ -0,0 +1,27 @@
+/* linux/include/asm-arm/arch-hi3515v100/irqs.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+#include <mach/platform.h>
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define NR_IRQS 32
+
+#endif /* __ASM_ARCH_IRQS_H */
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/led.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/led.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/led.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/led.h	2024-10-15 19:37:02.645862664 +0300
@@ -0,0 +1,46 @@
+/* linux/include/asm-arm/arch-hi3515v100/led.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <mach/gpio.h>
+
+#ifndef __ASM_ARCH_LED_H
+#define __ASM_ARCH_LED_H
+
+#ifdef CONFIG_LEDS_CPU
+
+#define CPULED_GPIO_GRP ((CONFIG_HISILICON_GPIO_CPU_LED%100)/10)
+#define CPULED_GPIO_BIT (CONFIG_HISILICON_GPIO_CPU_LED%10)
+#define CPULED_INVEST	(CONFIG_HISILICON_GPIO_CPU_LED/100)
+#define CPULED_VAL(x)	(CPULED_INVEST==0 ? !(x):(x))
+
+#define cpu_led_init() HISILICON_GPIO_SET_BITDIR(1,CPULED_GPIO_GRP,CPULED_GPIO_BIT)
+#define cpu_led_wr(x) HISILICON_GPIO_WRBIT(CPULED_VAL(x),CPULED_GPIO_GRP,CPULED_GPIO_BIT)
+#define cpu_led_rd() CPULED_VAL(HISILICON_GPIO_RDBIT(CPULED_GPIO_GRP,CPULED_GPIO_BIT))
+
+#else
+
+#define cpu_led_init() 
+#define cpu_led_wr(x) 
+#define cpu_led_rd() 
+
+#endif /* CONFIG_LEDS_CPU */
+
+#endif /* __ASM_ARCH_LED_H */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/platform.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/platform.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/platform.h	2024-10-15 18:54:01.007645468 +0300
@@ -0,0 +1,292 @@
+/* linux/include/asm-arm/arch-hi3515v100/platform.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef	__HI_CHIP_REGS_H__
+#define	__HI_CHIP_REGS_H__
+
+
+#define REG_BASE_NANDC	0x10000000
+#define REG_NANDC_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_SMI	0x10010000
+#define REG_SMI_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_SDIO	0x10030000
+#define REG_SDIO_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_SIO0	0x10040000
+#define REG_SIO0_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_SIO1	0x10050000
+#define REG_SIO1_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_INTC 	0x10070000	
+#define REG_INTC_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_ETH 	0x10090000	
+#define REG_ETH_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_USBOHCI 	0x100a0000	
+#define REG_USBOHCI_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_USBEHCI 	0x100b0000	
+#define REG_USBEHCI_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_CIPHER 	0x100c0000	
+#define REG_CIPHER_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_DMAC 	0x100d0000	
+#define REG_DMAC_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_VEDU0	0x100e0000	
+#define REG_VEDU0_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_VIU 	0x10100000	
+#define REG_VIU_IOSIZE 	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_TIMER12	0x20000000
+#define REG_TIMER12_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_TIMER34	0x20010000
+#define REG_TIMER34_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_WDG	0x20040000
+#define REG_WDG_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_SCTL	0x20050000
+#define REG_SCTL_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_RTC	0x20060000
+#define REG_RTC_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_IR	0x20070000
+#define REG_IR_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_UART0	0x20090000
+#define REG_UART0_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_UART1	0x200a0000
+#define REG_UART1_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_UART2	0x200b0000
+#define REG_UART2_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_UART3	0x200c0000
+#define REG_UART3_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_I2C	0x200d0000
+#define REG_I2C_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_SPI	0x200e0000
+#define REG_SPI_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_IO	0x200f0000
+#define REG_IO_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_DDRC	0x20110000
+#define REG_DDRC_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_VOU	0x20130000
+#define REG_VOU_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_TDE	0x20140000
+#define REG_TDE_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO0	0x20150000
+#define REG_GPIO0_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO1	0x20160000
+#define REG_GPIO1_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO2	0x20170000
+#define REG_GPIO2_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO3	0x20180000
+#define REG_GPIO3_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO4	0x20190000
+#define REG_GPIO4_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO5	0x201a0000
+#define REG_GPIO5_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO6	0x201b0000
+#define REG_GPIO6_IOSIZE	PAGE_ALIGN(0x10000)
+
+#define REG_BASE_GPIO7	0x201c0000
+#define REG_GPIO7_IOSIZE	PAGE_ALIGN(0x10000)
+
+
+/* SYSTEM CONTROL REG */
+#define REG_SC_CTRL	0x000
+#define REG_SC_SYSSTAT	0x004
+#define REG_SC_ITMCTRL	0x008
+#define REG_SC_IMSTAT	0x00C
+#define REG_SC_XTALCTRL	0x010
+#define REG_SC_PLLCTRL	0x014
+#define REG_SC_PLLFCTRL	0x018
+#define REG_SC_PERCTRL0	0x01C
+#define REG_SC_PERCTRL1	0x020
+#define REG_SC_PEREN	0x024
+#define REG_SC_PERDIS	0x028
+#define REG_SC_PERCLKEN	0x02C
+#define REG_SC_RESERVED	0x030
+#define REG_SC_PERCTRL2	0x034
+#define REG_SC_PERCTRL3	0x038
+#define REG_SC_PERCTRL4	0x03C
+#define REG_SC_PERLOCK	0x044
+#define REG_SC_SYSID	0xEE0
+#define REG_SC_SLAVE	0x050
+
+/* SMI REG */
+#define REG_SMI_BIDCYR1			0x000
+#define REG_SMI_BWSTRDR1		0x004
+#define REG_SMI_BWSTWRR1		0x008
+#define REG_SMI_BWSTOENR1		0x00C
+#define REG_SMI_BWSTWENR1		0x010
+#define REG_SMI_BCR1			0x014
+#define REG_SMI_BSR1			0x018
+#define REG_SMI_BWSTBRDR1		0x01C
+#define REG_SMI_BIDCYR0			0x0E0
+#define REG_SMI_BWSTRDR0		0x0E4
+#define REG_SMI_BWSTWRR0		0x0E8
+#define REG_SMI_BWSTOENR0		0x0EC
+#define REG_SMI_BWSTWENR0		0x0F0
+#define REG_SMI_BCR0			0X0F4
+#define REG_SMI_BSR0			0x0F8
+#define REG_SMI_BWSTBRDR0		0x0FC
+#define REG_SMI_SR				0x200
+#define REG_SMI_CR				0x204
+
+#define REG_INTC_IRQSTATUS	0x000
+#define REG_INTC_FIQSTATUS	0x004
+#define REG_INTC_RAWSTATUS	0x008
+#define REG_INTC_INTSELECT	0x00C
+#define REG_INTC_INTENABLE	0x010
+#define REG_INTC_INTENCLEAR	0x014
+#define REG_INTC_SOFTINT	0x018
+#define REG_INTC_SOFTINTCLEAR	0x01C
+#define REG_INTC_PROTECTION	0x020
+
+#define INTNR_IRQ_START	0
+#define INTNR_IRQ_END	31
+
+#define INTNR_WATCHDOG					0	/* Watchdog timer */
+#define INTNR_SOFTINT					1	/* Software interrupt */
+#define INTNR_COMMRx					2	/* Debug Comm Rx interrupt */
+#define INTNR_COMMTx					3	/* Debug Comm Tx interrupt */
+#define INTNR_TIMER_0_1					4	/* Timer 0 and 1 */
+#define INTNR_TIMER_2_3                 5	/* Timer 2 and 3 */
+#define INTNR_GPIO_0                    6	/* GPIO 0 */
+#define INTNR_GPIO_1                    7	/* GPIO 1 */
+#define INTNR_GPIO_2_7                  8	/* GPIO 2 */
+#define INTNR_IR						9	/* GPIO 3 */
+#define INTNR_RTC						10	/* Real Time Clock */
+#define INTNR_SPI						11	/* Synchronous Serial Port */
+#define INTNR_UART0						12
+#define INTNR_UART1						12
+#define INTNR_UART2						13
+#define INTNR_UART3						13
+#define INTNR_ETH						14
+#define INTNR_DMAC						15
+#define INTNR_I2C						16
+#define INTNR_VIU						17
+#define INTNR_TDE						18
+#define INTNR_VOU						19
+#define INTNR_VEDU						20
+#define INTNR_OHCI						22
+#define INTNR_EHCI						23
+#define INTNR_SDIO						24
+#define INTNR_SIO_0						25
+#define INTNR_SIO_1						26
+#define INTNR_CIPHER					28
+#define INTNR_SATA						29
+#define INTNR_NANDC						30
+
+#define REG_TIMER_RELOAD	0x000
+#define REG_TIMER_VALUE		0x004
+#define REG_TIMER_CONTROL	0x008
+#define REG_TIMER_INTCLR	0x00C
+#define REG_TIMER_RIS		0x010
+#define REG_TIMER_MIS		0x004
+#define REG_TIMER_BGLOAD	0x008
+
+#define REG_TIMER1_RELOAD	0x020
+#define REG_TIMER1_VALUE	0x024
+#define REG_TIMER1_CONTROL	0x028
+#define REG_TIMER1_INTCLR	0x02C
+#define REG_TIMER1_RIS		0x030
+#define REG_TIMER1_MIS		0x034
+#define REG_TIMER1_BGLOAD	0x038
+	
+#define REG_DDRC_STATUS		0x000
+#define REG_DDRC_CTRL		0x004
+#define REG_DDRC_EMRS01		0x008
+#define REG_DDRC_EMRS23		0x00C
+#define REG_DDRC_CONFIG		0x010
+#define REG_DDRC_TIMING0	0x020
+#define REG_DDRC_TIMING1	0x024
+#define REG_DDRC_TIMING2	0x028
+#define REG_DDRC_TIMING3	0x02C
+#define REG_DDRC_ODT_CONFIG	0x040
+#define REG_DDRC_PHY_CONFIG	0x060
+#define REG_DDRC_DLL_STATUS	0x078
+#define REG_DDRC_DLL_CONFIG	0x07C
+#define REG_DDRC_QOS_CONFIG	0x094
+#define REG_DDRC_CH0_QOS	0x098
+#define REG_DDRC_CH1_QOS	0x09C
+#define REG_DDRC_CH2_QOS	0x0A0
+#define REG_DDRC_CH3_QOS	0x0A4
+#define REG_DDRC_CH4_QOS	0x0A8
+#define REG_DDRC_CH5_QOS	0x0AC
+#define REG_DDRC_CH6_QOS	0x0B0
+#define REG_DDRC_CH7_QOS	0x0B4
+
+#define DDRC_BUSWITH_32BITS     1
+#define DDRC_BUSWITH_16BITS     0
+
+#define DDRC_CHIPCAP_64Mb       0
+#define DDRC_CHIPCAP_128Mb      1
+#define DDRC_CHIPCAP_256Mb      2
+#define DDRC_CHIPCAP_512Mb      3
+#define DDRC_CHIPCAP_1Gb      	4
+#define DDRC_CHIPCAP_2Gb      	5
+
+#define DDRC_CHIP_8BITS         0
+#define DDRC_CHIP_16BITS        1
+#define DDRC_CHIP_32BITS        2
+
+#define DDRC_CHIP_4BANK         0
+#define DDRC_CHIP_8BANK         1
+
+#define DDRC_READDELAY_2        0
+#define DDRC_READDELAY_2_5      1
+#define DDRC_READDELAY_3        2
+#define DDRC_READDELAY_4        3
+#define DDRC_READDELAY_5        4
+#define DDRC_READDELAY_6        5
+
+
+#define MEM_BASE_ITCM	0x00000000
+#define MEM_SIZE_ITCM	0x00000800
+#define MEM_CONF_ITCM_SIZE	3
+
+#endif /*End of __HI_CHIP_REGS_H__ */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/system.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/system.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/system.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/system.h	2024-10-15 19:46:36.099145854 +0300
@@ -0,0 +1,36 @@
+/* linux/include/asm-arm/arch-hi3515v100/system.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/platform.h>
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+void arch_idle(void);
+void arch_reset(char mode);
+
+
+#define hisilicon_intc_reg(x)	(void*)IO_ADDRESS(REG_BASE_INTC + (x))
+#define hisilicon_sctl_reg(x)	(void*)IO_ADDRESS(REG_BASE_SCTL +(x))
+
+#endif /* __ASM_ARCH_SYSTEM_H */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/timer.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/timer.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/timer.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/timer.h	2024-10-15 18:56:27.675161553 +0300
@@ -0,0 +1,72 @@
+/* linux/include/asm-arm/arch-hi3515v100/timer.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef __ASM_ARCH_TIMER_H__
+#define __ASM_ARCH_TIMER_H__
+
+#define CFG_TIMER_VABASE	IO_ADDRESS(REG_BASE_TIMER12)
+#define CFG_TIMER_CONTROL	( (1<<7) | (1<<6) | (1<<5) | (1<<1) )
+#define CFG_TIMER_ONE_CONTROL	( (1<<7) | (1<<5) | (1<<1)| 1 )
+#define CONFIG_DEFAULT_TIMERCLK  (100000000)
+#define CFG_TIMER_PRESCALE      2	
+#define BUSCLK_TO_TIMER_RELOAD(busclk)	(((busclk)/CFG_TIMER_PRESCALE)/HZ)
+#define BUSCLK_TO_TIMER0_CLK_HZ(busclk)  ((busclk)/CFG_TIMER_PRESCALE)
+#define BUSCLK_TO_TIMER1_CLK_HZ(busclk)  ((busclk)/CFG_TIMER_PRESCALE)
+#define BUSCLK_TO_TIMER0_CLK_KHZ(busclk) (((busclk)/CFG_TIMER_PRESCALE)/1000)
+#define BUSCLK_TO_TIMER1_CLK_KHZ(busclk) (((busclk)/CFG_TIMER_PRESCALE)/1000)
+#define CFG_TIMER_INTNR		INTNR_TIMER_0_1
+struct hisilicon_timer_onchip{
+        unsigned long reload;
+        unsigned long value;
+        unsigned long ctrl;
+        unsigned long clear;
+
+        unsigned long ris_ro;
+        unsigned long mis_ro;
+        unsigned long bigload;
+};
+
+#define hisilicon_onchip_timer1(n) ((struct hisilicon_timer_onchip *)IO_ADDRESS(REG_BASE_TIMER12))
+#define hisilicon_onchip_timer2(n) ((struct hisilicon_timer_onchip *)IO_ADDRESS(REG_BASE_TIMER23))
+
+#define __TIMER_CTRL(tmr_ena, tmr_mode, int_ena, clk_pre, tmr_size, one_shot) \
+		( (((tmr_ena)&0x01)<<7) | (((tmr_mode)&0x01)<<6) | (((int_ena)&0x01)<<5) | \
+		  (((clk_pre)&0x03)<<2) | (((tmr_size)&0x01)<<1) | ((one_shot)&0x01) )
+
+#define HISILICON_SYSTIMER_CTRL       __TIMER_CTRL(1,1,1,1,1,0)
+
+#define __CALC_TIMER_RELOAD_DIVER	(16*HZ)
+#define __CALC_TIMER_RELOAD(ahb_clk)	(((ahb_clk)+__CALC_TIMER_RELOAD_DIVER/2)/__CALC_TIMER_RELOAD_DIVER)
+#define HISILICON_SYSTIMER_RELOAD     __CALC_TIMER_RELOAD(HISILICON_AHBCLK_DEFAULT)
+
+#define HIS_TIMER_INT_CLEAN(timer) do{ ((volatile struct hisilicon_timer_onchip *)(timer))->clear = 0x00; }while(0)
+
+
+extern unsigned long hisilicon_timer_reload;
+
+#define hisilicon_ticks2us(ticks) (((ticks)*((1000000/HZ) >> 2))/(hisilicon_timer_reload >> 2))
+void hisilicon_timer_init(void);
+unsigned long hisilicon_gettimeoffset(void);
+unsigned long long sched_clock(void);
+
+#endif /* __ASM_ARCH_TIMER_H__ */
+
+
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/timex.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/timex.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/timex.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/timex.h	2024-10-15 18:56:39.591628862 +0300
@@ -0,0 +1,27 @@
+/* linux/include/asm-arm/arch-hi3515v100/timex.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE		(100000000 / 16)
+
+#endif /* __ASM_ARCH_TIMEX_H */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/uncompress.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/uncompress.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/uncompress.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/uncompress.h	2024-11-04 01:03:23.232795824 +0300
@@ -0,0 +1,53 @@
+/* linux/include/asm-arm/arch-hi3515v100/uncompress.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#define IOMEM(x)	(x)
+
+#define BOOTUP_UART_BASE 0x20090000 //using uart0
+
+#define AMBA_UART_DR	(*(volatile unsigned char *)(BOOTUP_UART_BASE + 0x000))
+#define AMBA_UART_LCRH	(*(volatile unsigned char *)(BOOTUP_UART_BASE + 0x02C))
+#define AMBA_UART_CR	(*(volatile unsigned char *)(BOOTUP_UART_BASE + 0x030))
+#define AMBA_UART_FR	(*(volatile unsigned char *)(BOOTUP_UART_BASE + 0x018))
+/*
+ * This does not append a newline
+ */
+
+static inline void putc(int c)
+{
+	if (c) {
+		while (AMBA_UART_FR & (1 << 5))
+			barrier();
+		AMBA_UART_DR = c;
+	}
+	while (AMBA_UART_FR & (1 << 3))
+		barrier();
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/include/mach/vmalloc.h linux-master-mod/arch/arm/mach-hi3515v100/include/mach/vmalloc.h
--- linux-master/arch/arm/mach-hi3515v100/include/mach/vmalloc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/include/mach/vmalloc.h	2024-10-15 19:06:36.361943671 +0300
@@ -0,0 +1,27 @@
+/* linux/include/asm-arm/arch-hi3515v100/vmalloc.h
+*
+* Copyright (c) 2009 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#ifndef __ASM_ARCH_VMALLOC_H__
+#define __ASM_ARCH_VMALLOC_H__
+
+#define VMALLOC_END		(PAGE_OFFSET + 0x20000000)
+
+#endif /* __ASM_ARCH_VMALLOC_H__ */
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/interrupt-arm.S linux-master-mod/arch/arm/mach-hi3515v100/interrupt-arm.S
--- linux-master/arch/arm/mach-hi3515v100/interrupt-arm.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/interrupt-arm.S	2010-03-16 05:41:14.000000000 +0300
@@ -0,0 +1,156 @@
+/* linux/include/asm/arch-hi3515v100/entry-macro.S
+*
+* Copyright (c) 2008 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+
+#include <linux/autoconf.h>
+#include <asm/arch/hardware.h>
+#ifdef CONFIG_HI_PRIO_IRQ
+#define NR_IRQS 32
+irq_priority_base:
+.word irq_priority
+                .macro  disable_fiq
+                .endm
+
+                .macro  get_irqnr_preamble, base, tmp
+                .endm
+
+                .macro  arch_ret_to_user, tmp1, tmp2
+                .endm
+
+
+		.macro	get_irqnr_and_base, irqnr, prio, base, tmp
+		ldr	\base, =IO_ADDRESS(REG_BASE_INTC)
+		ldr	\tmp, [\base, #REG_INTC_IRQSTATUS]	@ get masked status
+
+		ldr     \base, irq_priority_base
+		mov	\irqnr, \base
+		ldr     \prio, [\base]			@ priority 0
+		ands	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]! 		@ priority 1
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 2
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 3
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 4
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 5
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 6
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 7
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 8
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 9
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 10
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 11
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 12
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 13
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 14
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 15
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 16
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 17
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 18
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 19
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 20 
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 21
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 22
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 23
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 24
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 25
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 26
+		andeqs	\prio, \tmp, \prio
+
+
+		ldreq   \prio, [\base, #4]!		@ priority 27
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 28
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 29
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 30 
+		andeqs	\prio, \tmp, \prio
+
+		ldreq   \prio, [\base, #4]!		@ priority 31
+		andeqs	\prio, \tmp, \prio
+
+
+
+		sub	\base,	\base,	\irqnr
+		mov	\base,	\base,	lsr#2
+		clzne	\irqnr, \prio
+		rsbne	\irqnr, #(NR_IRQS-1)
+		.endm
+#endif
+
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/Kconfig linux-master-mod/arch/arm/mach-hi3515v100/Kconfig
--- linux-master/arch/arm/mach-hi3515v100/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/Kconfig	2024-11-29 21:10:44.802680625 +0300
@@ -0,0 +1,34 @@
+# menu "HI3515"
+
+menuconfig ARCH_HI3515V100
+	bool "hi3515v100 media processor"
+	select HISILICON_ARM926ejs
+	select ARM_AMBA
+	select EMBEDDED
+	select NEED_MACH_IO_H
+	select GENERIC_IRQ_CHIP
+	select IRQ_DOMAIN
+	select ARM_TIMER_SP804
+	select MFD_HI3515_SYSCON
+	select ARCH_HISI
+# 	select ARCH_HAS_ZONE_DMA_SET
+	select ARM_VIC
+	select CRYPTO_ENGINE
+	select ARM_SP805_WATCHDOG
+	select WATCHDOG
+	select RTC_DRV_PL031
+	select RTC_LIB
+	select RTC_CLASS
+	select RTC_INTF_DEV
+	select RTC_INTF_PROC
+	select RTC_INTF_SYSFS
+	select RTC_NVMEM
+	select FB_DMAMEM_HELPERS
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select CONSOLE_POLL
+	select ZBOOT_ROM
+	help
+	  This enables support for system based on the Hisilicon hi3515v100 series media proccessor
+
+
+# endmenu
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/Makefile linux-master-mod/arch/arm/mach-hi3515v100/Makefile
--- linux-master/arch/arm/mach-hi3515v100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/Makefile	2024-10-17 23:01:51.796227960 +0300
@@ -0,0 +1,6 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Common support
+# obj-y := core.o platform-devices.o
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/platform-devices.c linux-master-mod/arch/arm/mach-hi3515v100/platform-devices.c
--- linux-master/arch/arm/mach-hi3515v100/platform-devices.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/platform-devices.c	2024-10-15 21:03:47.495889527 +0300
@@ -0,0 +1,182 @@
+/* linux/arch/arm/mach-hi3515_v100/platform-devices.c
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/amba/bus.h>
+#include <linux/platform_device.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/map.h>
+
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#include <mach/io.h>
+#include <mach/timer.h>
+
+#include <linux/delay.h>
+
+#include <mach/led.h>
+#include <mach/early-debug.h>
+#include <linux/mtd/plat-ram.h>
+#include <linux/mtd/partitions.h>
+
+#if 0
+static struct resource hisilicon_usbhost_resources[] = {
+	[0] = {
+		.start = REG_BASE_USB11,
+		.end   = (REG_BASE_USB11+ 0xffff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INTNR_USB11,
+		.end   = INTNR_USB11,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 hisilicon_usbhost_dma_mask = 0xffffffffUL;
+
+static struct platform_device hisilicon_usbhost_device = {
+	        .name = "hisilicon-ohci",
+		.id   = 0,
+		.dev  = {
+			.dma_mask = &hisilicon_usbhost_dma_mask,
+			.coherent_dma_mask = 0xffffffffUL,
+		},
+		.num_resources = ARRAY_SIZE(hisilicon_usbhost_resources),
+		.resource = hisilicon_usbhost_resources,
+};
+
+
+	
+static struct resource hisilicon_eth_resources[] = {
+	[0] = {
+		.start = REG_BASE_GMAC,
+		.end   = REG_BASE_GMAC + REG_GMAC_IOSIZE,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INTNR_GMAC,
+		.end   = INTNR_GMAC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource hisilicon_ethv100_resources[] = {
+	[0] = {
+		.start = REG_BASE_GMAC,
+		.end   = REG_BASE_GMAC + REG_GMAC_IOSIZE,
+		.flags = IORESOURCE_MEM,
+		.parent = &hisilicon_eth_resources[0],
+	},
+
+	[1] = {
+		.start = INTNR_GMAC,
+		.end   = INTNR_GMAC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource hisilicon_ethv100_mdio_resources[] = {
+	[0] = {
+		.start = REG_BASE_GMAC,
+		.end   = REG_BASE_GMAC + REG_GMAC_IOSIZE,
+		.flags = IORESOURCE_MEM,
+		.parent = &hisilicon_ethv100_resources[0],
+	},
+};
+
+static struct platform_device hisilicon_ethv100_device = {
+	        .name = "hiethv100",
+		.id   = 0,
+		.num_resources = ARRAY_SIZE(hisilicon_ethv100_resources),
+		.resource = hisilicon_ethv100_resources,
+};
+
+static struct platform_device hisilicon_mdiobus_device = {
+	        .name = "hiethv100_mdiobus",
+		.id   = 0,
+		.num_resources = ARRAY_SIZE(hisilicon_ethv100_mdio_resources),
+		.resource = hisilicon_ethv100_mdio_resources,
+};
+
+static struct platform_device hisilicon_eth_device = {
+	        .name = "Hi3511-ETH",
+		.id   = 0,
+		.num_resources = ARRAY_SIZE(hisilicon_eth_resources),
+		.resource = hisilicon_eth_resources,
+};
+#endif
+static struct resource hisilicon_sfv300_resources[] = {
+	[0] = {
+		.start = 0x10090000,/*hi3515v100 sfv300*/
+		.end   = 0x10090000 + 0xffff,
+		.flags = IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start = 14,/*hi3515v100 sfv300*/
+		.end   = 14,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device hisilicon_sfv300_device = {
+	.name = "hisfv300",
+	.id   = 0,
+	.num_resources = ARRAY_SIZE(hisilicon_sfv300_resources),
+	.resource = hisilicon_sfv300_resources,
+};
+
+static struct resource hisilicon_sfv300_mdio_resources[] = {
+	[0] = {
+		.start = 0x10090000,/*hi3515v100 sfv300*/
+		.end   = 0x10090000 + 0xffff,
+		.flags = IORESOURCE_MEM,
+		.parent = &hisilicon_sfv300_resources[0],
+	},
+};
+
+static struct platform_device hisilicon_mdiobus_device = {
+	.name = "hisfv300_mdiobus",
+	.id   = 0,
+	.num_resources = ARRAY_SIZE(hisilicon_sfv300_mdio_resources),
+	.resource = hisilicon_sfv300_mdio_resources,
+};
+
+static struct platform_device *hisilicon_plat_devs[] __initdata = {
+	&hisilicon_sfv300_device,
+	&hisilicon_mdiobus_device,
+};
+
+
+int __init hisilicon_register_platform_devices(void)
+{
+	platform_add_devices(hisilicon_plat_devs, ARRAY_SIZE (hisilicon_plat_devs));
+	
+	return 0;
+}
diff --no-dereference -ruN linux-master/arch/arm/mach-hi3515v100/systimer.c linux-master-mod/arch/arm/mach-hi3515v100/systimer.c
--- linux-master/arch/arm/mach-hi3515v100/systimer.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/arch/arm/mach-hi3515v100/systimer.c	2024-10-15 22:23:26.967355074 +0300
@@ -0,0 +1,93 @@
+/* linux/arch/arm/mach-hi3515_v100/systimer.c
+*
+* Copyright (c) 2006 Hisilicon Co., Ltd. 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+*
+*/
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <linux/amba/bus.h>
+#include <linux/clk.h>
+
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/map.h>
+
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#include <mach/io.h>
+#include <mach/timer.h>
+#include <mach/clock.h>
+
+#include <linux/delay.h>
+
+#include <mach/led.h>
+#include <mach/early-debug.h>
+
+extern unsigned long hisilicon_timer_reload;
+
+static int sys_timer_notifier(struct clk *clk, 
+		unsigned int cmd, unsigned long wparam, unsigned long lparam)
+{
+	int ret = 0;
+	struct clk *p;
+
+	switch(cmd)
+	{
+	case HISILICON_CLK_REGISTER:
+	case HISILICON_CLK_PARENT_SETRATE:
+		p = clk_get_parent(clk);
+		if(p==NULL)
+			break;
+
+		hisilicon_timer_reload = BUSCLK_TO_TIMER_RELOAD(clk_get_rate(p));
+		writel(hisilicon_timer_reload, (void*)(CFG_TIMER_VABASE + REG_TIMER_RELOAD));
+		clk->rate = clk_get_rate(p)/CFG_TIMER_PRESCALE;
+		break;
+
+	default:
+		ret =  hisilicon_clk_default_notifier(clk, cmd, wparam, lparam);
+		break;
+	}
+
+	return ret;
+}
+
+
+static struct clk timer1_clk = {
+	.name		= "SYSTIMER",
+	.notifier	= sys_timer_notifier,
+	.parent_name = "BUSCLK",
+};
+
+static int __init __system_timer_init(void)
+{
+	clk_register(&timer1_clk);
+
+	edb_trace(1);
+
+	return 0;
+}
+
+module_init(__system_timer_init);
diff --no-dereference -ruN linux-master/arch/arm/Makefile linux-master-mod/arch/arm/Makefile
--- linux-master/arch/arm/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/Makefile	2024-10-17 20:54:31.208285427 +0300
@@ -226,12 +226,14 @@
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 machine-$(CONFIG_PLAT_VERSATILE)	+= versatile
 machine-$(CONFIG_PLAT_SPEAR)		+= spear
+machine-$(CONFIG_ARCH_HI3515V100)       += hi3515v100
 
 # legacy platforms provide their own mach/*.h headers globally,
 # these three are mutually exclusive
 machdirs-$(CONFIG_ARCH_FOOTBRIDGE)	+= arch/arm/mach-footbridge
 machdirs-$(CONFIG_ARCH_RPC)		+= arch/arm/mach-rpc
 machdirs-$(CONFIG_ARCH_SA1100)		+= arch/arm/mach-sa1100
+machdirs-$(CONFIG_ARCH_HI3515V100)	+= arch/arm/mach-hi3515v100
 KBUILD_CPPFLAGS += $(patsubst %,-I$(srctree)/%/include,$(machdirs-y))
 
 # The byte offset of the kernel image in RAM from the start of RAM.
diff --no-dereference -ruN linux-master/arch/arm/tools/mach-types linux-master-mod/arch/arm/tools/mach-types
--- linux-master/arch/arm/tools/mach-types	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/arch/arm/tools/mach-types	2024-10-15 01:16:37.295532025 +0300
@@ -86,7 +86,7 @@
 enp2611			ARCH_ENP2611		ENP2611			356
 s3c2440			ARCH_S3C2440		S3C2440			362
 gumstix			ARCH_GUMSTIX		GUMSTIX			373
-omap_h2			MACH_OMAP_H2		OMAP_H2			382
+
 e740			MACH_E740		E740			384
 iq80331			ARCH_IQ80331		IQ80331			385
 versatile_pb		ARCH_VERSATILE_PB	VERSATILE_PB		387
@@ -599,3 +599,4 @@
 remarkable		MACH_REMARKABLE		REMARKABLE		5106
 fa0113			MACH_FA0113		FA0113			5107
 innova_statnettawm	MACH_INNOVA_STATNETTAWM	INNOVA_STATNETTAWM	5108
+hi3515v100	        ARCH_hi3515v100		hi3515v100		387
diff --no-dereference -ruN linux-master/build.sh linux-master-mod/build.sh
--- linux-master/build.sh	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/build.sh	2024-11-02 21:40:18.605649452 +0300
@@ -0,0 +1,12 @@
+#!/bin/bash
+clear
+make -j4 zImage dtbs
+cat arch/arm/boot/zImage arch/arm/boot/dts/hisilicon/hi3515v100-avtech-dr082.dtb > ./zImgwd
+
+make -j4 headers
+
+mkdir headers_install
+
+make INSTALL_HDR_PATH=headers_install headers_install
+
+tar -czf headers.tar.gz headers_install
diff --no-dereference -ruN linux-master/.config linux-master-mod/.config
--- linux-master/.config	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/.config	2024-11-29 21:11:10.689514310 +0300
@@ -0,0 +1,5474 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 6.12.0-rc3 Kernel Configuration
+#
+CONFIG_CC_VERSION_TEXT="arm-linux-gnueabi-gcc (GCC) 14.2.0"
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=140200
+CONFIG_CLANG_VERSION=0
+CONFIG_AS_IS_GNU=y
+CONFIG_AS_VERSION=24100
+CONFIG_LD_IS_BFD=y
+CONFIG_LD_VERSION=24100
+CONFIG_LLD_VERSION=0
+CONFIG_RUSTC_VERSION=108100
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_CAN_LINK_STATIC=y
+CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y
+CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y
+CONFIG_PAHOLE_VERSION=127
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_TABLE_SORT=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+# CONFIG_WERROR is not set
+CONFIG_LOCALVERSION="-AWOO"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_INIT=""
+CONFIG_DEFAULT_HOSTNAME="RAWR"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_WATCH_QUEUE=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+CONFIG_BPF=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# BPF subsystem
+#
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_BPF_JIT is not set
+# end of BPF subsystem
+
+CONFIG_PREEMPT_NONE_BUILD=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_TINY_SRCU=y
+CONFIG_NEED_TASKS_RCU=y
+# end of RCU Subsystem
+
+CONFIG_IKCONFIG=m
+CONFIG_IKCONFIG_PROC=y
+CONFIG_IKHEADERS=m
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_PRINTK_INDEX is not set
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_CC_IMPLICIT_FALLTHROUGH="-Wimplicit-fallthrough=5"
+CONFIG_GCC10_NO_ARRAY_BOUNDS=y
+CONFIG_CC_NO_ARRAY_BOUNDS=y
+CONFIG_GCC_NO_STRINGOP_OVERFLOW=y
+CONFIG_CC_NO_STRINGOP_OVERFLOW=y
+# CONFIG_CGROUPS is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BOOT_CONFIG is not set
+CONFIG_INITRAMFS_PRESERVE_MTIME=y
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_HAVE_LD_DEAD_CODE_DATA_ELIMINATION=y
+# CONFIG_LD_DEAD_CODE_DATA_ELIMINATION is not set
+CONFIG_LD_ORPHAN_WARN=y
+CONFIG_LD_ORPHAN_WARN_LEVEL="warn"
+CONFIG_SYSCTL=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+# CONFIG_BASE_SMALL is not set
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KCMP=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
+CONFIG_CACHESTAT_SYSCALL=y
+# CONFIG_PC104 is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_SELFTEST is not set
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# end of Kernel Performance Events And Counters
+
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+
+#
+# Kexec and crash features
+#
+# CONFIG_KEXEC is not set
+# end of Kexec and crash features
+# end of General setup
+
+CONFIG_ARM=y
+CONFIG_ARM_HAS_GROUP_RELOCS=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_HISILICON_ARM926ejs=y
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_PHYS_OFFSET=0xc0000000
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+# CONFIG_ARCH_MULTIPLATFORM is not set
+
+#
+# Platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V4 is not set
+# CONFIG_ARCH_MULTI_V4T is not set
+CONFIG_ARCH_MULTI_V5=y
+CONFIG_ARCH_MULTI_V4_V5=y
+# CONFIG_ARCH_MULTI_V6 is not set
+# CONFIG_ARCH_MULTI_V7 is not set
+CONFIG_ARCH_MULTI_CPU_AUTO=y
+# end of Platform selection
+
+# CONFIG_MACH_ASM9260 is not set
+CONFIG_ARCH_HI3515V100=y
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_HISI=y
+
+#
+# Hisilicon platform type
+#
+# CONFIG_ARCH_SD5203 is not set
+# end of Hisilicon platform type
+
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_NPCM is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_WM8505 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+# end of System Type
+
+#
+# Bus support
+#
+# end of Bus support
+
+#
+# Kernel Features
+#
+CONFIG_IRQSTACKS=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+# CONFIG_HIGHMEM is not set
+CONFIG_ARM_PAN=y
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARM_MODULE_PLTS=y
+CONFIG_ARCH_FORCE_MAX_ORDER=16
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_CC_HAVE_STACKPROTECTOR_TLS=y
+# end of Kernel Features
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ARCH_WANT_FLAT_DTB_INSTALL=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x80100000
+CONFIG_ZBOOT_ROM_BSS=0xCA000000
+CONFIG_ZBOOT_ROM=y
+CONFIG_ARM_APPENDED_DTB=y
+# CONFIG_ARM_ATAG_DTB_COMPAT is not set
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_ARCH_SUPPORTS_KEXEC=y
+CONFIG_ARCH_SUPPORTS_CRASH_DUMP=y
+# CONFIG_AUTO_ZRELADDR is not set
+# end of Boot options
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+# end of CPU Frequency scaling
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_CPUIDLE=y
+# end of ARM CPU Idle Drivers
+# end of CPU Idle
+# end of CPU Power Management
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+# end of Floating point emulation
+
+#
+# Power management options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# end of Power management options
+
+CONFIG_AS_VFP_VMRS_FPINST=y
+CONFIG_CPU_MITIGATIONS=y
+CONFIG_ARCH_HAS_DMA_OPS=y
+
+#
+# General architecture-dependent options
+#
+CONFIG_KPROBES=y
+# CONFIG_JUMP_LABEL is not set
+CONFIG_OPTPROBES=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_FUNCTION_ERROR_INJECTION=y
+CONFIG_HAVE_NMI=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_KEEPINITRD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_ARCH_HAS_CPU_FINALIZE_INIT=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_ARCH_32BIT_OFF_T=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_MMU_LAZY_TLB_REFCOUNT=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP=y
+CONFIG_SECCOMP_FILTER=y
+# CONFIG_SECCOMP_CACHE_DEBUG is not set
+CONFIG_HAVE_ARCH_STACKLEAK=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_LTO_NONE=y
+CONFIG_ARCH_SUPPORTS_CFI_CLANG=y
+CONFIG_HAVE_CONTEXT_TRACKING_USER=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK=y
+CONFIG_SOFTIRQ_ON_OWN_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_HAVE_PAGE_SIZE_4KB=y
+CONFIG_PAGE_SIZE_4KB=y
+CONFIG_PAGE_SIZE_LESS_THAN_64KB=y
+CONFIG_PAGE_SIZE_LESS_THAN_256KB=y
+CONFIG_PAGE_SHIFT=12
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_HAVE_ARCH_VMAP_STACK=y
+CONFIG_VMAP_STACK=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+# CONFIG_STRICT_KERNEL_RWX is not set
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+# CONFIG_STRICT_MODULE_RWX is not set
+# CONFIG_LOCK_EVENT_COUNTS is not set
+CONFIG_ARCH_WANT_LD_ORPHAN_WARN=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_FUNCTION_ALIGNMENT=0
+CONFIG_CC_HAS_MIN_FUNCTION_ALIGNMENT=y
+CONFIG_CC_HAS_SANE_FUNCTION_ALIGNMENT=y
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_DEBUGFS=y
+CONFIG_MODULE_DEBUG=y
+# CONFIG_MODULE_STATS is not set
+# CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS is not set
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_UNLOAD_TAINT_TRACKING=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+CONFIG_MODPROBE_PATH="/sbin/modprobe"
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLOCK_LEGACY_AUTOLOAD=y
+CONFIG_BLK_DEV_BSG_COMMON=y
+CONFIG_BLK_DEV_BSGLIB=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+CONFIG_BLK_DEV_WRITE_MOUNTED=y
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_INLINE_ENCRYPTION is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+# end of Partition Types
+
+CONFIG_BLK_MQ_VIRTIO=y
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ASN1=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+# CONFIG_SWAP is not set
+CONFIG_ZSMALLOC=m
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_ZSMALLOC_CHAIN_SIZE=8
+
+#
+# Slab allocator options
+#
+CONFIG_SLUB=y
+# CONFIG_SLUB_TINY is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SLAB_BUCKETS is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_RANDOM_KMALLOC_CACHES is not set
+# end of Slab allocator options
+
+CONFIG_SHUFFLE_PAGE_ALLOCATOR=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_COMPACTION=y
+CONFIG_COMPACT_UNEVICTABLE_DEFAULT=1
+# CONFIG_PAGE_REPORTING is not set
+CONFIG_MIGRATION=y
+CONFIG_PCP_BATCH_SCALE_MAX=5
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CMA is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_ARCH_HAS_CPU_CACHE_ALIASING=y
+CONFIG_ARCH_HAS_CURRENT_STACK_POINTER=y
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_TEST is not set
+# CONFIG_DMAPOOL_TEST is not set
+CONFIG_MEMFD_CREATE=y
+# CONFIG_ANON_VMA_NAME is not set
+# CONFIG_USERFAULTFD is not set
+# CONFIG_LRU_GEN is not set
+CONFIG_ARCH_SUPPORTS_PER_VMA_LOCK=y
+CONFIG_LOCK_MM_AND_FIND_VMA=y
+CONFIG_EXECMEM=y
+
+#
+# Data Access Monitoring
+#
+# CONFIG_DAMON is not set
+# end of Data Access Monitoring
+# end of Memory Management options
+
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+CONFIG_NET_EGRESS=y
+CONFIG_SKB_DECRYPTED=y
+CONFIG_SKB_EXTENSIONS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_AF_UNIX_OOB=y
+CONFIG_UNIX_DIAG=y
+CONFIG_TLS=y
+CONFIG_TLS_DEVICE=y
+# CONFIG_TLS_TOE is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IP_TUNNEL=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE_COMMON=y
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_NET_IPVTI=m
+CONFIG_NET_UDP_TUNNEL=m
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TABLE_PERTURB_ORDER=16
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_INET_RAW_DIAG=m
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_ILA is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_IPV6_RPL_LWTUNNEL is not set
+# CONFIG_IPV6_IOAM6_LWTUNNEL is not set
+# CONFIG_MPTCP is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_EGRESS=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NETFILTER_NETLINK_OSF is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_LOG_SYSLOG is not set
+# CONFIG_NF_TABLES is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+CONFIG_NETFILTER_XT_MATCH_L2TP=m
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# end of Core Netfilter Configuration
+
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_IPTABLES_LEGACY=y
+CONFIG_NF_SOCKET_IPV4=y
+CONFIG_NF_TPROXY_IPV4=y
+CONFIG_NF_DUP_IPV4=y
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+CONFIG_NF_REJECT_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+CONFIG_IP_NF_MATCH_RPFILTER=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# end of IP: Netfilter Configuration
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_SOCKET_IPV6=m
+# CONFIG_NF_TPROXY_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+CONFIG_IP6_NF_IPTABLES=m
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_MATCH_SRH is not set
+# CONFIG_IP6_NF_FILTER is not set
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_RAW is not set
+# end of IPv6: Netfilter Configuration
+
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_OBJCNT is not set
+CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1 is not set
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_NONE is not set
+CONFIG_SCTP_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_COOKIE_HMAC_SHA1 is not set
+CONFIG_INET_SCTP_DIAG=m
+CONFIG_RDS=m
+CONFIG_RDS_TCP=m
+# CONFIG_RDS_DEBUG is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=m
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_QRTR is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_MAX_SKB_FRAGS=17
+CONFIG_SOCK_RX_QUEUE_MAPPING=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# end of Network testing
+# end of Networking options
+
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+CONFIG_BAYCOM_SER_FDX=m
+CONFIG_BAYCOM_SER_HDX=m
+CONFIG_YAM=m
+# end of AX.25 network device drivers
+
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_STREAM_PARSER=y
+# CONFIG_MCTP is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_SOCK_VALIDATE_XMIT=y
+CONFIG_NET_SELFTESTS=y
+CONFIG_NET_SOCK_MSG=y
+# CONFIG_FAILOVER is not set
+CONFIG_ETHTOOL_NETLINK=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+CONFIG_HAVE_PCI=y
+CONFIG_GENERIC_PCI_IOMAP=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=m
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# CONFIG_FW_UPLOAD is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_DEVICES=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+# CONFIG_FW_DEVLINK_SYNC_STATE_TIMEOUT is not set
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_MOXTET is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MHI_BUS is not set
+# CONFIG_MHI_BUS_EP is not set
+# end of Bus devices
+
+#
+# Cache Drivers
+#
+# end of Cache Drivers
+
+# CONFIG_CONNECTOR is not set
+
+#
+# Firmware Drivers
+#
+
+#
+# ARM System Control and Management Interface Protocol
+#
+CONFIG_ARM_SCMI_PROTOCOL=m
+# CONFIG_ARM_SCMI_RAW_MODE_SUPPORT is not set
+# CONFIG_ARM_SCMI_DEBUG_COUNTERS is not set
+
+#
+# SCMI Transport Drivers
+#
+# CONFIG_ARM_SCMI_TRANSPORT_VIRTIO is not set
+# end of SCMI Transport Drivers
+
+#
+# ARM SCMI NXP i.MX Vendor Protocols
+#
+# CONFIG_IMX_SCMI_BBM_EXT is not set
+# CONFIG_IMX_SCMI_MISC_EXT is not set
+# end of ARM SCMI NXP i.MX Vendor Protocols
+
+CONFIG_ARM_SCMI_POWER_CONTROL=m
+# end of ARM System Control and Management Interface Protocol
+
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Qualcomm firmware drivers
+#
+# end of Qualcomm firmware drivers
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+CONFIG_GNSS=m
+CONFIG_GNSS_SERIAL=m
+CONFIG_GNSS_MTK_SERIAL=m
+CONFIG_GNSS_SIRF_SERIAL=m
+CONFIG_GNSS_UBX_SERIAL=m
+# CONFIG_GNSS_USB is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+
+#
+# Partition parsers
+#
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+
+#
+# Note that in some cases UBI block is preferred. See MTD_UBI_BLOCK.
+#
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=y
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_PHYSMAP_VERSATILE=y
+CONFIG_MTD_PHYSMAP_GEMINI=y
+CONFIG_MTD_PHYSMAP_IXP4XX=y
+CONFIG_MTD_PHYSMAP_GPIO_ADDR=y
+# CONFIG_MTD_IMPA7 is not set
+CONFIG_MTD_PLATRAM=y
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_MCHP23K256 is not set
+# CONFIG_MTD_MCHP48L640 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+#
+# NAND
+#
+CONFIG_MTD_NAND_CORE=y
+# CONFIG_MTD_ONENAND is not set
+CONFIG_MTD_RAW_NAND=y
+
+#
+# Raw/parallel NAND flash controllers
+#
+# CONFIG_MTD_NAND_DENALI_DT is not set
+# CONFIG_MTD_NAND_BRCMNAND is not set
+CONFIG_MTD_NAND_HISI504=y
+# CONFIG_MTD_NAND_MXIC is not set
+# CONFIG_MTD_NAND_GPIO is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_NAND_CADENCE is not set
+# CONFIG_MTD_NAND_ARASAN is not set
+# CONFIG_MTD_NAND_INTEL_LGM is not set
+CONFIG_MTD_NAND_PL35X=y
+
+#
+# Misc
+#
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_SPI_NAND is not set
+
+#
+# ECC engine support
+#
+CONFIG_MTD_NAND_ECC=y
+CONFIG_MTD_NAND_ECC_SW_HAMMING=y
+# CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC is not set
+# CONFIG_MTD_NAND_ECC_SW_BCH is not set
+# CONFIG_MTD_NAND_ECC_MXIC is not set
+# end of ECC engine support
+# end of NAND
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_MTD_SPI_NOR_SWP_DISABLE is not set
+CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE=y
+# CONFIG_MTD_SPI_NOR_SWP_KEEP is not set
+CONFIG_SPI_HISI_SFC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_MTD_UBI_NVMEM is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+CONFIG_OF_RESOLVE=y
+CONFIG_OF_OVERLAY=y
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+CONFIG_ZRAM=m
+# CONFIG_ZRAM_BACKEND_LZ4 is not set
+# CONFIG_ZRAM_BACKEND_LZ4HC is not set
+# CONFIG_ZRAM_BACKEND_ZSTD is not set
+CONFIG_ZRAM_BACKEND_DEFLATE=y
+# CONFIG_ZRAM_BACKEND_842 is not set
+# CONFIG_ZRAM_BACKEND_LZO is not set
+CONFIG_ZRAM_DEF_COMP_DEFLATE=y
+CONFIG_ZRAM_DEF_COMP="deflate"
+# CONFIG_ZRAM_WRITEBACK is not set
+# CONFIG_ZRAM_TRACK_ENTRY_ACTIME is not set
+# CONFIG_ZRAM_MEMORY_TRACKING is not set
+# CONFIG_ZRAM_MULTI_COMP is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=0
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_VIRTIO_BLK is not set
+# CONFIG_BLK_DEV_RBD is not set
+CONFIG_BLK_DEV_UBLK=m
+CONFIG_BLKDEV_UBLK_LEGACY_OPCODES=y
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TCP is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_RPMB is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_OPEN_DICE is not set
+# CONFIG_VCPU_STALL_DETECTOR is not set
+# CONFIG_NSM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+# CONFIG_PVPANIC is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI_COMMON=y
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+# CONFIG_SCSI_SAS_ATA is not set
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SRP_ATTRS=m
+# end of SCSI Transports
+
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
+CONFIG_ATA=y
+CONFIG_SATA_HOST=y
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_FORCE=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_DWC=y
+# CONFIG_AHCI_CEVA is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_SATA_DWC is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_OF_PLATFORM is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_WIREGUARD is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_BAREUDP is not set
+# CONFIG_GTP is not set
+# CONFIG_PFCP is not set
+# CONFIG_AMT is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+CONFIG_TUN=m
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_NLMON is not set
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ASIX is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_DAVICOM is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_FUNGIBLE is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+CONFIG_HISI_FEMAC=y
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_ADI is not set
+# CONFIG_NET_VENDOR_LITEX is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_META is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_ETHOC is not set
+# CONFIG_OA_TC6 is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WANGXUN is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+CONFIG_PHYLIB_LEDS=y
+CONFIG_FIXED_PHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AIR_EN8811H_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_ADIN1100_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+CONFIG_BROADCOM_PHY=m
+# CONFIG_BCM54140_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM84881_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+CONFIG_BCM_NET_PHYLIB=m
+CONFIG_BCM_NET_PHYPTP=m
+CONFIG_CICADA_PHY=m
+# CONFIG_CORTINA_PHY is not set
+CONFIG_DAVICOM_PHY=m
+CONFIG_ICPLUS_PHY=y
+CONFIG_LXT_PHY=m
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+CONFIG_MARVELL_PHY=m
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MARVELL_88Q2XXX_PHY is not set
+# CONFIG_MARVELL_88X2222_PHY is not set
+# CONFIG_MAXLINEAR_GPHY is not set
+# CONFIG_MEDIATEK_GE_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_T1S_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_MOTORCOMM_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NXP_CBTX_PHY is not set
+# CONFIG_NXP_C45_TJA11XX_PHY is not set
+# CONFIG_NXP_TJA11XX_PHY is not set
+# CONFIG_NCN26000_PHY is not set
+# CONFIG_QCA83XX_PHY is not set
+# CONFIG_QCA808X_PHY is not set
+# CONFIG_QCA807X_PHY is not set
+CONFIG_QSEMI_PHY=m
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+CONFIG_SMSC_PHY=m
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_DP83869_PHY is not set
+# CONFIG_DP83TD510_PHY is not set
+# CONFIG_DP83TG720_PHY is not set
+CONFIG_VITESSE_PHY=m
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+CONFIG_FWNODE_MDIO=y
+CONFIG_OF_MDIO=y
+CONFIG_MDIO_DEVRES=y
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+CONFIG_MDIO_HISI_FEMAC=y
+# CONFIG_MDIO_MVUSB is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_IPQ4019 is not set
+# CONFIG_MDIO_IPQ8064 is not set
+
+#
+# MDIO Multiplexers
+#
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+
+#
+# PCS device drivers
+#
+# CONFIG_PCS_XPCS is not set
+# end of PCS device drivers
+
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=m
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+# CONFIG_WAN is not set
+
+#
+# Wireless WAN
+#
+# CONFIG_WWAN is not set
+# end of Wireless WAN
+
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+CONFIG_INPUT_VIVALDIFMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1050 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+# CONFIG_KEYBOARD_CYPRESS_SF is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_BYD=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+CONFIG_MOUSE_PS2_SMBUS=y
+CONFIG_MOUSE_SERIAL=m
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+# CONFIG_JOYSTICK_PSXPAD_SPI is not set
+# CONFIG_JOYSTICK_PXRC is not set
+# CONFIG_JOYSTICK_QWIIC is not set
+# CONFIG_JOYSTICK_FSIA6B is not set
+# CONFIG_JOYSTICK_SENSEHAT is not set
+# CONFIG_JOYSTICK_SEESAW is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_PEGASUS is not set
+# CONFIG_TABLET_SERIAL_WACOM4 is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMA140 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP5 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_GOODIX_BERLIN_I2C is not set
+# CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI is not set
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_HYCON_HY46XX is not set
+# CONFIG_TOUCHSCREEN_HYNITRON_CSTXXX is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_ILITEK is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MSG2638 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_NOVATEK_NVT_TS is not set
+# CONFIG_TOUCHSCREEN_IMAGIS is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+# CONFIG_TOUCHSCREEN_IQS5XX is not set
+# CONFIG_TOUCHSCREEN_IQS7211 is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+# CONFIG_TOUCHSCREEN_HIMAX_HX83112B is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_DA7280_HAPTICS is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_IQS269A is not set
+# CONFIG_INPUT_IQS626A is not set
+# CONFIG_INPUT_IQS7222 is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_INPUT_HISI_POWERKEY is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+CONFIG_GAMEPORT=m
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_LEGACY_TIOCSTI=y
+CONFIG_LDISC_AUTOLOAD=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_EARLYCON_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_CONSOLE_POLL=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_SPRD is not set
+# end of Serial drivers
+
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_NULL_TTY is not set
+# CONFIG_HVC_DCC is not set
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVPORT=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# CONFIG_XILLYUSB is not set
+# end of Character devices
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_HIX5HD2 is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+CONFIG_I2C_DESIGNWARE_CORE=y
+# CONFIG_I2C_DESIGNWARE_SLAVE is not set
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_CP2615 is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_VIRTIO is not set
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_SPI_CH341 is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_MICROCHIP_CORE is not set
+# CONFIG_SPI_MICROCHIP_CORE_QSPI is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_SN_F_OSPI is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+# CONFIG_SPI_AMD is not set
+
+#
+# SPI Multiplexer support
+#
+# CONFIG_SPI_MUX is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+CONFIG_SPI_DYNAMIC=y
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_PTP_1588_CLOCK_OPTIONAL=y
+# CONFIG_DP83640_PHY is not set
+# CONFIG_PTP_1588_CLOCK_INES is not set
+# CONFIG_PTP_1588_CLOCK_IDT82P33 is not set
+# CONFIG_PTP_1588_CLOCK_IDTCM is not set
+# CONFIG_PTP_1588_CLOCK_FC3W is not set
+# CONFIG_PTP_1588_CLOCK_MOCK is not set
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_PINMUX=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AW9523 is not set
+# CONFIG_PINCTRL_CY8C95X0 is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_MICROCHIP_SGPIO is not set
+# CONFIG_PINCTRL_OCELOT is not set
+# CONFIG_PINCTRL_SCMI is not set
+CONFIG_PINCTRL_SINGLE=y
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_IMX_SCMI is not set
+
+#
+# Renesas pinctrl drivers
+#
+# end of Renesas pinctrl drivers
+
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+CONFIG_GPIO_CDEV=y
+CONFIG_GPIO_CDEV_V1=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_LOGICVC is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MPC8XXX is not set
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_SIFIVE is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_FXL6408 is not set
+# CONFIG_GPIO_DS4520 is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCA9570 is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# end of MFD GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+#
+# USB GPIO expanders
+#
+# end of USB GPIO expanders
+
+#
+# Virtual GPIO drivers
+#
+# CONFIG_GPIO_AGGREGATOR is not set
+# CONFIG_GPIO_LATCH is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_VIRTIO is not set
+# CONFIG_GPIO_SIM is not set
+# end of Virtual GPIO drivers
+
+#
+# GPIO Debugging utilities
+#
+# CONFIG_GPIO_VIRTUSER is not set
+# end of GPIO Debugging utilities
+
+# CONFIG_W1 is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+CONFIG_POWER_RESET_HISI=y
+# CONFIG_POWER_RESET_LTC2952 is not set
+CONFIG_POWER_RESET_RESTART=y
+# CONFIG_POWER_RESET_VERSATILE is not set
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_REBOOT_MODE=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_NVMEM_REBOOT_MODE=y
+# CONFIG_POWER_SEQUENCING is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_IP5XXX_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_CW2015 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SAMSUNG_SDI is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_MAX1720X is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_LTC4162L is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_MAX77976 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ2515X is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_BQ25980 is not set
+# CONFIG_CHARGER_BQ256XX is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_BATTERY_RT5033 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_BD99954 is not set
+# CONFIG_BATTERY_UG3105 is not set
+# CONFIG_FUEL_GAUGE_MM8013 is not set
+CONFIG_HWMON=m
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM1177 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AHT10 is not set
+# CONFIG_SENSORS_AQUACOMPUTER_D5NEXT is not set
+# CONFIG_SENSORS_AS370 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ASUS_ROG_RYUJIN is not set
+# CONFIG_SENSORS_AXI_FAN_CONTROL is not set
+# CONFIG_SENSORS_ARM_SCMI is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_CHIPCAP2 is not set
+# CONFIG_SENSORS_CORSAIR_CPRO is not set
+# CONFIG_SENSORS_CORSAIR_PSU is not set
+# CONFIG_SENSORS_DRIVETEMP is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FTSTEUTATES is not set
+# CONFIG_SENSORS_GIGABYTE_WATERFORCE is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_HS3001 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWERZ is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC2947_I2C is not set
+# CONFIG_SENSORS_LTC2947_SPI is not set
+# CONFIG_SENSORS_LTC2990 is not set
+# CONFIG_SENSORS_LTC2991 is not set
+# CONFIG_SENSORS_LTC2992 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LTC4282 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX127 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX31722 is not set
+# CONFIG_SENSORS_MAX31730 is not set
+# CONFIG_SENSORS_MAX31760 is not set
+# CONFIG_MAX31827 is not set
+# CONFIG_SENSORS_MAX6620 is not set
+# CONFIG_SENSORS_MAX6621 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MC34VR500 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_TC654 is not set
+# CONFIG_SENSORS_TPS23861 is not set
+# CONFIG_SENSORS_MR75203 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775_I2C is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_NPCM7XX is not set
+# CONFIG_SENSORS_NZXT_KRAKEN2 is not set
+# CONFIG_SENSORS_NZXT_KRAKEN3 is not set
+# CONFIG_SENSORS_NZXT_SMART2 is not set
+# CONFIG_SENSORS_OCC_P8_I2C is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_PT5161L is not set
+# CONFIG_SENSORS_SBTSI is not set
+# CONFIG_SENSORS_SBRMI is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHT3x is not set
+# CONFIG_SENSORS_SHT4x is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC2305 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_STTS751 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_INA238 is not set
+# CONFIG_SENSORS_INA3221 is not set
+# CONFIG_SENSORS_SPD5118 is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP108 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_TMP464 is not set
+# CONFIG_SENSORS_TMP513 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83773G is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_NETLINK is not set
+# CONFIG_THERMAL_STATISTICS is not set
+# CONFIG_THERMAL_DEBUGFS is not set
+# CONFIG_THERMAL_CORE_TESTING is not set
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_DEVFREQ_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_THERMAL_MMIO is not set
+CONFIG_HISI_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
+CONFIG_WATCHDOG_OPEN_TIMEOUT=0
+# CONFIG_WATCHDOG_SYSFS is not set
+# CONFIG_WATCHDOG_HRTIMER_PRETIMEOUT is not set
+
+#
+# Watchdog Pretimeout Governors
+#
+CONFIG_WATCHDOG_PRETIMEOUT_GOV=y
+CONFIG_WATCHDOG_PRETIMEOUT_GOV_SEL=m
+CONFIG_WATCHDOG_PRETIMEOUT_GOV_NOOP=y
+CONFIG_WATCHDOG_PRETIMEOUT_GOV_PANIC=y
+# CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP is not set
+CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_PANIC=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_ZIIRAVE_WATCHDOG is not set
+CONFIG_ARM_SP805_WATCHDOG=y
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_FTWDT010_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_ADP5585 is not set
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_SMPRO is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CS42L43_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_MAX5970 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_GATEWORKS_GSC is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MP2629 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_MFD_HI655X_PMIC is not set
+# CONFIG_MFD_IQS62X is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM886_PMIC is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77541 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77714 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6360 is not set
+# CONFIG_MFD_MT6370 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_OCELOT is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_NTXEC is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SY7636A is not set
+# CONFIG_MFD_RT4831 is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RT5120 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK8XX_I2C is not set
+# CONFIG_MFD_RK8XX_SPI is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS65219 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS6594_I2C is not set
+# CONFIG_MFD_TPS6594_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD71828 is not set
+# CONFIG_MFD_ROHM_BD957XMUF is not set
+# CONFIG_MFD_ROHM_BD96801 is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# CONFIG_MFD_ATC260X_I2C is not set
+# CONFIG_MFD_QCOM_PM8008 is not set
+# CONFIG_MFD_CS40L50_I2C is not set
+# CONFIG_MFD_CS40L50_SPI is not set
+# CONFIG_RAVE_SP_CORE is not set
+# CONFIG_MFD_INTEL_M10_BMC_SPI is not set
+# CONFIG_MFD_RSMU_I2C is not set
+# CONFIG_MFD_RSMU_SPI is not set
+CONFIG_MFD_HI3515_SYSCON=y
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+CONFIG_RC_CORE=m
+# CONFIG_LIRC is not set
+CONFIG_RC_MAP=m
+# CONFIG_RC_DECODERS is not set
+CONFIG_RC_DEVICES=y
+# CONFIG_IR_GPIO_CIR is not set
+CONFIG_IR_HIX5HD2=m
+# CONFIG_IR_IGORPLUGUSB is not set
+# CONFIG_IR_IGUANA is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_IMON_RAW is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_SERIAL is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_IR_TOY is not set
+# CONFIG_IR_TTUSBIR is not set
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_RC_XBOX_DVD is not set
+
+#
+# CEC support
+#
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# end of CEC support
+
+CONFIG_MEDIA_SUPPORT=m
+# CONFIG_MEDIA_SUPPORT_FILTER is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# Media device types
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_SDR_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_TEST_SUPPORT=y
+# end of Media device types
+
+#
+# Media core support
+#
+CONFIG_VIDEO_DEV=m
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_DVB_CORE=m
+# end of Media core support
+
+#
+# Video4Linux options
+#
+CONFIG_VIDEO_V4L2_I2C=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_V4L2_FWNODE=m
+CONFIG_V4L2_ASYNC=m
+# end of Video4Linux options
+
+#
+# Media controller options
+#
+# CONFIG_MEDIA_CONTROLLER_DVB is not set
+# end of Media controller options
+
+#
+# Digital TV options
+#
+# CONFIG_DVB_MMAP is not set
+CONFIG_DVB_NET=y
+CONFIG_DVB_MAX_ADAPTERS=16
+CONFIG_DVB_DYNAMIC_MINORS=y
+# CONFIG_DVB_DEMUX_SECTION_LOSS_LOG is not set
+# CONFIG_DVB_ULE_DEBUG is not set
+# end of Digital TV options
+
+#
+# Media drivers
+#
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+CONFIG_RADIO_ADAPTERS=m
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_SHARK is not set
+# CONFIG_RADIO_SHARK2 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_KEENE is not set
+# CONFIG_USB_MA901 is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_RAREMONO is not set
+# CONFIG_RADIO_SI470X is not set
+CONFIG_MEDIA_PLATFORM_DRIVERS=y
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_SDR_PLATFORM_DRIVERS is not set
+# CONFIG_DVB_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+
+#
+# Allegro DVT media platform drivers
+#
+
+#
+# Amlogic media platform drivers
+#
+
+#
+# Amphion drivers
+#
+
+#
+# Aspeed media platform drivers
+#
+
+#
+# Atmel media platform drivers
+#
+
+#
+# Cadence media platform drivers
+#
+# CONFIG_VIDEO_CADENCE_CSI2RX is not set
+# CONFIG_VIDEO_CADENCE_CSI2TX is not set
+
+#
+# Chips&Media media platform drivers
+#
+
+#
+# Intel media platform drivers
+#
+
+#
+# Marvell media platform drivers
+#
+
+#
+# Mediatek media platform drivers
+#
+
+#
+# Microchip Technology, Inc. media platform drivers
+#
+
+#
+# Nuvoton media platform drivers
+#
+
+#
+# NVidia media platform drivers
+#
+
+#
+# NXP media platform drivers
+#
+
+#
+# Qualcomm media platform drivers
+#
+
+#
+# Raspberry Pi media platform drivers
+#
+
+#
+# Renesas media platform drivers
+#
+
+#
+# Rockchip media platform drivers
+#
+
+#
+# Samsung media platform drivers
+#
+
+#
+# STMicroelectronics media platform drivers
+#
+
+#
+# Sunxi media platform drivers
+#
+
+#
+# Texas Instruments drivers
+#
+
+#
+# Verisilicon media platform drivers
+#
+
+#
+# VIA media platform drivers
+#
+
+#
+# Xilinx media platform drivers
+#
+
+#
+# MMC/SDIO DVB adapters
+#
+# CONFIG_SMS_SDIO_DRV is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+# CONFIG_DVB_TEST_DRIVERS is not set
+# end of Media drivers
+
+#
+# Media ancillary drivers
+#
+CONFIG_MEDIA_ATTACH=y
+CONFIG_VIDEO_IR_I2C=m
+CONFIG_VIDEO_CAMERA_SENSOR=y
+# CONFIG_VIDEO_ALVIUM_CSI2 is not set
+# CONFIG_VIDEO_AR0521 is not set
+# CONFIG_VIDEO_GC0308 is not set
+# CONFIG_VIDEO_GC05A2 is not set
+# CONFIG_VIDEO_GC08A3 is not set
+# CONFIG_VIDEO_GC2145 is not set
+# CONFIG_VIDEO_HI556 is not set
+# CONFIG_VIDEO_HI846 is not set
+# CONFIG_VIDEO_HI847 is not set
+# CONFIG_VIDEO_IMX208 is not set
+# CONFIG_VIDEO_IMX214 is not set
+# CONFIG_VIDEO_IMX219 is not set
+# CONFIG_VIDEO_IMX258 is not set
+# CONFIG_VIDEO_IMX274 is not set
+# CONFIG_VIDEO_IMX283 is not set
+# CONFIG_VIDEO_IMX290 is not set
+# CONFIG_VIDEO_IMX296 is not set
+# CONFIG_VIDEO_IMX319 is not set
+# CONFIG_VIDEO_IMX334 is not set
+# CONFIG_VIDEO_IMX335 is not set
+# CONFIG_VIDEO_IMX355 is not set
+# CONFIG_VIDEO_IMX412 is not set
+# CONFIG_VIDEO_IMX415 is not set
+# CONFIG_VIDEO_MT9M001 is not set
+# CONFIG_VIDEO_MT9M111 is not set
+# CONFIG_VIDEO_MT9M114 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T112 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_MT9V111 is not set
+# CONFIG_VIDEO_OG01A1B is not set
+# CONFIG_VIDEO_OV01A10 is not set
+# CONFIG_VIDEO_OV02A10 is not set
+# CONFIG_VIDEO_OV08D10 is not set
+# CONFIG_VIDEO_OV08X40 is not set
+# CONFIG_VIDEO_OV13858 is not set
+# CONFIG_VIDEO_OV13B10 is not set
+# CONFIG_VIDEO_OV2640 is not set
+# CONFIG_VIDEO_OV2659 is not set
+# CONFIG_VIDEO_OV2680 is not set
+# CONFIG_VIDEO_OV2685 is not set
+# CONFIG_VIDEO_OV4689 is not set
+# CONFIG_VIDEO_OV5640 is not set
+# CONFIG_VIDEO_OV5645 is not set
+# CONFIG_VIDEO_OV5647 is not set
+# CONFIG_VIDEO_OV5648 is not set
+# CONFIG_VIDEO_OV5670 is not set
+# CONFIG_VIDEO_OV5675 is not set
+# CONFIG_VIDEO_OV5693 is not set
+# CONFIG_VIDEO_OV5695 is not set
+# CONFIG_VIDEO_OV64A40 is not set
+# CONFIG_VIDEO_OV6650 is not set
+# CONFIG_VIDEO_OV7251 is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_OV772X is not set
+# CONFIG_VIDEO_OV7740 is not set
+# CONFIG_VIDEO_OV8856 is not set
+# CONFIG_VIDEO_OV8858 is not set
+# CONFIG_VIDEO_OV8865 is not set
+# CONFIG_VIDEO_OV9282 is not set
+# CONFIG_VIDEO_OV9640 is not set
+# CONFIG_VIDEO_OV9650 is not set
+# CONFIG_VIDEO_RDACM20 is not set
+# CONFIG_VIDEO_RDACM21 is not set
+# CONFIG_VIDEO_RJ54N1 is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# CONFIG_VIDEO_S5K5BAF is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+# CONFIG_VIDEO_VGXY61 is not set
+# CONFIG_VIDEO_CCS is not set
+# CONFIG_VIDEO_ET8EK8 is not set
+
+#
+# Camera ISPs
+#
+# CONFIG_VIDEO_THP7312 is not set
+# end of Camera ISPs
+
+#
+# Lens drivers
+#
+# CONFIG_VIDEO_AD5820 is not set
+# CONFIG_VIDEO_AK7375 is not set
+# CONFIG_VIDEO_DW9714 is not set
+# CONFIG_VIDEO_DW9719 is not set
+# CONFIG_VIDEO_DW9768 is not set
+# CONFIG_VIDEO_DW9807_VCM is not set
+# end of Lens drivers
+
+#
+# Flash devices
+#
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_LM3560 is not set
+# CONFIG_VIDEO_LM3646 is not set
+# end of Flash devices
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_CS3308 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+# CONFIG_VIDEO_TDA1997X is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# end of Audio decoders, processors and mixers
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+# end of RDS decoders
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV748X is not set
+# CONFIG_VIDEO_ADV7604 is not set
+# CONFIG_VIDEO_ADV7842 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_ISL7998X is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_TC358743 is not set
+# CONFIG_VIDEO_TC358746 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9900 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_TW9910 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# end of Video decoders
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV7511 is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_THS8200 is not set
+# end of Video encoders
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# end of Video improvement chips
+
+#
+# Audio/Video compression chips
+#
+# CONFIG_VIDEO_SAA6752HS is not set
+# end of Audio/Video compression chips
+
+#
+# SDR tuner chips
+#
+# CONFIG_SDR_MAX2175 is not set
+# end of SDR tuner chips
+
+#
+# Miscellaneous helper chips
+#
+# CONFIG_VIDEO_I2C is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_ST_MIPID02 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# end of Miscellaneous helper chips
+
+#
+# Video serializers and deserializers
+#
+# CONFIG_VIDEO_DS90UB913 is not set
+# CONFIG_VIDEO_DS90UB953 is not set
+# CONFIG_VIDEO_DS90UB960 is not set
+# CONFIG_VIDEO_MAX96714 is not set
+# CONFIG_VIDEO_MAX96717 is not set
+# end of Video serializers and deserializers
+
+#
+# Media SPI Adapters
+#
+CONFIG_CXD2880_SPI_DRV=m
+# CONFIG_VIDEO_GS1662 is not set
+# end of Media SPI Adapters
+
+CONFIG_MEDIA_TUNER=m
+
+#
+# Customize TV tuners
+#
+CONFIG_MEDIA_TUNER_E4000=m
+CONFIG_MEDIA_TUNER_FC0011=m
+CONFIG_MEDIA_TUNER_FC0012=m
+CONFIG_MEDIA_TUNER_FC0013=m
+CONFIG_MEDIA_TUNER_FC2580=m
+CONFIG_MEDIA_TUNER_IT913X=m
+CONFIG_MEDIA_TUNER_M88RS6000T=m
+CONFIG_MEDIA_TUNER_MAX2165=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_MEDIA_TUNER_MSI001=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2063=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MXL301RF=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_QM1D1B0004=m
+CONFIG_MEDIA_TUNER_QM1D1C0042=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_R820T=m
+CONFIG_MEDIA_TUNER_SI2157=m
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA18212=m
+CONFIG_MEDIA_TUNER_TDA18218=m
+CONFIG_MEDIA_TUNER_TDA18250=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_TUA9001=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC4000=m
+CONFIG_MEDIA_TUNER_XC5000=m
+# end of Customize TV tuners
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+CONFIG_DVB_MXL5XX=m
+CONFIG_DVB_STB0899=m
+CONFIG_DVB_STB6100=m
+CONFIG_DVB_STV090x=m
+CONFIG_DVB_STV0910=m
+CONFIG_DVB_STV6110x=m
+CONFIG_DVB_STV6111=m
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+CONFIG_DVB_DRXK=m
+CONFIG_DVB_MN88472=m
+CONFIG_DVB_MN88473=m
+CONFIG_DVB_SI2165=m
+CONFIG_DVB_TDA18271C2DD=m
+
+#
+# DVB-S (satellite) frontends
+#
+CONFIG_DVB_CX24110=m
+CONFIG_DVB_CX24116=m
+CONFIG_DVB_CX24117=m
+CONFIG_DVB_CX24120=m
+CONFIG_DVB_CX24123=m
+CONFIG_DVB_DS3000=m
+CONFIG_DVB_MB86A16=m
+CONFIG_DVB_MT312=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_SI21XX=m
+CONFIG_DVB_STB6000=m
+CONFIG_DVB_STV0288=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_STV0900=m
+CONFIG_DVB_STV6110=m
+CONFIG_DVB_TDA10071=m
+CONFIG_DVB_TDA10086=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA8261=m
+CONFIG_DVB_TDA826X=m
+CONFIG_DVB_TS2020=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_DVB_VES1X93=m
+CONFIG_DVB_ZL10036=m
+CONFIG_DVB_ZL10039=m
+
+#
+# DVB-T (terrestrial) frontends
+#
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_CXD2820R=m
+CONFIG_DVB_CXD2841ER=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_DIB9000=m
+CONFIG_DVB_DRXD=m
+CONFIG_DVB_EC100=m
+CONFIG_DVB_L64781=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_NXT6000=m
+CONFIG_DVB_S5H1432=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_STV0367=m
+CONFIG_DVB_TDA10048=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_ZD1301_DEMOD=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_CXD2880=m
+
+#
+# DVB-C (cable) frontends
+#
+CONFIG_DVB_STV0297=m
+CONFIG_DVB_TDA10021=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_VES1820=m
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_AU8522_DTV=m
+CONFIG_DVB_AU8522_V4L=m
+CONFIG_DVB_BCM3510=m
+CONFIG_DVB_LG2160=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_MXL692=m
+CONFIG_DVB_NXT200X=m
+CONFIG_DVB_OR51132=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_S5H1409=m
+CONFIG_DVB_S5H1411=m
+
+#
+# ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_MB86A20S=m
+CONFIG_DVB_S921=m
+
+#
+# ISDB-S (satellite) & ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_MN88443X=m
+CONFIG_DVB_TC90522=m
+
+#
+# Digital terrestrial only tuners/PLL
+#
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_TUNER_DIB0090=m
+
+#
+# SEC control devices for DVB-S
+#
+CONFIG_DVB_A8293=m
+CONFIG_DVB_AF9033=m
+CONFIG_DVB_ASCOT2E=m
+CONFIG_DVB_ATBM8830=m
+CONFIG_DVB_HELENE=m
+CONFIG_DVB_HORUS3A=m
+CONFIG_DVB_ISL6405=m
+CONFIG_DVB_ISL6421=m
+CONFIG_DVB_ISL6423=m
+CONFIG_DVB_IX2505V=m
+CONFIG_DVB_LGS8GL5=m
+CONFIG_DVB_LGS8GXX=m
+CONFIG_DVB_LNBH25=m
+CONFIG_DVB_LNBH29=m
+CONFIG_DVB_LNBP21=m
+CONFIG_DVB_LNBP22=m
+CONFIG_DVB_M88RS2000=m
+CONFIG_DVB_TDA665x=m
+CONFIG_DVB_DRX39XYJ=m
+
+#
+# Common Interface (EN50221) controller drivers
+#
+CONFIG_DVB_CXD2099=m
+CONFIG_DVB_SP2=m
+# end of Customise DVB Frontends
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+# end of Media ancillary drivers
+
+#
+# Graphics support
+#
+CONFIG_VIDEO=y
+# CONFIG_AUXDISPLAY is not set
+CONFIG_DRM=y
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_PANIC is not set
+# CONFIG_DRM_DEBUG_MODESET_LOCK is not set
+# CONFIG_DRM_FBDEV_EMULATION is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+
+#
+# ARM devices
+#
+# CONFIG_DRM_HDLCD is not set
+# CONFIG_DRM_MALI_DISPLAY is not set
+# CONFIG_DRM_KOMEDA is not set
+# end of ARM devices
+
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VKMS is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_ARMADA is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_DRM_FSL_DCU is not set
+CONFIG_DRM_PANEL=y
+
+#
+# Display Panels
+#
+# CONFIG_DRM_PANEL_ABT_Y030XX067A is not set
+# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_AUO_A030JTN01 is not set
+# CONFIG_DRM_PANEL_LVDS is not set
+# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
+# CONFIG_DRM_PANEL_ILITEK_ILI9341 is not set
+# CONFIG_DRM_PANEL_INNOLUX_EJ030NA is not set
+# CONFIG_DRM_PANEL_LG_LB035Q02 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_NEC_NL8048HL11 is not set
+# CONFIG_DRM_PANEL_NEWVISION_NV3052C is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT39016 is not set
+# CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO is not set
+# CONFIG_DRM_PANEL_ORISETECH_OTA5601A is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS452EF01 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_DB7430 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D27A1 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D7AA0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63M0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+# CONFIG_DRM_PANEL_SEIKO_43WVF1G is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7701 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+# CONFIG_DRM_PANEL_SONY_ACX565AKM is not set
+# CONFIG_DRM_PANEL_EDP is not set
+# CONFIG_DRM_PANEL_SIMPLE is not set
+# CONFIG_DRM_PANEL_TPO_TD028TTEC1 is not set
+# CONFIG_DRM_PANEL_TPO_TPG110 is not set
+# CONFIG_DRM_PANEL_WIDECHIPS_WS2401 is not set
+# end of Display Panels
+
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+# CONFIG_DRM_CHIPONE_ICN6211 is not set
+# CONFIG_DRM_CHRONTEL_CH7033 is not set
+# CONFIG_DRM_DISPLAY_CONNECTOR is not set
+# CONFIG_DRM_ITE_IT6505 is not set
+# CONFIG_DRM_LONTIUM_LT8912B is not set
+# CONFIG_DRM_LONTIUM_LT9211 is not set
+# CONFIG_DRM_LONTIUM_LT9611 is not set
+# CONFIG_DRM_LONTIUM_LT9611UXC is not set
+# CONFIG_DRM_ITE_IT66121 is not set
+# CONFIG_DRM_LVDS_CODEC is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+# CONFIG_DRM_NWL_MIPI_DSI is not set
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_PARADE_PS8640 is not set
+# CONFIG_DRM_SAMSUNG_DSIM is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_SII9234 is not set
+# CONFIG_DRM_SIMPLE_BRIDGE is not set
+# CONFIG_DRM_THINE_THC63LVD1024 is not set
+# CONFIG_DRM_TOSHIBA_TC358762 is not set
+# CONFIG_DRM_TOSHIBA_TC358764 is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TOSHIBA_TC358768 is not set
+# CONFIG_DRM_TOSHIBA_TC358775 is not set
+# CONFIG_DRM_TI_DLPC3433 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_TI_SN65DSI83 is not set
+# CONFIG_DRM_TI_SN65DSI86 is not set
+# CONFIG_DRM_TI_TPD12S015 is not set
+# CONFIG_DRM_ANALOGIX_ANX6345 is not set
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+# CONFIG_DRM_ANALOGIX_ANX7625 is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_CDNS_DSI is not set
+# CONFIG_DRM_CDNS_MHDP8546 is not set
+# end of Display Interface Bridges
+
+# CONFIG_DRM_ETNAVIV is not set
+# CONFIG_DRM_LOGICVC is not set
+# CONFIG_DRM_ARCPGU is not set
+# CONFIG_DRM_GM12U320 is not set
+# CONFIG_DRM_PANEL_MIPI_DBI is not set
+# CONFIG_DRM_SIMPLEDRM is not set
+# CONFIG_TINYDRM_HX8357D is not set
+# CONFIG_TINYDRM_ILI9163 is not set
+# CONFIG_TINYDRM_ILI9225 is not set
+# CONFIG_TINYDRM_ILI9341 is not set
+# CONFIG_TINYDRM_ILI9486 is not set
+# CONFIG_TINYDRM_MI0283QT is not set
+# CONFIG_TINYDRM_REPAPER is not set
+# CONFIG_TINYDRM_ST7586 is not set
+# CONFIG_TINYDRM_ST7735R is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_LIMA is not set
+# CONFIG_DRM_TIDSS is not set
+# CONFIG_DRM_GUD is not set
+# CONFIG_DRM_SSD130X is not set
+# CONFIG_DRM_WERROR is not set
+CONFIG_DRM_PANEL_ORIENTATION_QUIRKS=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+CONFIG_FB_CORE=y
+CONFIG_FB_NOTIFY=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_DEVICE=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYSMEM_FOPS=y
+CONFIG_FB_DMAMEM_HELPERS=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_OTM3225A is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=m
+# CONFIG_BACKLIGHT_KTD253 is not set
+# CONFIG_BACKLIGHT_KTD2801 is not set
+# CONFIG_BACKLIGHT_KTZ8866 is not set
+# CONFIG_BACKLIGHT_QCOM_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3509 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# CONFIG_BACKLIGHT_LED is not set
+# end of Backlight & LCD device support
+
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=30
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# end of Console display driver support
+
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# end of Graphics support
+
+CONFIG_DRM_ACCEL=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_DMAENGINE_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_JACK_INPUT_DEV=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_CTL_FAST_LOOKUP=y
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_CTL_INPUT_VALIDATION is not set
+# CONFIG_SND_UTIMER is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_PCMTEST is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_SERIAL_GENERIC is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+# end of HD-Audio
+
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+# CONFIG_SND_SOC_ADI is not set
+# CONFIG_SND_SOC_AMD_ACP is not set
+# CONFIG_SND_AMD_ACP_CONFIG is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_BCM63XX_I2S_WHISTLER is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio for Freescale CPUs
+#
+
+#
+# Common SoC Audio options for Freescale CPUs:
+#
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_AUDMIX is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_FSL_MICFIL is not set
+# CONFIG_SND_SOC_FSL_XCVR is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# end of SoC Audio for Freescale CPUs
+
+# CONFIG_SND_SOC_CHV3_I2S is not set
+# CONFIG_SND_I2S_HI6210_I2S is not set
+# CONFIG_SND_SOC_IMG is not set
+# CONFIG_SND_SOC_MTK_BTCVSD is not set
+# CONFIG_SND_SOC_SOF_TOPLEVEL is not set
+
+#
+# STMicroelectronics STM32 SOC audio support
+#
+# end of STMicroelectronics STM32 SOC audio support
+
+# CONFIG_SND_SOC_XILINX_I2S is not set
+# CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER is not set
+# CONFIG_SND_SOC_XILINX_SPDIF is not set
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1372_I2C is not set
+# CONFIG_SND_SOC_ADAU1372_SPI is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_ADAU1761_I2C is not set
+# CONFIG_SND_SOC_ADAU1761_SPI is not set
+# CONFIG_SND_SOC_ADAU7002 is not set
+# CONFIG_SND_SOC_ADAU7118_HW is not set
+# CONFIG_SND_SOC_ADAU7118_I2C is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4118 is not set
+# CONFIG_SND_SOC_AK4375 is not set
+# CONFIG_SND_SOC_AK4458 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4619 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_AK5558 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_AW8738 is not set
+# CONFIG_SND_SOC_AW88395 is not set
+# CONFIG_SND_SOC_AW88261 is not set
+# CONFIG_SND_SOC_AW87390 is not set
+# CONFIG_SND_SOC_AW88399 is not set
+# CONFIG_SND_SOC_BD28623 is not set
+# CONFIG_SND_SOC_BT_SCO is not set
+# CONFIG_SND_SOC_CHV3_CODEC is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS35L33 is not set
+# CONFIG_SND_SOC_CS35L34 is not set
+# CONFIG_SND_SOC_CS35L35 is not set
+# CONFIG_SND_SOC_CS35L36 is not set
+# CONFIG_SND_SOC_CS35L41_SPI is not set
+# CONFIG_SND_SOC_CS35L41_I2C is not set
+# CONFIG_SND_SOC_CS35L45_SPI is not set
+# CONFIG_SND_SOC_CS35L45_I2C is not set
+# CONFIG_SND_SOC_CS35L56_I2C is not set
+# CONFIG_SND_SOC_CS35L56_SPI is not set
+# CONFIG_SND_SOC_CS42L42 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS42L83 is not set
+# CONFIG_SND_SOC_CS4234 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS43130 is not set
+# CONFIG_SND_SOC_CS4341 is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_CS53L30 is not set
+# CONFIG_SND_SOC_CS530X_I2C is not set
+# CONFIG_SND_SOC_CX2072X is not set
+# CONFIG_SND_SOC_DA7213 is not set
+# CONFIG_SND_SOC_DMIC is not set
+# CONFIG_SND_SOC_ES7134 is not set
+# CONFIG_SND_SOC_ES7241 is not set
+# CONFIG_SND_SOC_ES8311 is not set
+# CONFIG_SND_SOC_ES8316 is not set
+# CONFIG_SND_SOC_ES8326 is not set
+# CONFIG_SND_SOC_ES8328_I2C is not set
+# CONFIG_SND_SOC_ES8328_SPI is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_HDA is not set
+# CONFIG_SND_SOC_ICS43432 is not set
+# CONFIG_SND_SOC_IDT821034 is not set
+# CONFIG_SND_SOC_MAX98088 is not set
+# CONFIG_SND_SOC_MAX98090 is not set
+# CONFIG_SND_SOC_MAX98357A is not set
+# CONFIG_SND_SOC_MAX98504 is not set
+# CONFIG_SND_SOC_MAX9867 is not set
+# CONFIG_SND_SOC_MAX98927 is not set
+# CONFIG_SND_SOC_MAX98520 is not set
+# CONFIG_SND_SOC_MAX98373_I2C is not set
+# CONFIG_SND_SOC_MAX98388 is not set
+# CONFIG_SND_SOC_MAX98390 is not set
+# CONFIG_SND_SOC_MAX98396 is not set
+# CONFIG_SND_SOC_MAX9860 is not set
+# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1789_I2C is not set
+# CONFIG_SND_SOC_PCM179X_I2C is not set
+# CONFIG_SND_SOC_PCM179X_SPI is not set
+# CONFIG_SND_SOC_PCM186X_I2C is not set
+# CONFIG_SND_SOC_PCM186X_SPI is not set
+# CONFIG_SND_SOC_PCM3060_I2C is not set
+# CONFIG_SND_SOC_PCM3060_SPI is not set
+# CONFIG_SND_SOC_PCM3168A_I2C is not set
+# CONFIG_SND_SOC_PCM3168A_SPI is not set
+# CONFIG_SND_SOC_PCM5102A is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_PCM6240 is not set
+# CONFIG_SND_SOC_PEB2466 is not set
+# CONFIG_SND_SOC_RT5616 is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_RT5640 is not set
+# CONFIG_SND_SOC_RT5659 is not set
+# CONFIG_SND_SOC_RT9120 is not set
+# CONFIG_SND_SOC_RTQ9128 is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIMPLE_AMPLIFIER is not set
+# CONFIG_SND_SOC_SIMPLE_MUX is not set
+# CONFIG_SND_SOC_SMA1303 is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SRC4XXX_I2C is not set
+# CONFIG_SND_SOC_SSM2305 is not set
+# CONFIG_SND_SOC_SSM2518 is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM3515 is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS2562 is not set
+# CONFIG_SND_SOC_TAS2764 is not set
+# CONFIG_SND_SOC_TAS2770 is not set
+# CONFIG_SND_SOC_TAS2780 is not set
+# CONFIG_SND_SOC_TAS2781_I2C is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TAS5720 is not set
+# CONFIG_SND_SOC_TAS5805M is not set
+# CONFIG_SND_SOC_TAS6424 is not set
+# CONFIG_SND_SOC_TDA7419 is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TFA989X is not set
+# CONFIG_SND_SOC_TLV320ADC3XXX is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC3X_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC3X_SPI is not set
+# CONFIG_SND_SOC_TLV320ADCX140 is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_TSCS42XX is not set
+# CONFIG_SND_SOC_TSCS454 is not set
+CONFIG_SND_SOC_TW2868=y
+# CONFIG_SND_SOC_UDA1334 is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8524 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731_I2C is not set
+# CONFIG_SND_SOC_WM8731_SPI is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8782 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8904 is not set
+# CONFIG_SND_SOC_WM8940 is not set
+# CONFIG_SND_SOC_WM8960 is not set
+# CONFIG_SND_SOC_WM8961 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8974 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_WM8985 is not set
+# CONFIG_SND_SOC_ZL38060 is not set
+# CONFIG_SND_SOC_MAX9759 is not set
+# CONFIG_SND_SOC_MT6351 is not set
+# CONFIG_SND_SOC_MT6357 is not set
+# CONFIG_SND_SOC_MT6358 is not set
+# CONFIG_SND_SOC_MT6660 is not set
+# CONFIG_SND_SOC_NAU8315 is not set
+# CONFIG_SND_SOC_NAU8540 is not set
+# CONFIG_SND_SOC_NAU8810 is not set
+# CONFIG_SND_SOC_NAU8821 is not set
+# CONFIG_SND_SOC_NAU8822 is not set
+# CONFIG_SND_SOC_NAU8824 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# CONFIG_SND_SOC_LPASS_WSA_MACRO is not set
+# CONFIG_SND_SOC_LPASS_VA_MACRO is not set
+# CONFIG_SND_SOC_LPASS_RX_MACRO is not set
+# CONFIG_SND_SOC_LPASS_TX_MACRO is not set
+# end of CODEC drivers
+
+CONFIG_SND_SIMPLE_CARD_UTILS=y
+CONFIG_SND_SIMPLE_CARD=y
+# CONFIG_SND_AUDIO_GRAPH_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_CARD2 is not set
+# CONFIG_SND_TEST_COMPONENT is not set
+# CONFIG_SND_VIRTIO is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_BIGBEN_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CREATIVE_SB0540 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELAN is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EVISION is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GLORIOUS is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_GOODIX_SPI is not set
+# CONFIG_HID_GOOGLE_STADIA_FF is not set
+# CONFIG_HID_VIVALDI is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_VRC2 is not set
+# CONFIG_HID_XIAOMI is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LETSKETCH is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MEGAWORLD_FF is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NINTENDO is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PXRC is not set
+# CONFIG_HID_RAZER is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SEMITEK is not set
+# CONFIG_HID_SIGMAMICRO is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_TOPRE is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_WINWING is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# CONFIG_HID_MCP2200 is not set
+# CONFIG_HID_MCP2221 is not set
+# end of Special HID drivers
+
+#
+# HID-BPF support
+#
+# end of HID-BPF support
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+# end of USB HID support
+
+CONFIG_I2C_HID=y
+# CONFIG_I2C_HID_OF is not set
+# CONFIG_I2C_HID_OF_ELAN is not set
+# CONFIG_I2C_HID_OF_GOODIX is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_CONN_GPIO is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_FEW_INIT_RETRIES is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_PRODUCTLIST is not set
+# CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB is not set
+CONFIG_USB_AUTOSUSPEND_DELAY=2
+CONFIG_USB_DEFAULT_AUTHORIZATION_MODE=1
+# CONFIG_USB_MON is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_FSL is not set
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+
+#
+# USB dual-mode controller drivers
+#
+# CONFIG_USB_CDNS_SUPPORT is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_SIMPLE is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_F8153X is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_UPD78F0730 is not set
+# CONFIG_USB_SERIAL_XR is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_APPLE_MFI_FASTCHARGE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_ONBOARD_DEV is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+# end of USB Physical Layer drivers
+
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_MAX3420_UDC is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# end of USB Peripheral Controller
+
+# CONFIG_USB_CONFIGFS is not set
+
+#
+# USB Gadget precomposed configurations
+#
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_RAW_GADGET is not set
+# end of USB Gadget precomposed configurations
+
+# CONFIG_TYPEC is not set
+# CONFIG_USB_ROLE_SWITCH is not set
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_STM32_SDMMC is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_PLTFM=y
+# CONFIG_MMC_DW_BLUEFIELD is not set
+# CONFIG_MMC_DW_EXYNOS is not set
+# CONFIG_MMC_DW_HI3798CV200 is not set
+# CONFIG_MMC_DW_HI3798MV200 is not set
+# CONFIG_MMC_DW_K3 is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_HSQ is not set
+# CONFIG_MMC_MTK is not set
+CONFIG_SCSI_UFSHCD=m
+# CONFIG_SCSI_UFS_BSG is not set
+# CONFIG_SCSI_UFS_HWMON is not set
+# CONFIG_SCSI_UFSHCD_PLATFORM is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_CLASS_MULTICOLOR is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_AW200XX is not set
+# CONFIG_LEDS_AW2013 is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_EL15203000 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_PCA995X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2606MVV is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_LM3697 is not set
+
+#
+# Flash and Torch LED drivers
+#
+
+#
+# RGB LED drivers
+#
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# Simple LED drivers
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+CONFIG_RTC_DEBUG=y
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_MAX31335 is not set
+# CONFIG_RTC_DRV_NCT3018Y is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8111 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV3032 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_SD2405AL is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+CONFIG_RTC_DRV_PL031=y
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_GOLDFISH is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+CONFIG_AMBA_PL08X=y
+# CONFIG_DW_AXI_DMAC is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_FSL_QDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_K3_DMA is not set
+# CONFIG_NBPFAXI_DMA is not set
+# CONFIG_PL330_DMA is not set
+# CONFIG_XILINX_DMA is not set
+# CONFIG_XILINX_XDMA is not set
+# CONFIG_XILINX_ZYNQMP_DPDMA is not set
+# CONFIG_AMD_QDMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_SF_PDMA is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+CONFIG_DMATEST=y
+CONFIG_DMA_ENGINE_RAID=y
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_UDMABUF is not set
+# CONFIG_DMABUF_MOVE_NOTIFY is not set
+# CONFIG_DMABUF_DEBUG is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+# CONFIG_DMABUF_HEAPS is not set
+# CONFIG_DMABUF_SYSFS_STATS is not set
+# end of DMABUF options
+
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO_ANCHOR=y
+CONFIG_VIRTIO=m
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VDPA is not set
+# CONFIG_VHOST_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_COMEDI is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_CZNIC_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Clock driver for ARM Reference designs
+#
+CONFIG_CLK_ICST=y
+# CONFIG_CLK_SP810 is not set
+# end of Clock driver for ARM Reference designs
+
+# CONFIG_LMK04832 is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SCMI is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_COMMON_CLK_AXI_CLKGEN is not set
+# CONFIG_COMMON_CLK_RS9_PCIE is not set
+# CONFIG_COMMON_CLK_SI521XX is not set
+# CONFIG_COMMON_CLK_VC3 is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_VC7 is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# CONFIG_COMMON_CLK_HI3516CV300 is not set
+# CONFIG_COMMON_CLK_HI3519 is not set
+# CONFIG_COMMON_CLK_HI3559A is not set
+# CONFIG_COMMON_CLK_HI3660 is not set
+# CONFIG_COMMON_CLK_HI3670 is not set
+# CONFIG_COMMON_CLK_HI3798CV200 is not set
+# CONFIG_COMMON_CLK_HI6220 is not set
+# CONFIG_RESET_HISI is not set
+# CONFIG_XILINX_VCU is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_TIMER_SP804=y
+# CONFIG_MICROCHIP_PIT64B is not set
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# CONFIG_QUICC_ENGINE is not set
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# fujitsu SoC drivers
+#
+# end of fujitsu SoC drivers
+
+#
+# Hisilicon SoC drivers
+#
+# end of Hisilicon SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Enable LiteX SoC Builder specific drivers
+#
+# CONFIG_LITEX_SOC_CONTROLLER is not set
+# end of Enable LiteX SoC Builder specific drivers
+
+# CONFIG_WPCM450_SOC is not set
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+#
+# PM Domains
+#
+
+#
+# Amlogic PM Domains
+#
+# end of Amlogic PM Domains
+
+CONFIG_ARM_SCMI_PERF_DOMAIN=m
+CONFIG_ARM_SCMI_POWER_DOMAIN=m
+
+#
+# Broadcom PM Domains
+#
+# end of Broadcom PM Domains
+
+#
+# i.MX PM Domains
+#
+# end of i.MX PM Domains
+
+#
+# Qualcomm PM Domains
+#
+# end of Qualcomm PM Domains
+# end of PM Domains
+
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+# CONFIG_DEVFREQ_GOV_PASSIVE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+CONFIG_ARM_PL172_MPMC=y
+CONFIG_PL353_SMC=y
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_VIC=y
+CONFIG_ARM_VIC_NR=2
+# CONFIG_AL_FIC is not set
+# CONFIG_LAN966X_OIC is not set
+# CONFIG_XILINX_INTC is not set
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_GPIO is not set
+CONFIG_RESET_SCMI=m
+# CONFIG_RESET_SIMPLE is not set
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_RESET_TI_TPS380X is not set
+# CONFIG_COMMON_RESET_HI3660 is not set
+# CONFIG_COMMON_RESET_HI6220 is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_PHY_CAN_TRANSCEIVER is not set
+
+#
+# PHY drivers for Broadcom platforms
+#
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# end of PHY drivers for Broadcom platforms
+
+# CONFIG_PHY_CADENCE_TORRENT is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_DPHY_RX is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_CADENCE_SALVO is not set
+# CONFIG_PHY_HISI_INNO_USB2 is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_LAN966X_SERDES is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID_BINDER_IPC is not set
+# end of Android
+
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+CONFIG_NVMEM_LAYOUTS=y
+
+#
+# Layout Types
+#
+# CONFIG_NVMEM_LAYOUT_SL28_VPD is not set
+# CONFIG_NVMEM_LAYOUT_ONIE_TLV is not set
+CONFIG_NVMEM_LAYOUT_U_BOOT_ENV=y
+# end of Layout Types
+
+CONFIG_NVMEM_RMEM=m
+CONFIG_NVMEM_U_BOOT_ENV=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+# CONFIG_MOST is not set
+# CONFIG_PECI is not set
+# CONFIG_HTE is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+CONFIG_FS_STACK=y
+CONFIG_BUFFER_HEAD=y
+CONFIG_LEGACY_DIRECT_IO=y
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_BCACHEFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_VIRTIO_FS=m
+CONFIG_FUSE_PASSTHROUGH=y
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/EXFAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_EXFAT_FS is not set
+CONFIG_NTFS3_FS=m
+# CONFIG_NTFS3_LZX_XPRESS is not set
+# CONFIG_NTFS3_FS_POSIX_ACL is not set
+CONFIG_NTFS_FS=m
+# end of DOS/FAT/EXFAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TMPFS_QUOTA is not set
+CONFIG_CONFIGFS_FS=m
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_FS_POSIX_ACL=y
+CONFIG_JFFS2_FS_SECURITY=y
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UBIFS_FS_ZSTD=y
+# CONFIG_UBIFS_ATIME_SUPPORT is not set
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_SECURITY=y
+# CONFIG_UBIFS_FS_AUTHENTICATION is not set
+CONFIG_CRAMFS=m
+CONFIG_CRAMFS_BLOCKDEV=y
+CONFIG_CRAMFS_MTD=y
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_FILE_CACHE=y
+# CONFIG_SQUASHFS_FILE_DIRECT is not set
+CONFIG_SQUASHFS_DECOMP_SINGLE=y
+# CONFIG_SQUASHFS_CHOICE_DECOMP_BY_MOUNT is not set
+CONFIG_SQUASHFS_COMPILE_DECOMP_SINGLE=y
+# CONFIG_SQUASHFS_COMPILE_DECOMP_MULTI is not set
+# CONFIG_SQUASHFS_COMPILE_DECOMP_MULTI_PERCPU is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_ZLIB=y
+# CONFIG_SQUASHFS_LZ4 is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_ZSTD is not set
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EROFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_SMB_SERVER is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+CONFIG_IO_WQ=y
+# end of File systems
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_PROC_MEM_ALWAYS_FORCE=y
+# CONFIG_PROC_MEM_FORCE_PTRACE is not set
+# CONFIG_PROC_MEM_NO_FORCE is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,ipe,bpf"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_CC_HAS_AUTO_VAR_INIT_PATTERN=y
+CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO_BARE=y
+CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO=y
+# CONFIG_INIT_STACK_NONE is not set
+CONFIG_INIT_STACK_ALL_PATTERN=y
+# CONFIG_INIT_STACK_ALL_ZERO is not set
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+CONFIG_CC_HAS_ZERO_CALL_USED_REGS=y
+# CONFIG_ZERO_CALL_USED_REGS is not set
+# end of Memory initialization
+
+#
+# Hardening of kernel data structures
+#
+# CONFIG_LIST_HARDENED is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# end of Hardening of kernel data structures
+
+CONFIG_RANDSTRUCT_NONE=y
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_SIG2=y
+CONFIG_CRYPTO_SKCIPHER=y
+CONFIG_CRYPTO_SKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_MANAGER_EXTRA_TESTS is not set
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_CRYPTD=y
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CRYPTO_ENGINE=y
+# end of Crypto core or helper
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+CONFIG_CRYPTO_DH=y
+# CONFIG_CRYPTO_DH_RFC7919_GROUPS is not set
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+CONFIG_CRYPTO_ECDSA=y
+CONFIG_CRYPTO_ECRDSA=y
+# CONFIG_CRYPTO_CURVE25519 is not set
+# end of Public-key cryptography
+
+#
+# Block ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARIA is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_BLOWFISH_COMMON=m
+# CONFIG_CRYPTO_CAMELLIA is not set
+CONFIG_CRYPTO_CAST_COMMON=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_SERPENT=m
+# CONFIG_CRYPTO_SM4_GENERIC is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+# end of Block ciphers
+
+#
+# Length-preserving ciphers and modes
+#
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_HCTR2 is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# end of Length-preserving ciphers and modes
+
+#
+# AEAD (authenticated encryption with associated data) ciphers
+#
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_CCM is not set
+CONFIG_CRYPTO_GCM=y
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+# CONFIG_CRYPTO_ESSIV is not set
+# end of AEAD (authenticated encryption with associated data) ciphers
+
+#
+# Hashes, digests, and MACs
+#
+# CONFIG_CRYPTO_BLAKE2B is not set
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA3=y
+# CONFIG_CRYPTO_SM3_GENERIC is not set
+CONFIG_CRYPTO_STREEBOG=y
+# CONFIG_CRYPTO_VMAC is not set
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_XCBC=m
+# CONFIG_CRYPTO_XXHASH is not set
+# end of Hashes, digests, and MACs
+
+#
+# CRCs (cyclic redundancy checks)
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32=y
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# end of CRCs (cyclic redundancy checks)
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+CONFIG_CRYPTO_ZSTD=y
+# end of Compression
+
+#
+# Random number generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+CONFIG_CRYPTO_DRBG_HASH=y
+CONFIG_CRYPTO_DRBG_CTR=y
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_JITTERENTROPY_MEMORY_BLOCKS=64
+CONFIG_CRYPTO_JITTERENTROPY_MEMORY_BLOCKSIZE=32
+CONFIG_CRYPTO_JITTERENTROPY_OSR=1
+# end of Random number generation
+
+#
+# Userspace interface
+#
+CONFIG_CRYPTO_USER_API=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+# CONFIG_CRYPTO_USER_API_RNG_CAVP is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_USER_API_ENABLE_OBSOLETE=y
+# end of Userspace interface
+
+CONFIG_CRYPTO_HASH_INFO=y
+
+#
+# Accelerated Cryptographic Algorithms for CPU (arm)
+#
+# CONFIG_CRYPTO_POLY1305_ARM is not set
+CONFIG_CRYPTO_BLAKE2S_ARM=y
+CONFIG_CRYPTO_SHA1_ARM=y
+# CONFIG_CRYPTO_SHA256_ARM is not set
+# CONFIG_CRYPTO_SHA512_ARM is not set
+CONFIG_CRYPTO_AES_ARM=y
+# CONFIG_CRYPTO_CHACHA20_NEON is not set
+# end of Accelerated Cryptographic Algorithms for CPU (arm)
+
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_VIRTIO is not set
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_AMLOGIC_GXL is not set
+
+#
+# Certificates for signature checking
+#
+# end of Certificates for signature checking
+
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_PACKING=y
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+# CONFIG_PRIME_NUMBERS is not set
+CONFIG_RATIONAL=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+
+#
+# Crypto library routines
+#
+CONFIG_CRYPTO_LIB_UTILS=y
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_LIB_GF128MUL=y
+CONFIG_CRYPTO_ARCH_HAVE_LIB_BLAKE2S=y
+# CONFIG_CRYPTO_LIB_CHACHA is not set
+# CONFIG_CRYPTO_LIB_CURVE25519 is not set
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_LIB_POLY1305_RSIZE=9
+# CONFIG_CRYPTO_LIB_POLY1305 is not set
+# CONFIG_CRYPTO_LIB_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_LIB_SHA1=y
+CONFIG_CRYPTO_LIB_SHA256=y
+# end of Crypto library routines
+
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC64_ROCKSOFT is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_XXHASH=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_ZSTD_COMMON=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_ARM64=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_RISCV=y
+# CONFIG_XZ_DEC_MICROLZMA is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_XARRAY_MULTI=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_DMA_OPS_HELPERS=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_HAS_DMA_WRITE_COMBINE=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SETUP_DMA_OPS=y
+CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU=y
+CONFIG_DMA_NEED_SYNC=y
+CONFIG_DMA_NONCOHERENT_MMAP=y
+CONFIG_ARCH_HAS_DMA_ALLOC=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_DMA_MAP_BENCHMARK is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_FORCE_NR_CPUS=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_DIMLIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_6x10 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_TER16x32 is not set
+# CONFIG_FONT_6x8 is not set
+CONFIG_FONT_AUTOSELECT=y
+CONFIG_SG_POOL=y
+CONFIG_ARCH_STACKWALK=y
+CONFIG_STACKDEPOT=y
+CONFIG_STACKDEPOT_MAX_FRAMES=64
+CONFIG_SBITMAP=y
+# CONFIG_LWQ_TEST is not set
+# end of Library routines
+
+CONFIG_GENERIC_LIB_DEVMEM_IS_ALLOWED=y
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+# CONFIG_STACKTRACE_BUILD_ID is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DYNAMIC_DEBUG_CORE is not set
+CONFIG_SYMBOLIC_ERRNAME=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# end of printk and dmesg options
+
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_AS_HAS_NON_CONST_ULEB128=y
+CONFIG_DEBUG_INFO_NONE=y
+# CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_DEBUG_INFO_DWARF5 is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_HEADERS_INSTALL is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_VMLINUX_MAP is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+#
+# Generic Kernel Debugging Instruments
+#
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_FS_ALLOW_ALL=y
+# CONFIG_DEBUG_FS_DISALLOW_MOUNT is not set
+# CONFIG_DEBUG_FS_ALLOW_NONE is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARCH_HAS_UBSAN=y
+# CONFIG_UBSAN is not set
+CONFIG_HAVE_KCSAN_COMPILER=y
+# end of Generic Kernel Debugging Instruments
+
+#
+# Networking Debugging
+#
+# CONFIG_NET_DEV_REFCNT_TRACKER is not set
+# CONFIG_NET_NS_REFCNT_TRACKER is not set
+# CONFIG_DEBUG_NET is not set
+# end of Networking Debugging
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_PAGE_REF is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SHRINKER_DEBUG is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_MEM_ALLOC_PROFILING is not set
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_HAVE_ARCH_KASAN_VMALLOC=y
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS=y
+# CONFIG_KASAN is not set
+CONFIG_HAVE_ARCH_KFENCE=y
+# CONFIG_KFENCE is not set
+# end of Memory Debugging
+
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Oops, Lockups and Hangs
+#
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_WQ_CPU_INTENSIVE_REPORT is not set
+# CONFIG_TEST_LOCKUP is not set
+# end of Debug Oops, Lockups and Hangs
+
+#
+# Scheduler Debugging
+#
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# end of Scheduler Debugging
+
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_SCF_TORTURE_TEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+# CONFIG_DEBUG_IRQFLAGS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+
+#
+# Debug kernel data structures
+#
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_MAPLE_TREE is not set
+# end of Debug kernel data structures
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_SCALE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_REF_SCALE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_BUILDTIME_MCOUNT_SORT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_BOOTTIME_TRACING is not set
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_HWLAT_TRACER is not set
+# CONFIG_OSNOISE_TRACER is not set
+# CONFIG_TIMERLAT_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENTS=y
+CONFIG_DYNAMIC_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+# CONFIG_SYNTH_EVENTS is not set
+# CONFIG_USER_EVENTS is not set
+# CONFIG_TRACE_EVENT_INJECT is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_TRACE_EVAL_MAP_FILE is not set
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_VALIDATE_TIME_DELTAS is not set
+# CONFIG_PREEMPTIRQ_DELAY_TEST is not set
+# CONFIG_KPROBE_EVENT_GEN_TEST is not set
+# CONFIG_RV is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_STRICT_DEVMEM is not set
+
+#
+# arm Debugging
+#
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_ARM_DEBUG_WX is not set
+# CONFIG_UNWINDER_FRAME_POINTER is not set
+CONFIG_UNWINDER_ARM=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_BACKTRACE_VERBOSE is not set
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+CONFIG_DEBUG_HI3515=y
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+# CONFIG_DEBUG_UART_FLOW_CONTROL is not set
+CONFIG_DEBUG_LL_INCLUDE="debug/hi3515-debug-macro.S"
+CONFIG_DEBUG_UNCOMPRESS=y
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_ARM_KPROBES_TEST is not set
+# CONFIG_CORESIGHT is not set
+# end of arm Debugging
+
+#
+# Kernel Testing and Coverage
+#
+# CONFIG_KUNIT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FUNCTION_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_TEST_DHRY is not set
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_MIN_HEAP is not set
+# CONFIG_TEST_DIV64 is not set
+# CONFIG_TEST_MULDIV64 is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_TEST_REF_TRACKER is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_SCANF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_MAPLE_TREE is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_BITOPS is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_TEST_FREE_PAGES is not set
+# CONFIG_TEST_OBJPOOL is not set
+CONFIG_ARCH_USE_MEMTEST=y
+# CONFIG_MEMTEST is not set
+# end of Kernel Testing and Coverage
+
+#
+# Rust hacking
+#
+# end of Rust hacking
+# end of Kernel hacking
diff --no-dereference -ruN linux-master/drivers/accel/hi3515-accel.c linux-master-mod/drivers/accel/hi3515-accel.c
--- linux-master/drivers/accel/hi3515-accel.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/accel/hi3515-accel.c	2024-11-13 22:24:22.427842161 +0300
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Indir Wolf
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-direction.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <linux/fb.h>
+
+/*
+TDE REGS:
+0x20140000 - base
+
+0x830 - should be 0 on begin
+0x820 - should be 0 on begin
+0x82C
+	bits 20-24 should be 0b10100 on begin
+	should be 0b10000 before writing 1 to 0x808
+0x814
+	if bit 1 is 0, then CTL is idle
+0x818 - int stats/int clear, needs to be written to same value after read
+	for CTL reset should be 0x800F001F
+	
+0x804 - should be 0xFFFFFFFF for CTL reset
+
+0x830 - should be set to phy naddr on task start
+0x834 - should be set to update on task start
+0x808 - bit1 should be set to 1 on task start
+
+
+
+TODO
+
+*/
+
+
diff --no-dereference -ruN linux-master/drivers/accel/Makefile linux-master-mod/drivers/accel/Makefile
--- linux-master/drivers/accel/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/accel/Makefile	2024-11-12 22:46:55.070613695 +0300
@@ -3,3 +3,4 @@
 obj-$(CONFIG_DRM_ACCEL_HABANALABS)	+= habanalabs/
 obj-$(CONFIG_DRM_ACCEL_IVPU)		+= ivpu/
 obj-$(CONFIG_DRM_ACCEL_QAIC)		+= qaic/
+obj-$(CONFIG_ARCH_HI3515V100)		+= hi3515-accel.o
diff --no-dereference -ruN linux-master/drivers/ata/libahci.c linux-master-mod/drivers/ata/libahci.c
--- linux-master/drivers/ata/libahci.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/ata/libahci.c	2024-11-04 02:06:35.882082247 +0300
@@ -229,7 +229,9 @@
 		msleep(10);
 	}
 
+#ifndef CONFIG_ARCH_HI3515V100 //seems to be normal for Hi3515
 	WARN_ON(1);
+#endif
 }
 
 /**
diff --no-dereference -ruN linux-master/drivers/char/himedia.c linux-master-mod/drivers/char/himedia.c
--- linux-master/drivers/char/himedia.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/char/himedia.c	2024-10-15 21:19:41.392903571 +0300
@@ -0,0 +1,287 @@
+/*
+ * linux/drivers/char/himedia.c
+ *
+ * Generic misc open routine by Johan Myreen
+ *
+ * Based on code from Linus
+ *
+ * Teemu Rantanen's Microsoft Busmouse support and Derrick Cole's
+ *   changes incorporated into 0.97pl4
+ *   by Peter Cervasio (pete%q106fm.uucp@wupost.wustl.edu) (08SEP92)
+ *   See busmouse.c for particulars.
+ *
+ * Made things a lot mode modular - easy to compile in just one or two
+ * of the misc drivers, as they are now completely independent. Linus.
+ *
+ * Support for loadable modules. 8-Sep-95 Philip Blundell <pjb27@cam.ac.uk>
+ *
+ * Fixed a failing symbol register to free the device registration
+ *		Alan Cox <alan@lxorguk.ukuu.org.uk> 21-Jan-96
+ *
+ * Dynamic minors and /proc/mice by Alessandro Rubini. 26-Mar-96
+ *
+ * Renamed to misc and miscdevice to be more accurate. Alan Cox 26-Mar-96
+ *
+ * Handling of mouse minor numbers for kerneld:
+ *  Idea by Jacques Gelinas <jack@solucorp.qc.ca>,
+ *  adapted by Bjorn Ekwall <bj0rn@blox.se>
+ *  corrected by Alan Cox <alan@lxorguk.ukuu.org.uk>
+ *
+ * Changes for kmod (from kerneld):
+ *	Cyrus Durgin <cider@speakeasy.org>
+ *
+ * Added devfs support. Richard Gooch <rgooch@atnf.csiro.au>  10-Jan-1998
+ * Changed for hisilicon-media devices by Liu Jiandong 10-Dec-2007
+ */
+
+#include <linux/module.h>
+
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/himedia.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/kmod.h>
+
+/*
+ * Head entry for the doubly linked himedia_device list
+ */
+static LIST_HEAD(himedia_list);
+static DEFINE_MUTEX(himedia_sem);
+
+/*
+ * Assigned numbers, used for dynamic minors
+ */
+#define DYNAMIC_MINORS 64 /* like dynamic majors */
+static unsigned char himedia_minors[DYNAMIC_MINORS / 8];
+
+extern int pmu_device_init(void);
+
+#ifdef CONFIG_PROC_FS
+static void *himedia_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	mutex_lock(&himedia_sem);
+	return seq_list_start(&himedia_list, *pos);
+}
+
+static void *himedia_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	return seq_list_next(v, &himedia_list, pos);
+}
+
+static void himedia_seq_stop(struct seq_file *seq, void *v)
+{
+	mutex_unlock(&himedia_sem);
+}
+
+static int himedia_seq_show(struct seq_file *seq, void *v)
+{
+	const struct himedia_device *p = list_entry(v, struct himedia_device, list);
+
+	seq_printf(seq, "%3i %s\n", p->minor, p->name ? p->name : "");
+	return 0;
+}
+
+
+static struct seq_operations himedia_seq_ops = {
+	.start = himedia_seq_start,
+	.next  = himedia_seq_next,
+	.stop  = himedia_seq_stop,
+	.show  = himedia_seq_show,
+};
+
+static int himedia_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &himedia_seq_ops);
+}
+
+static struct proc_ops himedia_proc_fops = {
+	// .owner	 = THIS_MODULE,
+	.proc_open    = himedia_seq_open,
+	.proc_read    = seq_read,
+	.proc_lseek  = seq_lseek,
+	.proc_release = seq_release,
+};
+#endif
+
+static int himedia_open(struct inode * inode, struct file * file)
+{
+	int minor = iminor(inode);
+	struct himedia_device *c;
+	int err = -ENODEV;
+	const struct file_operations *old_fops, *new_fops = NULL;
+	
+	mutex_lock(&himedia_sem);
+	
+	list_for_each_entry(c, &himedia_list, list) {
+		if (c->minor == minor) {
+			new_fops = fops_get(c->fops);		
+			break;
+		}
+	}
+		
+	if (!new_fops) {
+		mutex_unlock(&himedia_sem);
+		request_module("char-major-%d-%d", HIMEDIA_DEVICE_MAJOR, minor);
+		mutex_lock(&himedia_sem);
+
+		list_for_each_entry(c, &himedia_list, list) {
+			if (c->minor == minor) {
+				new_fops = fops_get(c->fops);
+				break;
+			}
+		}
+		if (!new_fops)
+			goto fail;
+	}
+
+	err = 0;
+	old_fops = file->f_op;
+	file->f_op = new_fops;
+	if (file->f_op->open) {
+		err=file->f_op->open(inode,file);
+		if (err) {
+			fops_put(file->f_op);
+			file->f_op = fops_get(old_fops);
+		}
+	}
+	fops_put(old_fops);
+fail:
+	mutex_unlock(&himedia_sem);
+	return err;
+}
+
+static struct class *himedia_class;
+
+static struct file_operations himedia_fops = {
+	.owner		= THIS_MODULE,
+	.open		= himedia_open,
+};
+
+
+/**
+ *	himedia_register	-	register a himedia device
+ *	@himedia: device structure
+ *	
+ *	Register a himedia device with the kernel. If the minor
+ *	number is set to %HIMEDIA_DYNAMIC_MINOR a minor number is assigned
+ *	and placed in the minor field of the structure. For other cases
+ *	the minor number requested is used.
+ *
+ *	The structure passed is linked into the kernel and may not be
+ *	destroyed until it has been unregistered.
+ *
+ *	A zero is returned on success and a negative errno code for
+ *	failure.
+ */
+ 
+int himedia_register(struct himedia_device * himedia)
+{
+	struct himedia_device *c;
+	dev_t dev;
+	int err = 0;
+
+	INIT_LIST_HEAD(&himedia->list);
+
+	mutex_lock(&himedia_sem);
+	list_for_each_entry(c, &himedia_list, list) {
+		if (c->minor == himedia->minor) {
+			mutex_unlock(&himedia_sem);
+			return -EBUSY;
+		}
+	}
+
+	if (himedia->minor == HIMEDIA_DYNAMIC_MINOR) {
+		int i = DYNAMIC_MINORS;
+		while (--i >= 0)
+			if ( (himedia_minors[i>>3] & (1 << (i&7))) == 0)
+				break;
+		if (i<0) {
+			mutex_unlock(&himedia_sem);
+			return -EBUSY;
+		}
+		himedia->minor = i;
+	}
+
+	if (himedia->minor < DYNAMIC_MINORS)
+		himedia_minors[himedia->minor >> 3] |= 1 << (himedia->minor & 7);
+	dev = MKDEV(HIMEDIA_DEVICE_MAJOR, himedia->minor);
+
+	himedia->this_device = device_create(himedia_class, himedia->parent, dev,
+					  "%s", himedia->name);
+	if (IS_ERR(himedia->this_device)) {
+		err = PTR_ERR(himedia->this_device);
+		goto out;
+	}
+
+	/*
+	 * Add it to the front, so that later devices can "override"
+	 * earlier defaults
+	 */
+	list_add(&himedia->list, &himedia_list);
+ out:
+	mutex_unlock(&himedia_sem);
+	return err;
+}
+
+/**
+ *	himedia_deregister - unregister a himedia device
+ *	@himedia: device to unregister
+ *
+ *	Unregister a himedia device that was previously
+ *	successfully registered with himedia_register(). Success
+ *	is indicated by a zero return, a negative errno code
+ *	indicates an error.
+ */
+
+int himedia_deregister(struct himedia_device * himedia)
+{
+	int i = himedia->minor;
+
+	if (list_empty(&himedia->list))
+		return -EINVAL;
+
+	mutex_lock(&himedia_sem);
+	list_del(&himedia->list);
+	device_destroy(himedia_class, MKDEV(HIMEDIA_DEVICE_MAJOR, himedia->minor));
+	if (i < DYNAMIC_MINORS && i>0) {
+		himedia_minors[i>>3] &= ~(1 << (himedia->minor & 7));
+	}
+	mutex_unlock(&himedia_sem);
+	return 0;
+}
+
+EXPORT_SYMBOL(himedia_register);
+EXPORT_SYMBOL(himedia_deregister);
+
+static int __init himedia_init(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *ent;
+
+	// ent = create_proc_entry("himedia", 0, NULL);
+	// if (ent)
+		// ent->proc_fops = &himedia_proc_fops;
+	proc_create("himedia", 0, NULL, &himedia_proc_fops);
+#endif
+	himedia_class = class_create("himedia");
+	if (IS_ERR(himedia_class))
+		return PTR_ERR(himedia_class);
+
+	if (register_chrdev(HIMEDIA_DEVICE_MAJOR,"himedia",&himedia_fops)) {
+		printk("unable to get major %d for himedia devices\n",
+		       HIMEDIA_DEVICE_MAJOR);
+		class_destroy(himedia_class);
+		return -EIO;
+	}
+	return 0;
+}
+subsys_initcall(himedia_init);
diff --no-dereference -ruN linux-master/drivers/char/Makefile linux-master-mod/drivers/char/Makefile
--- linux-master/drivers/char/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/char/Makefile	2024-10-15 01:28:55.439885874 +0300
@@ -5,7 +5,8 @@
 
 obj-y				+= mem.o random.o
 obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
-obj-y				+= misc.o
+obj-y				+= misc.o 
+obj-y				+= himedia.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_VIRTIO_CONSOLE)	+= virtio_console.o
 obj-$(CONFIG_UV_MMTIMER)	+= uv_mmtimer.o
diff --no-dereference -ruN linux-master/drivers/clk/hisilicon/clk-hi3515.c linux-master-mod/drivers/clk/hisilicon/clk-hi3515.c
--- linux-master/drivers/clk/hisilicon/clk-hi3515.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/clk/hisilicon/clk-hi3515.c	2024-11-24 14:41:48.875975321 +0300
@@ -0,0 +1,730 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/notifier.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/types.h>
+#include <linux/of_address.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include <linux/math64.h>
+
+#include <dt-bindings/clock/hi3515-clock.h>
+
+struct hi3515_pll_clk {
+	struct clk_hw hw;
+	struct regmap *regs;
+	int regnum;
+};
+
+
+#define HI3515_PLL_MINVCO 800000000 + 100000000
+#define HI3515_PLL_MAXVCO 2400000000 - 100000000
+#define to_hi3515_pll_clk(_hw) container_of((_hw), struct hi3515_pll_clk, hw)
+
+// #undef pr_debug
+// #define pr_debug pr_info
+
+static unsigned long hi3515_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate) {
+	struct hi3515_pll_clk *pll = to_hi3515_pll_clk(hw);
+	//calculating FOUTPOSTDIV
+	u32 rega, regb;
+	if(regmap_read(pll->regs, pll->regnum + 0x0, &rega)) {
+		return 0;
+	}
+	if(regmap_read(pll->regs, pll->regnum + 0x4, &regb)) {
+		return 0;
+	}
+	uint32_t fbdiv = regb&0xFFF;
+	uint32_t frac = rega&0xFFFFFF;
+	uint32_t refdiv = (regb&0x3F000) >> 12;
+	uint32_t pstdiv1 = (rega&0x7000000) >> 24;
+	uint32_t pstdiv2 = (rega&0x38000000) >> 27;
+	return ((parent_rate * fbdiv + parent_rate * frac/0x1000000)/refdiv) / (pstdiv1*pstdiv2);
+}
+
+static int hi3515_pll_is_enabled(struct clk_hw *hw) {
+	struct hi3515_pll_clk *pll = to_hi3515_pll_clk(hw);
+	u32 regb;
+	if(!regmap_read(pll->regs, pll->regnum + 0x4, &regb)) {
+		return !!(regb & (0b1 << 21));
+	} else {
+		return 0;
+	}
+}
+
+static int hi3515_pll_enable(struct clk_hw *hw) {
+	struct hi3515_pll_clk *pll = to_hi3515_pll_clk(hw);
+	regmap_write_bits(pll->regs, pll->regnum + 0x4, (0b11111 << 18), (0b11011 << 18));
+	pr_debug("HI3515 ENABLING PLL %d\n", pll->regnum);
+	return 0;
+}
+
+static void hi3515_pll_disable(struct clk_hw *hw) {
+	struct hi3515_pll_clk *pll = to_hi3515_pll_clk(hw);
+	pr_debug("HI3515 DISABLING PLL %d(had freq %lu, was %d)\n", pll->regnum, hi3515_pll_recalc_rate(hw, 24000000), hi3515_pll_is_enabled(hw));
+	regmap_write_bits(pll->regs, pll->regnum + 0x4, (0b11111 << 18), (0b10000 << 18));
+}
+
+static long hi3515_pll_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate) {
+	struct hi3515_pll_clk *pll = to_hi3515_pll_clk(hw);
+	uint32_t pstdiv1_closest = 1;
+	uint32_t pstdiv2_closest = 1;
+	uint32_t refdiv_closest = 0x03;
+	uint32_t fbdiv_closest = 0xC8;
+	uint32_t error_closest = 100000000;
+	long newrate = 0;
+	for(int pstdiv1 = 1; pstdiv1 < 8; pstdiv1++) {
+		for(int pstdiv2 = 1; pstdiv2 < 8; pstdiv2++) {
+			uint32_t foutvco = rate * (pstdiv1 * pstdiv2);
+			if(foutvco >= HI3515_PLL_MAXVCO || foutvco <= HI3515_PLL_MINVCO)
+				continue;
+			for(int refdiv = 1; refdiv < 64; refdiv++) {
+				uint32_t fbdiv = foutvco * refdiv / *parent_rate;
+				if(fbdiv < 1 || fbdiv > 0xFFF)
+					continue;
+				uint32_t error = abs((((*parent_rate * fbdiv)/refdiv) / (pstdiv1*pstdiv2)) - rate);
+				if(error < error_closest) {
+					newrate = ((*parent_rate * fbdiv)/refdiv) / (pstdiv1*pstdiv2);
+					pstdiv1_closest = pstdiv1;
+					pstdiv2_closest = pstdiv2;
+					refdiv_closest = refdiv;
+					fbdiv_closest = fbdiv;
+					error_closest = error;
+				}
+			}
+		}
+	}
+	newrate = ((*parent_rate * fbdiv_closest)/refdiv_closest) / (pstdiv1_closest*pstdiv2_closest);
+	pr_debug("HI3515 PLL %d ROUDING RATE %lu -> %ld\n", pll->regnum, rate, newrate);
+	return newrate;
+}
+
+static int hi3515_pll_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate) {
+	struct hi3515_pll_clk *pll = to_hi3515_pll_clk(hw);
+	uint32_t pstdiv1_closest = 1;
+	uint32_t pstdiv2_closest = 1;
+	uint32_t refdiv_closest = 0x03;
+	uint32_t fbdiv_closest = 0xC8;
+	uint32_t error_closest = 100000000;
+	for(int pstdiv1 = 1; pstdiv1 < 8; pstdiv1++) {
+		for(int pstdiv2 = 1; pstdiv2 < 8; pstdiv2++) {
+			uint32_t foutvco = rate * (pstdiv1 * pstdiv2);
+			if(foutvco >= HI3515_PLL_MAXVCO || foutvco <= HI3515_PLL_MINVCO)
+				continue;
+			for(int refdiv = 1; refdiv < 64; refdiv++) {
+				uint32_t fbdiv = foutvco * refdiv / parent_rate;
+				if(fbdiv < 1 || fbdiv > 0xFFF)
+					continue;
+				uint32_t error = abs((((parent_rate * fbdiv)/refdiv) / (pstdiv1*pstdiv2)) - rate);
+				if(error < error_closest) {
+					pstdiv1_closest = pstdiv1;
+					pstdiv2_closest = pstdiv2;
+					refdiv_closest = refdiv;
+					fbdiv_closest = fbdiv;
+					error_closest = error;
+				}
+			}
+		}
+	}
+	regmap_write(pll->regs, pll->regnum + 0x0, (0 | (pstdiv1_closest<<24) | (pstdiv2_closest<<27) | (0<<30) | (1<<31)) );
+	regmap_write_bits(pll->regs, pll->regnum + 0x4, 0x3FFFF, (fbdiv_closest | (refdiv_closest << 12)) );
+	pr_debug("HI3515 PLL %d WRITING RATE NEW %lu\n", pll->regnum, hi3515_pll_recalc_rate(hw, parent_rate));
+	return 0;
+	
+}
+
+static const struct clk_ops hi3515_pll_ops = {
+	.enable = hi3515_pll_enable,
+	.disable = hi3515_pll_disable,
+	.is_enabled = hi3515_pll_is_enabled,
+	.recalc_rate = hi3515_pll_recalc_rate,
+	.round_rate = hi3515_pll_round_rate,
+	.set_rate = hi3515_pll_set_rate,
+};
+
+
+static int hi3515_pll_probe(struct device_node *node) {
+	int ret;
+	const char *parent_name;
+	unsigned int num_parents;
+	struct hi3515_pll_clk *pll_clk;
+	struct clk_init_data init = { };
+
+	pll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);
+	if (!pll_clk)
+		return -ENOMEM;
+
+	pll_clk->regs = syscon_regmap_lookup_by_compatible("hisilicon,hi3515sysctrl");
+	of_property_read_u32(node, "regnum", &pll_clk->regnum);
+
+	init.name = node->name;
+	init.ops = &hi3515_pll_ops;
+	parent_name = of_clk_get_parent_name(node, 0);
+	init.parent_names = &parent_name;
+	num_parents = of_clk_get_parent_count(node);
+	init.num_parents = num_parents;
+
+	pll_clk->hw.init = &init;
+
+	ret = of_clk_hw_register(node, &pll_clk->hw);
+	if (ret) {
+		pr_err("failed to register %s clock\n", init.name);
+		return ret;
+	}
+	
+	pr_info("HI3515 PLL %s initialized\n", node->name);
+
+	return of_clk_add_hw_provider(node, of_clk_hw_simple_get,
+					   &pll_clk->hw);
+}
+
+CLK_OF_DECLARE(hi3515_pll, "hisilicon,hi3515pllctl", hi3515_pll_probe);
+
+//----------------------------------------------------------------------------------------------------------------------------------
+
+struct hi3515_clockctrl_gate {
+	struct clk_hw hw;
+	struct regmap *regs;
+	int idx;
+};
+
+struct hi3515_clockctrl_clkinfo {
+	const char* name;
+	int idx;
+	u32 mul;
+	u32 div;
+	bool rsvd;
+};
+
+#define EPLL_I2S_FREQ 500000000ULL
+static const uint32_t i2s_bclk_divs[] = {1, 3, 2, 4, 6, 8, 12, 16, 24, 48, 64, 128};
+static const uint32_t i2s_lrclk_divs[] = {2, 4, 8, 16, 32, 48, 64, 128, 256};
+
+static const struct hi3515_clockctrl_clkinfo hi3515_clockctrl_clksinfo[HI3515_PER_CLK_CNT] = {
+	{"clk_rsvd0", 0, 1, 1, 1},
+	{"clk_sata", HI3515_PER_CLK_SATA, 1, 1, 0},
+	{"clk_cipher", HI3515_PER_CLK_CIPHER, 1, 1, 0},
+	{"clk_smi", HI3515_PER_CLK_SMI, 1, 1, 0},
+	{"clk_uart0", HI3515_PER_CLK_UART0, 43, 100, 0},
+	{"clk_uart1", HI3515_PER_CLK_UART1, 43, 100, 0},
+	{"clk_uart2", HI3515_PER_CLK_UART2, 43, 100, 0},
+	{"clk_uart3", HI3515_PER_CLK_UART3, 43, 100, 0},
+	{"clk_sio0", HI3515_PER_CLK_SIO0, 1, 1, 0},
+	{"clk_sio1", HI3515_PER_CLK_SIO1, 1, 1, 0},
+	{"clk_rsvd10", 10, 1, 1, 1},
+	{"clk_ir", HI3515_PER_CLK_IR, 1, 1, 0},
+	{"clk_rsvd12", 12, 1, 1, 1},
+	{"clk_rsvd13", 13, 1, 1, 1},
+	{"clk_mmc", HI3515_PER_CLK_MMC, 1, 1, 0},
+	{"clk_tde", HI3515_PER_CLK_TDE, 1, 1, 0},
+	{"clk_vibus", HI3515_PER_CLK_VIBUS, 1, 1, 0},
+	{"clk_vi0", HI3515_PER_CLK_VI0, 1, 1, 0},
+	{"clk_vi1", HI3515_PER_CLK_VI1, 1, 1, 0},
+	{"clk_vi2", HI3515_PER_CLK_VI2, 1, 1, 0},
+	{"clk_vi3", HI3515_PER_CLK_VI3, 1, 1, 0},
+	{"clk_eth", HI3515_PER_CLK_ETH, 1, 1, 0},
+	{"clk_usb", HI3515_PER_CLK_USB, 1, 1, 0},
+	{"clk_vobus", HI3515_PER_CLK_VOBUS, 1, 1, 0},
+	{"clk_vosd", HI3515_PER_CLK_VOSD, 1, 1, 0},
+	{"clk_vohd", HI3515_PER_CLK_VOHD, 1, 1, 0},
+	{"clk_rsvd26", 26, 1, 1, 1},
+	{"clk_nandc", HI3515_PER_CLK_NANDC, 1, 1, 0},
+	{"clk_rsvd28", 28, 1, 1, 1},
+	{"clk_ssp", HI3515_PER_CLK_SSP, 1, 1, 0},
+	{"clk_vdac0", HI3515_PER_CLK_VDAC0, 1, 1, 0},
+	{"clk_vdac1", HI3515_PER_CLK_VDAC1, 1, 1, 0},
+};
+
+#define to_hi3515_clockctrl_gate(_hw) container_of(_hw, struct hi3515_clockctrl_gate, hw)
+
+static int hi3515_clockctrl_enable(struct clk_hw *hw) {
+	struct hi3515_clockctrl_gate *gate = to_hi3515_clockctrl_gate(hw);
+	pr_debug("HI3515 CCTRL ENABLING CLOCK %d\n", gate->idx);
+	regmap_write_bits(gate->regs, 0x0024, (1<<(gate->idx)), (1<<(gate->idx)));
+	if(gate->idx == HI3515_PER_CLK_VDAC0 || gate->idx == HI3515_PER_CLK_VDAC1) {
+		regmap_write_bits(gate->regs, 0x0060, (0b11 << 8), (0b11 << 8));
+	}
+	if(gate->idx == HI3515_PER_CLK_SIO0) {
+		regmap_write_bits(gate->regs, 0x0060, 0b111, 0b001);
+	}
+	if(gate->idx == HI3515_PER_CLK_SIO1) {
+		regmap_write_bits(gate->regs, 0x0060, 1 << 3, 1 << 3);
+	}
+	return 0;
+}
+
+static void hi3515_clockctrl_disable(struct clk_hw *hw) {
+	struct hi3515_clockctrl_gate *gate = to_hi3515_clockctrl_gate(hw);
+	pr_debug("HI3515 CCTRL DISABLING CLOCK %d/%d/%s\n", gate->idx,hi3515_clockctrl_clksinfo[gate->idx].idx,hi3515_clockctrl_clksinfo[gate->idx].name);
+	regmap_write_bits(gate->regs, 0x0028, (1<<(gate->idx)), (1<<(gate->idx)));
+	if(gate->idx == HI3515_PER_CLK_VDAC0 || gate->idx == HI3515_PER_CLK_VDAC1) {
+		regmap_write_bits(gate->regs, 0x0060, (0b11 << 8), (0b00 << 8));
+	}
+	if(gate->idx == HI3515_PER_CLK_SIO0) {
+		regmap_write_bits(gate->regs, 0x0060, 0b111, 0b000);
+	}
+	if(gate->idx == HI3515_PER_CLK_SIO1) {
+		regmap_write_bits(gate->regs, 0x0060, 1 << 3, 0 << 3);
+	}
+}
+
+static int hi3515_clockctrl_is_enabled(struct clk_hw *hw) {
+	struct hi3515_clockctrl_gate *gate = to_hi3515_clockctrl_gate(hw);
+	u32 reg;
+	if(gate->idx == HI3515_PER_CLK_VDAC0 || gate->idx == HI3515_PER_CLK_VDAC1) {
+		regmap_read(gate->regs, 0x0060, &reg);
+		if(((reg&0x300)>>8) != 0b11) {
+			return false;
+		}
+	}
+	regmap_read(gate->regs, 0x002C, &reg);
+	return !!(reg & (1<<(gate->idx)) );
+}
+
+
+
+static unsigned long hi3515_clockctrl_recalc_rate(struct clk_hw *hw, unsigned long parent_rate) {
+	struct hi3515_clockctrl_gate *gate = to_hi3515_clockctrl_gate(hw);
+	u32 inreg;
+	u64 reg,div1,div2;
+	
+	reg = 0;
+	inreg = 0;
+	div2 = 0;
+	div1 = 0;
+	
+	if(gate->idx == HI3515_PER_CLK_SIO0) {
+		regmap_read(gate->regs, 0x0064, &inreg);
+		reg = inreg;
+		div1 = (reg&(0b1111ULL << 24))>>24;
+		if(div1 > 0xbULL) {
+			pr_warn("Hi3515 CCTRL WRONG DIV1: %llu\n", div1);
+			div1 = 0xb;
+		}
+		div1 = i2s_bclk_divs[div1];
+		div2 = (reg&(0b1111ULL << 28))>>28;
+		if(div2 > 0x8ULL) {
+			pr_warn("Hi3515 CCTRL WRONG DIV2: %llu\n", div2);
+			div2 = 0x8;
+		}
+		div2 = i2s_lrclk_divs[div2];
+		reg = div_u64(div_u64((EPLL_I2S_FREQ * (reg&0xffffffULL)), 0x8000000ULL), div1*div2);
+		inreg = (reg&0xffffffffULL);
+		pr_debug("HI3515 CCTRL CLOCK %d DIV1 %llu DIV2 %llu RATE %u\n", gate->idx, div1, div2, inreg);
+		return inreg;
+	} else if(gate->idx == HI3515_PER_CLK_SIO1) {
+		regmap_read(gate->regs, 0x0068, &inreg);
+		reg = inreg;
+		div1 = (reg&(0b1111ULL << 24))>>24;
+		if(div1 > 0xbULL) {
+			pr_warn("Hi3515 CCTRL WRONG DIV1: %llu\n", div1);
+			div1 = 0xb;
+		}
+		div1 = i2s_bclk_divs[div1];
+		div2 = (reg&(0b1111ULL << 28))>>28;
+		if(div2 > 0x8ULL) {
+			pr_warn("Hi3515 CCTRL WRONG DIV2: %llu\n", div2);
+			div2 = 0x8;
+		}
+		div2 = i2s_lrclk_divs[div2];
+		reg = div_u64(div_u64((EPLL_I2S_FREQ * (reg&0xffffffULL)), 0x8000000ULL), div1*div2);
+		inreg = (reg&0xffffffffULL);
+		pr_debug("HI3515 CCTRL CLOCK %d DIV1 %llu DIV2 %llu RATE %u\n", gate->idx, div1, div2, inreg);
+		return inreg;
+	}
+	
+	return div_u64(((unsigned long long)parent_rate * (unsigned long long)hi3515_clockctrl_clksinfo[gate->idx].mul), ((unsigned long long)hi3515_clockctrl_clksinfo[gate->idx].div));
+}
+
+
+static long hi3515_clockctrl_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate) {
+	struct hi3515_clockctrl_gate *gate = to_hi3515_clockctrl_gate(hw);
+	u64 newrate, currate;
+	u64 bclk, div, lrclk, error;
+	u64 me_bclk, me_div, me_error = 100000000;
+	
+	if((gate->idx != HI3515_PER_CLK_SIO0) && (gate->idx != HI3515_PER_CLK_SIO1))
+		return rate;
+	
+	// lrclk = 0x3; //fixed 16 bits
+	lrclk = 0x08;
+	
+	for(int i = 0; i < 0x0C; i++) {
+		bclk = i;
+		currate = rate * i2s_lrclk_divs[lrclk] * i2s_bclk_divs[bclk];
+		div = div_u64(currate * 0x8000000ULL, EPLL_I2S_FREQ) & 0xffffffULL;
+		if(div == 0)
+			div = 1;
+		currate = div_u64(div_u64((EPLL_I2S_FREQ * (div)), 0x8000000ULL), i2s_bclk_divs[bclk]*i2s_lrclk_divs[lrclk]);
+		error = abs(currate - rate);
+		if(error < me_error) {
+			me_error = error;
+			me_bclk = bclk;
+			me_div = div;
+		}
+	}
+	
+	newrate = div_u64(div_u64((EPLL_I2S_FREQ * (me_div)), 0x8000000ULL), i2s_bclk_divs[me_bclk]*i2s_lrclk_divs[lrclk]);
+	
+	pr_debug("HI3515 CCTRL CLOCK %d RND RATE %llu (request %lu; EPLL %llu; MEDIV %llu; BCLK %llu => %u; LRCLK %u)\n", gate->idx, newrate, rate, EPLL_I2S_FREQ, me_div, me_bclk, i2s_bclk_divs[me_bclk], i2s_lrclk_divs[lrclk]);
+	
+	return newrate;
+}
+
+static int hi3515_clockctrl_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate) {
+	struct hi3515_clockctrl_gate *gate = to_hi3515_clockctrl_gate(hw);
+	
+	u64 currate;
+	u64 bclk, div, lrclk, error;
+	u32 me_bclk, me_div, me_error = 100000000;
+	
+	// lrclk = 0x3; //fixed 16 bits
+	lrclk = 0x08;
+	
+	for(int i = 0; i < 0x0C; i++) {
+		bclk = i;
+		currate = rate * i2s_lrclk_divs[lrclk] * i2s_bclk_divs[bclk];
+		div = div_u64(currate * 0x8000000ULL, EPLL_I2S_FREQ) & 0xffffffULL;
+		if(div == 0)
+			div = 1;
+		currate = div_u64(div_u64((EPLL_I2S_FREQ * (div)), 0x8000000ULL), i2s_bclk_divs[bclk]*i2s_lrclk_divs[lrclk]);
+		error = abs(currate - rate);
+		if(error < me_error) {
+			me_error = error;
+			me_bclk = bclk;
+			me_div = div;
+		}
+	}
+	
+	pr_debug("HI3515 CCTRL CLOCK %d CALC RATE (request %lu; EPLL %llu; MEDIV %u; BCLK %u => %u; LRCLK %u)\n", gate->idx, rate, EPLL_I2S_FREQ, me_div, me_bclk, i2s_bclk_divs[me_bclk], i2s_lrclk_divs[lrclk]);
+	
+	pr_debug("HI3515 CCTRL CLOCK %d WRITING REG 0x%llx\n", gate->idx, me_div | (me_bclk<<24) | (lrclk<<28));
+	
+	if(gate->idx == HI3515_PER_CLK_SIO0) {
+		regmap_write(gate->regs, 0x0064, me_div | ((me_bclk&0b1111ULL)<<24) | ((lrclk&0b1111ULL)<<28));
+		return 0;
+	} else if(gate->idx == HI3515_PER_CLK_SIO1) {
+		regmap_write(gate->regs, 0x0068, me_div | ((me_bclk&0b1111ULL)<<24) | ((lrclk&0b1111ULL)<<28));
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+static const struct clk_ops hi3515_clockctrl_ops = {
+	.enable = hi3515_clockctrl_enable,
+	.disable = hi3515_clockctrl_disable,
+	.is_enabled =hi3515_clockctrl_is_enabled,
+	.recalc_rate = hi3515_clockctrl_recalc_rate,
+	.round_rate = hi3515_clockctrl_round_rate,
+	.set_rate = hi3515_clockctrl_set_rate,
+};
+
+
+struct hi3515_reset_controller {
+	spinlock_t	lock;
+	struct regmap *regs;
+	struct reset_controller_dev	rcdev;
+};
+
+#define to_hi3515_reset_controller(_rcdev) container_of(_rcdev, struct hi3515_reset_controller, rcdev)
+
+static int hi3515_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	struct hi3515_reset_controller *rstc = to_hi3515_reset_controller(rcdev);
+	pr_debug("HI3515 CCTRL ASSERTING RST %lu\n", id);
+	unsigned long flags;
+	u32 offset = (id<HI3515_SOFTRST_TDEBUS) ? id : (id-HI3515_SOFTRST_TDEBUS);
+	bool noinv = (id==HI3515_SOFTRST_SIO0)||(id==HI3515_SOFTRST_SIO1)||(id==HI3515_SOFTRST_I2C)||(id==HI3515_SOFTRST_RTC)||(id==HI3515_SOFTRST_IR)||(id==HI3515_SOFTRST_UART0)||(id==HI3515_SOFTRST_UART1)||(id==HI3515_SOFTRST_UART2)||(id==HI3515_SOFTRST_UART3)||(id==HI3515_SOFTRST_CIPHER)||(id==HI3515_SOFTRST_SSMC)||(id==HI3515_SOFTRST_DMA)||(id==HI3515_SOFTRST_DDR)||(id==HI3515_SOFTRST_SPI)||(id==HI3515_SOFTRST_NANDC)||(id==HI3515_SOFTRST_TDE)||(id==HI3515_SOFTRST_TDEBUS);
+
+	spin_lock_irqsave(&rstc->lock, flags);
+
+	regmap_write_bits(rstc->regs, (id<HI3515_SOFTRST_TDEBUS) ? 0x0050 : 0x0058, (1<<offset), ((noinv)<<offset));
+
+	spin_unlock_irqrestore(&rstc->lock, flags);
+
+	return 0;
+}
+
+static int hi3515_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	struct hi3515_reset_controller *rstc = to_hi3515_reset_controller(rcdev);
+	pr_debug("HI3515 CCTRL DEASSERTING RST %lu\n", id);
+	unsigned long flags;
+	u32 offset = (id<HI3515_SOFTRST_TDEBUS) ? id : (id-HI3515_SOFTRST_TDEBUS);
+	bool noinv = (id==HI3515_SOFTRST_SIO0)||(id==HI3515_SOFTRST_SIO1)||(id==HI3515_SOFTRST_I2C)||(id==HI3515_SOFTRST_RTC)||(id==HI3515_SOFTRST_IR)||(id==HI3515_SOFTRST_UART0)||(id==HI3515_SOFTRST_UART1)||(id==HI3515_SOFTRST_UART2)||(id==HI3515_SOFTRST_UART3)||(id==HI3515_SOFTRST_CIPHER)||(id==HI3515_SOFTRST_SSMC)||(id==HI3515_SOFTRST_DMA)||(id==HI3515_SOFTRST_DDR)||(id==HI3515_SOFTRST_SPI)||(id==HI3515_SOFTRST_NANDC)||(id==HI3515_SOFTRST_TDE)||(id==HI3515_SOFTRST_TDEBUS);
+
+	spin_lock_irqsave(&rstc->lock, flags);
+
+	regmap_write_bits(rstc->regs, (id<HI3515_SOFTRST_TDEBUS) ? 0x0050 : 0x0058, (1<<offset), ((!noinv)<<offset));
+
+	spin_unlock_irqrestore(&rstc->lock, flags);
+
+	return 0;
+}
+
+static int hi3515_reset_status(struct reset_controller_dev *rcdev, unsigned long id) {
+	struct hi3515_reset_controller *rstc = to_hi3515_reset_controller(rcdev);
+	u32 reg;
+	int ret;
+	unsigned long flags;
+	u32 offset = (id<HI3515_SOFTRST_TDEBUS) ? id : (id-HI3515_SOFTRST_TDEBUS);
+	bool noinv = (id==HI3515_SOFTRST_SIO0)||(id==HI3515_SOFTRST_SIO1)||(id==HI3515_SOFTRST_I2C)||(id==HI3515_SOFTRST_RTC)||(id==HI3515_SOFTRST_IR)||(id==HI3515_SOFTRST_UART0)||(id==HI3515_SOFTRST_UART1)||(id==HI3515_SOFTRST_UART2)||(id==HI3515_SOFTRST_UART3)||(id==HI3515_SOFTRST_CIPHER)||(id==HI3515_SOFTRST_SSMC)||(id==HI3515_SOFTRST_DMA)||(id==HI3515_SOFTRST_DDR)||(id==HI3515_SOFTRST_SPI)||(id==HI3515_SOFTRST_NANDC)||(id==HI3515_SOFTRST_TDE)||(id==HI3515_SOFTRST_TDEBUS);
+
+	spin_lock_irqsave(&rstc->lock, flags);
+
+	regmap_read(rstc->regs, (id<HI3515_SOFTRST_TDEBUS) ? 0x0050 : 0x0058, &reg);
+	if(noinv)
+		ret = !!(reg&(1<<offset));
+	else
+		ret = !(reg&(1<<offset));
+
+	spin_unlock_irqrestore(&rstc->lock, flags);
+	
+	return ret;
+}
+
+static const struct reset_control_ops hi3515_reset_ops = {
+	.assert		= hi3515_reset_assert,
+	.deassert	= hi3515_reset_deassert,
+	.status		= hi3515_reset_status,
+};
+
+static int __init hi3515_clockctrl_probe(struct device_node *node) {
+	int ret;
+	const char *parent_name;
+	struct clk_hw_onecell_data *ctrl_clk;
+	struct regmap *regs;
+	struct clk_init_data* init;
+	struct hi3515_clockctrl_gate* gate;
+	struct clk_hw *chw;
+	struct hi3515_reset_controller *rstc;
+
+	ctrl_clk = kzalloc(struct_size(ctrl_clk, hws, HI3515_PER_CLK_CNT),
+			      GFP_KERNEL);
+	if (!ctrl_clk)
+		return -ENOMEM;
+	
+	ctrl_clk->num = HI3515_PER_CLK_CNT;
+
+	regs = syscon_regmap_lookup_by_compatible("hisilicon,hi3515sysctrl");
+	if(IS_ERR(regs))
+		return PTR_ERR(regs);
+	
+	for(int i = 0; i < HI3515_PER_CLK_CNT; i++) {
+		if(hi3515_clockctrl_clksinfo[i].rsvd)
+			continue;
+		gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+		if (!gate)
+			return -ENOMEM;
+		
+		init = kzalloc(sizeof(*init), GFP_KERNEL);
+		if (!init)
+			return -ENOMEM;
+		
+		init->name = hi3515_clockctrl_clksinfo[i].name;
+		init->ops = &hi3515_clockctrl_ops;
+		parent_name = of_clk_get_parent_name(node, 0);
+		init->parent_names = &parent_name;
+		init->num_parents = parent_name ? 1 : 0;
+		
+		gate->hw.init = init;
+		gate->regs = regs;
+		gate->idx = hi3515_clockctrl_clksinfo[i].idx;
+		
+		chw = &gate->hw;
+		
+		ret = of_clk_hw_register(node, chw);
+		if (ret) {
+			pr_err("failed to register %s clock\n", init->name);
+			return ret;
+		}
+		ctrl_clk->hws[hi3515_clockctrl_clksinfo[i].idx] = chw;
+	}
+	
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, ctrl_clk);
+	if(ret) {
+		pr_err("failed to register clock controller\n");
+		return ret;
+	}
+	
+	rstc = kzalloc(sizeof(*rstc), GFP_KERNEL);
+	if (!rstc)
+		return -ENOMEM;
+
+	rstc->regs = regs;
+
+	spin_lock_init(&rstc->lock);
+	rstc->rcdev.owner = THIS_MODULE;
+	rstc->rcdev.ops = &hi3515_reset_ops;
+	rstc->rcdev.of_node = node;
+	rstc->rcdev.of_reset_n_cells = 1;
+	rstc->rcdev.nr_resets = HI3515_SOFTRST_CNT;
+	
+	
+	ret = reset_controller_register(&rstc->rcdev);
+	if(ret) {
+		pr_err("failed to register reset controller\n");
+	}
+	
+	return ret;
+}
+
+CLK_OF_DECLARE(hi3515_clockctrl, "hisilicon,hi3515clockctl", hi3515_clockctrl_probe);
+
+//----------------------------------------------------------------------------------------------------------
+
+struct hi3515_mux_clk {
+	struct clk_hw hw;
+	struct regmap *regs;
+	int regnum;
+	u32 shift;
+	u32 mask;
+	int saved_parent;
+};
+
+#define to_hi3515_mux_clk(_hw) container_of((_hw), struct hi3515_mux_clk, hw)
+
+
+static u8 hi3515_clkmux_get_parent(struct clk_hw *hw)
+{
+	struct hi3515_mux_clk *mux = to_hi3515_mux_clk(hw);
+	u32 val;
+	
+	if(!regmap_read(mux->regs, mux->regnum, &val)) {
+		return (val & (mux->mask<<mux->shift))>>mux->shift;
+	} else {
+		return 0;
+	}
+}
+
+static int hi3515_clkmux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct hi3515_mux_clk *mux = to_hi3515_mux_clk(hw);
+	
+	regmap_write_bits(mux->regs, mux->regnum, (mux->mask << mux->shift), (index << mux->shift));
+
+	return 0;
+}
+
+static int hi3515_clkmux_save_context(struct clk_hw *hw)
+{
+	struct hi3515_mux_clk *mux = to_hi3515_mux_clk(hw);
+
+	mux->saved_parent = hi3515_clkmux_get_parent(hw);
+	return 0;
+}
+
+static void hi3515_clkmux_restore_context(struct clk_hw *hw)
+{
+	struct hi3515_mux_clk *mux = to_hi3515_mux_clk(hw);
+
+	hi3515_clkmux_set_parent(hw, mux->saved_parent);
+}
+
+
+const struct clk_ops hi3515_clkmux_ops = {
+	.get_parent = hi3515_clkmux_get_parent,
+	.set_parent = hi3515_clkmux_set_parent,
+	.determine_rate = __clk_mux_determine_rate,
+	.save_context = hi3515_clkmux_save_context,
+	.restore_context = hi3515_clkmux_restore_context,
+};
+
+static int __init hi3515_muxclk_probe(struct device_node *node)
+{
+	struct regmap *reg;
+	unsigned int num_parents;
+	const char **parent_names;
+	const char *name;
+	u32 mask = 0;
+	u32 shift = 0;
+	u32 regnum;
+	u32 defval;
+	u32 flags = CLK_SET_RATE_NO_REPARENT;
+	int ret;
+	struct hi3515_mux_clk *mux;
+	struct clk_init_data init;
+
+	num_parents = of_clk_get_parent_count(node);
+	if (num_parents < 2) {
+		pr_err("hi3515-mux-clock %pOFn must have parents\n", node);
+		return -EINVAL;
+	}
+	parent_names = kzalloc((sizeof(char *) * num_parents), GFP_KERNEL);
+	if (!parent_names)
+		return -ENOMEM;
+
+	of_clk_parent_fill(node, parent_names, num_parents);
+	
+	reg = syscon_regmap_lookup_by_compatible("hisilicon,hi3515sysctrl");
+
+	of_property_read_u32(node, "bit-shift", &shift);
+	of_property_read_u32(node, "regnum", &regnum);
+	
+	
+
+	/* Generate bit-mask based on parent info */
+	mask = num_parents;
+	mask--;
+
+	mask = (1 << fls(mask)) - 1;
+
+	name = node->name;
+	
+	/* allocate the mux */
+	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+	if (!mux)
+		return -ENOMEM;
+
+	init.name = name;
+	init.ops = &hi3515_clkmux_ops;
+	init.flags = flags;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
+	/* struct clk_mux assignments */
+	mux->regs = reg;
+	mux->regnum = regnum;
+	mux->shift = shift;
+	mux->mask = mask;
+	mux->saved_parent = 0;
+	mux->hw.init = &init;
+
+	ret = of_clk_hw_register(node, &mux->hw);
+	if (ret) {
+		// dev_err(dev, "failed to register %s clock\n", init.name);
+		return ret;
+	}
+	
+	if(!of_property_read_u32(node, "defval", &defval)) {
+		pr_info("HI3515 CLKMUX %s setting defval %d\n", name, defval);
+		// hi3515_clkmux_set_parent(&mux->hw, defval);
+		clk_hw_set_parent(&mux->hw, clk_hw_get_parent_by_index(&mux->hw, defval));
+	}
+	
+	pr_info("HI3515 CLKMUX %s initialized\n", name);
+
+	return of_clk_add_hw_provider(node, of_clk_hw_simple_get,
+					   &mux->hw);
+	
+}
+
+CLK_OF_DECLARE(hi3515_muxclk, "hisilicon,hi3515-mux-clock", hi3515_muxclk_probe);
diff --no-dereference -ruN linux-master/drivers/clk/hisilicon/Makefile linux-master-mod/drivers/clk/hisilicon/Makefile
--- linux-master/drivers/clk/hisilicon/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/clk/hisilicon/Makefile	2024-10-18 18:44:25.012066975 +0300
@@ -18,3 +18,4 @@
 obj-$(CONFIG_RESET_HISI)	+= reset.o
 obj-$(CONFIG_STUB_CLK_HI6220)	+= clk-hi6220-stub.o
 obj-$(CONFIG_STUB_CLK_HI3660)	+= clk-hi3660-stub.o
+obj-$(CONFIG_ARCH_HI3515V100)	+= clk-hi3515.o
diff --no-dereference -ruN linux-master/drivers/cpuidle/cpuidle-arm.c linux-master-mod/drivers/cpuidle/cpuidle-arm.c
--- linux-master/drivers/cpuidle/cpuidle-arm.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/cpuidle/cpuidle-arm.c	2024-11-23 17:58:03.876809207 +0300
@@ -116,7 +116,7 @@
 	 */
 	if (ret) {
 		if (ret != -EOPNOTSUPP)
-			pr_err("CPU %d failed to init idle CPU ops\n", cpu);
+			pr_err("CPU %d failed to init idle CPU ops: %d\n", cpu, ret);
 		ret = ret == -ENXIO ? 0 : ret;
 		goto out_kfree_drv;
 	}
diff --no-dereference -ruN linux-master/drivers/crypto/hisilicon/hi3515-crypto.c linux-master-mod/drivers/crypto/hisilicon/hi3515-crypto.c
--- linux-master/drivers/crypto/hisilicon/hi3515-crypto.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/crypto/hisilicon/hi3515-crypto.c	2024-10-25 21:01:16.405133319 +0300
@@ -0,0 +1,754 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+
+#include <linux/crypto.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include <crypto/algapi.h>
+#include <linux/kfifo.h>
+
+#include <linux/acpi.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-direction.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <crypto/aes.h>
+#include <crypto/algapi.h>
+#include <crypto/internal/des.h>
+#include <crypto/skcipher.h>
+#include <crypto/xts.h>
+#include <crypto/internal/skcipher.h>
+#include <crypto/engine.h>
+
+#include <crypto/engine.h>
+#include <crypto/internal/hash.h>
+#include <crypto/internal/skcipher.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+
+struct hi3515_crypto_hwdev {
+	void __iomem *regs;
+	struct device *dev;
+	struct skcipher_request* curr_req;
+	struct crypto_engine *engine;
+};
+
+enum hi3515_crypto_cipher_alg {
+	HI3515_C_DES_ECB_64,
+	HI3515_C_DES_CBC_64,
+
+	HI3515_C_3DES_ECB_192_3KEY,
+	HI3515_C_3DES_ECB_192_2KEY,
+
+	HI3515_C_3DES_CBC_192_3KEY,
+	HI3515_C_3DES_CBC_192_2KEY,
+
+	HI3515_C_AES_ECB_128,
+	HI3515_C_AES_ECB_192,
+	HI3515_C_AES_ECB_256,
+
+	HI3515_C_AES_CBC_128,
+	HI3515_C_AES_CBC_192,
+	HI3515_C_AES_CBC_256,
+
+	HI3515_C_AES_CTR_128,
+	HI3515_C_AES_CTR_192,
+	HI3515_C_AES_CTR_256,
+
+	HI3515_C_NULL,
+};
+
+struct hi3515_crypto_alg_tfm_ctx {
+	enum hi3515_crypto_cipher_alg cipher_alg;
+	char iv[AES_BLOCK_SIZE];
+	char key[AES_MAX_KEY_SIZE];
+	int keysize;
+	int ivsize;
+};
+
+struct hi3515_crypto_alg_req_ctx {
+	struct hi3515_crypto_hwdev* hwdev;
+	enum hi3515_crypto_cipher_alg cipher_alg;
+	bool encrypt;
+};
+
+//sorry for that, dear Satan
+struct hi3515_crypto_hwdev *_global_dev = NULL;
+
+static void hi3515_crypto_dump_regs(const char* fnname) {
+	pr_info("----CRYPTO DUMP IN FN %s----\n", fnname);
+	for(int i = 0; i <= 0x080; i+=4) {
+		pr_info("	reg 0x%x = 0x%x\n", i, readl(_global_dev->regs + i));
+	}
+	pr_info("---------------------------\n");
+}
+
+static int hi3515_crypto_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key, unsigned int keylen, enum hi3515_crypto_cipher_alg alg) {
+	struct hi3515_crypto_alg_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);
+	
+	ctx->cipher_alg = alg;
+	memcpy(ctx->key, key, keylen);
+	ctx->keysize = keylen;
+
+	return 0;
+}
+
+static int hi3515_crypto_skcipher_setkey_aes_ecb(struct crypto_skcipher *tfm, const u8 *key, unsigned int keylen) {
+	enum hi3515_crypto_cipher_alg alg;
+
+	switch (keylen) {
+		case AES_KEYSIZE_128:
+			alg = HI3515_C_AES_ECB_128;
+			break;
+		case AES_KEYSIZE_192:
+			alg = HI3515_C_AES_ECB_192;
+			break;
+		case AES_KEYSIZE_256:
+			alg = HI3515_C_AES_ECB_256;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return hi3515_crypto_skcipher_setkey(tfm, key, keylen, alg);
+}
+
+static int hi3515_crypto_skcipher_setkey_aes_cbc(struct crypto_skcipher *tfm, const u8 *key, unsigned int keylen) {
+	enum hi3515_crypto_cipher_alg alg;
+
+	switch (keylen) {
+		case AES_KEYSIZE_128:
+			alg = HI3515_C_AES_CBC_128;
+			break;
+		case AES_KEYSIZE_192:
+			alg = HI3515_C_AES_CBC_192;
+			break;
+		case AES_KEYSIZE_256:
+			alg = HI3515_C_AES_CBC_256;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return hi3515_crypto_skcipher_setkey(tfm, key, keylen, alg);
+}
+
+static int hi3515_crypto_skcipher_setkey_aes_ctr(struct crypto_skcipher *tfm, const u8 *key, unsigned int keylen) {
+	enum hi3515_crypto_cipher_alg alg;
+
+	switch (keylen) {
+		case AES_KEYSIZE_128:
+			alg = HI3515_C_AES_CTR_128;
+			break;
+		case AES_KEYSIZE_192:
+			alg = HI3515_C_AES_CTR_192;
+			break;
+		case AES_KEYSIZE_256:
+			alg = HI3515_C_AES_CTR_256;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return hi3515_crypto_skcipher_setkey(tfm, key, keylen, alg);
+}
+
+static int hi3515_crypto_skcipher_setkey_des_ecb(struct crypto_skcipher *tfm,const u8 *key, unsigned int keylen)
+{
+	return verify_skcipher_des_key(tfm, key) ?:
+	       hi3515_crypto_skcipher_setkey(tfm, key, keylen, HI3515_C_DES_ECB_64);
+}
+
+static int hi3515_crypto_skcipher_setkey_des_cbc(struct crypto_skcipher *tfm,const u8 *key, unsigned int keylen)
+{
+	return verify_skcipher_des_key(tfm, key) ?:
+	       hi3515_crypto_skcipher_setkey(tfm, key, keylen, HI3515_C_DES_CBC_64);
+}
+
+static int hi3515_crypto_skcipher_setkey_3des_ecb(struct crypto_skcipher *tfm,const u8 *key, unsigned int keylen)
+{
+	return verify_skcipher_des3_key(tfm, key) ?:
+	       hi3515_crypto_skcipher_setkey(tfm, key, keylen,
+				       HI3515_C_3DES_ECB_192_3KEY);
+}
+
+static int hi3515_crypto_skcipher_setkey_3des_cbc(struct crypto_skcipher *tfm,const u8 *key, unsigned int keylen) {
+	return verify_skcipher_des3_key(tfm, key) ?:
+	       hi3515_crypto_skcipher_setkey(tfm, key, keylen,
+				       HI3515_C_3DES_CBC_192_3KEY);
+}
+
+static DEFINE_SPINLOCK(hi3515_crypto_lock);
+
+static void hi3515_crypto_skcipher_process_block(struct hi3515_crypto_hwdev* hwdev, const void *src, void *dst, int len, u8 *iv, int ivsize) {
+	u32 counter = 0x100;
+
+	for(int i = 0; i < len && i <= 12; i+=4) {
+		writel(((u32*)src)[i/4], hwdev->regs + 0x000 + i);
+
+	}
+	
+	for(int i = 0; i < ivsize && i <= 12; i+=4) {
+		writel(((u32*)iv)[i/4], hwdev->regs + 0x010 + i);
+		// pr_info("HI3515 CRYPTO: LOADED IV %d/%d TO REG 0x%x: 0x%x\n", i, ivsize, 0x010 + i, readl(hwdev->regs + 0x010 + i));
+	}
+	
+	writel(1, hwdev->regs + 0x06C);
+	
+	//wait for operation to complete
+	while(readl(hwdev->regs + 0x068) && --counter) {
+		cpu_relax();
+	}
+	
+	BUG_ON(!counter);
+	
+	for(int i = 0; i < len && i <= 12; i+=4) {
+		((u32*)dst)[i/4] = readl(hwdev->regs + 0x040 + i);
+	}
+	
+	for(int i = 0; i < ivsize && i <= 12; i+=4) {
+		((u32*)iv)[i/4] = readl(hwdev->regs + 0x050 + i);
+	}
+	
+}
+
+static int hi3515_crypto_skcipher_process_blocks(struct hi3515_crypto_hwdev* hwdev, const void *src, void *dst, u8 *iv, u8* key, int len, int keysize, int ivsize, enum hi3515_crypto_cipher_alg alg_mode, bool encrypt) {
+	int ret;
+	u32 keyword;
+	u8 mode, keylen, algsel,blksz;
+	unsigned long iflags;
+	int ptr = 0;
+	
+	// pr_info("PROCESSING BLOCK LEN %d: ", len);
+	// for(int i = 0; i < len; i++) {
+	// 	printk(KERN_CONT "%x ", ((u8*)src)[i]);
+	// }
+	
+	switch(alg_mode) {
+		case HI3515_C_DES_ECB_64:
+			mode = 0b000;
+			keylen = 0b11;
+			algsel = 0b00;
+			blksz = 8;
+			break;
+		case HI3515_C_DES_CBC_64:
+			mode = 0b001;
+			keylen = 0b11;
+			algsel = 0b00;
+			blksz = 8;
+			break;
+		case HI3515_C_3DES_ECB_192_3KEY:
+			mode = 0b000;
+			keylen = 0b00;
+			algsel = 0b01;
+			blksz = 8;
+			break;
+		case HI3515_C_3DES_ECB_192_2KEY:
+			mode = 0b000;
+			keylen = 0b11;
+			algsel = 0b01;
+			blksz = 8;
+			break;
+		case HI3515_C_3DES_CBC_192_3KEY:
+			mode = 0b001;
+			keylen = 0b00;
+			algsel = 0b01;
+			blksz = 8;
+			break;
+		case HI3515_C_3DES_CBC_192_2KEY:
+			mode = 0b001;
+			keylen = 0b11;
+			algsel = 0b01;
+			blksz = 8;
+			break;
+		case HI3515_C_AES_ECB_128:
+			mode = 0b000;
+			keylen = 0b00;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_ECB_192:
+			mode = 0b000;
+			keylen = 0b01;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_ECB_256:
+			mode = 0b000;
+			keylen = 0b10;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_CBC_128:
+			mode = 0b001;
+			keylen = 0b00;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_CBC_192:
+			mode = 0b001;
+			keylen = 0b01;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_CBC_256:
+			mode = 0b001;
+			keylen = 0b10;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_CTR_128:
+			mode = 0b100;
+			keylen = 0b00;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_CTR_192:
+			mode = 0b100;
+			keylen = 0b01;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		case HI3515_C_AES_CTR_256:
+			mode = 0b100;
+			keylen = 0b10;
+			algsel = 0b10;
+			blksz = 16;
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	spin_lock_irqsave(&hi3515_crypto_lock, iflags);
+	
+	while(readl(hwdev->regs + 0x068)&0b1);
+	
+	writel( ((!encrypt)<<0) | (mode<<1) | (0b00<<4) | (keylen<<6) | (algsel<<8) | ((ivsize != 0)<<10) | (0<<11) | (0<<12) | (1<<13) | (0<<14), 
+			hwdev->regs + 0x060);
+
+	for(int i = 0; i < keysize && i <= 28; i+=4) {
+		keyword = ((u32*)key)[i/4];
+		writel(keyword, hwdev->regs + 0x020 + i);
+	}
+
+	while(ptr+blksz <= len) {
+		while(readl(hwdev->regs + 0x068)&0b1);
+		
+		hi3515_crypto_skcipher_process_block(hwdev, &(((u8*)src)[ptr]), &(((u8*)dst)[ptr]), blksz, iv, ivsize);
+		
+		ptr+=blksz;
+	}
+	
+	spin_unlock_irqrestore(&hi3515_crypto_lock, iflags);
+	
+	// pr_info("PROCESSED BLOCK LEN %d: ", len);
+	// for(int i = 0; i < len; i++) {
+	// 	printk(KERN_CONT "%x ", ((u8*)dst)[i]);
+	// }
+	
+	return len-ptr;
+	
+}
+
+static int hi3515_cipher_run(struct crypto_engine *engine, void *async_req) {
+	struct skcipher_request *req = container_of(async_req, struct skcipher_request, base);
+	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
+	struct hi3515_crypto_alg_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);
+	struct hi3515_crypto_alg_req_ctx *reqctx = skcipher_request_ctx(req);
+	
+	unsigned int nbytes;
+	int err;
+	struct skcipher_walk walk;
+	
+	
+	err = skcipher_walk_virt(&walk, req, false);
+
+	// pr_info("WALK START");
+	while ((nbytes = walk.nbytes) != 0) {
+		// pr_info("SZ PROC %d", nbytes);
+		err = hi3515_crypto_skcipher_process_blocks(reqctx->hwdev, walk.src.virt.addr, walk.dst.virt.addr, walk.iv, ctx->key, nbytes, ctx->keysize, crypto_skcipher_ivsize(tfm), reqctx->cipher_alg, reqctx->encrypt);
+		// pr_info("RETA %d", err);
+		err = skcipher_walk_done(&walk, err);
+		// pr_info("RETB %d", err);
+	}
+	// pr_info("WALK STOP %d", err);
+	
+	crypto_finalize_skcipher_request(reqctx->hwdev->engine, req, err);
+	
+	return err;
+	
+	
+}
+
+static int hi3515_crypto_skcipher_encrypt(struct skcipher_request *req) {
+	struct hi3515_crypto_alg_req_ctx* reqctx = skcipher_request_ctx(req);
+	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
+	struct hi3515_crypto_alg_tfm_ctx *ctx = crypto_skcipher_ctx(cipher);
+	struct hi3515_crypto_hwdev *hwdev;
+	
+	reqctx->cipher_alg = ctx->cipher_alg;
+
+	if(!_global_dev) {
+		pr_err("HI3515 CRYPTO: GLOBAL DEV NULL\n");
+		return -EINVAL;
+	}
+
+	hwdev = _global_dev;
+	
+	reqctx->hwdev = hwdev;
+	reqctx->encrypt = true;
+
+	return crypto_transfer_skcipher_request_to_engine(hwdev->engine, req);
+	
+}
+
+static int hi3515_crypto_skcipher_decrypt(struct skcipher_request *req) {
+	struct hi3515_crypto_alg_req_ctx* reqctx = skcipher_request_ctx(req);
+	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
+	struct hi3515_crypto_alg_tfm_ctx *ctx = crypto_skcipher_ctx(cipher);
+	struct hi3515_crypto_hwdev *hwdev;
+	
+	reqctx->cipher_alg = ctx->cipher_alg;
+
+	if(!_global_dev) {
+		pr_err("HI3515 CRYPTO: GLOBAL DEV NULL\n");
+		return -EINVAL;
+	}
+
+	hwdev = _global_dev;
+	
+	reqctx->hwdev = hwdev;
+	reqctx->encrypt = false;
+
+	return crypto_transfer_skcipher_request_to_engine(hwdev->engine, req);
+}
+
+static int hi3515_crypto_skcipher_init(struct crypto_skcipher *tfm) {
+	struct hi3515_crypto_alg_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	int ret;
+	
+	if(_global_dev == NULL) {
+		pr_err("HI3515 CRYPTO INIT: GLOBAL DEV NULL!\n");
+		return -EINVAL;
+	}
+	
+	ctx->ivsize = 0;
+	ctx->keysize = 0;
+
+	crypto_skcipher_set_reqsize(tfm, sizeof(struct hi3515_crypto_alg_req_ctx));
+
+	return 0;
+}
+
+static void hi3515_crypto_skcipher_exit(struct crypto_skcipher *tfm) {
+	struct hi3515_crypto_alg_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	memzero_explicit(ctx->key, ctx->keysize);
+}
+
+
+static struct skcipher_engine_alg hi3515_crypto_algs[] = {
+	{
+		.base = {
+			.base = {
+				.cra_name = "ecb(aes)",
+				.cra_driver_name = "hi3515_crypto_aes_ecb",
+				.cra_priority = 4001,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_ALLOCATES_MEMORY,
+				.cra_blocksize = AES_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+				.cra_alignmask = 0,
+				.cra_module = THIS_MODULE,
+			},
+			.init = hi3515_crypto_skcipher_init,
+			.exit = hi3515_crypto_skcipher_exit,
+			.setkey = hi3515_crypto_skcipher_setkey_aes_ecb,
+			.decrypt = hi3515_crypto_skcipher_decrypt,
+			.encrypt = hi3515_crypto_skcipher_encrypt,
+			.min_keysize = 16,
+			.max_keysize = 32,
+			.ivsize = 0,
+		},
+		.op = {
+			.do_one_request = hi3515_cipher_run,
+		},
+	}, 
+	{
+		.base = {
+			.base = {
+				.cra_name = "cbc(aes)",
+				.cra_driver_name = "hi3515_crypto_aes_cbc",
+				.cra_priority = 4001,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_ALLOCATES_MEMORY,
+				.cra_blocksize = AES_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+				.cra_alignmask = 0,
+				.cra_module = THIS_MODULE,
+			},
+			.init = hi3515_crypto_skcipher_init,
+			.exit = hi3515_crypto_skcipher_exit,
+			.setkey = hi3515_crypto_skcipher_setkey_aes_cbc,
+			.decrypt = hi3515_crypto_skcipher_decrypt,
+			.encrypt = hi3515_crypto_skcipher_encrypt,
+			.min_keysize = 16,
+			.max_keysize = 32,
+			.ivsize = AES_BLOCK_SIZE,
+		},
+		.op = {
+			.do_one_request = hi3515_cipher_run,
+		},
+	}, 
+	// {
+	// 	.base = {
+	// 		.base = {
+	// 			.cra_name = "ctr(aes)",
+	// 			.cra_driver_name = "hi3515_crypto_aes_ctr",
+	// 			.cra_priority = 4001,
+	// 			.cra_flags = CRYPTO_ALG_ASYNC |
+	// 				CRYPTO_ALG_ALLOCATES_MEMORY,
+	// 			.cra_blocksize = AES_BLOCK_SIZE,
+	// 			.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+	// 			.cra_alignmask = 0,
+	// 			.cra_module = THIS_MODULE,
+	// 		},
+	// 		.init = hi3515_crypto_skcipher_init,
+	// 		.exit = hi3515_crypto_skcipher_exit,
+	// 		.setkey = hi3515_crypto_skcipher_setkey_aes_ctr,
+	// 		.decrypt = hi3515_crypto_skcipher_decrypt,
+	// 		.encrypt = hi3515_crypto_skcipher_encrypt,
+	// 		.min_keysize = 16,
+	// 		.max_keysize = 32,
+	// 		.ivsize = AES_BLOCK_SIZE,
+	// 	},
+	// 	.op = {
+	// 		.do_one_request = hi3515_cipher_run,
+	// 	},
+	// }, 
+	{
+		.base = {
+			.base = {
+				.cra_name = "ecb(des)",
+				.cra_driver_name = "hi3515_crypto_des_ecb",
+				.cra_priority = 4001,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_ALLOCATES_MEMORY,
+				.cra_blocksize = DES_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+				.cra_alignmask = 0,
+				.cra_module = THIS_MODULE,
+			},
+			.init = hi3515_crypto_skcipher_init,
+			.exit = hi3515_crypto_skcipher_exit,
+			.setkey = hi3515_crypto_skcipher_setkey_des_ecb,
+			.decrypt = hi3515_crypto_skcipher_decrypt,
+			.encrypt = hi3515_crypto_skcipher_encrypt,
+			.min_keysize = DES_KEY_SIZE,
+			.max_keysize = DES_KEY_SIZE,
+			.ivsize = 0,
+		},
+		.op = {
+			.do_one_request = hi3515_cipher_run,
+		},
+	}, 
+	{
+		.base = {
+			.base = {
+				.cra_name = "cbc(des)",
+				.cra_driver_name = "hi3515_crypto_des_cbc",
+				.cra_priority = 4001,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_ALLOCATES_MEMORY,
+				.cra_blocksize = DES_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+				.cra_alignmask = 0,
+				.cra_module = THIS_MODULE,
+			},
+			.init = hi3515_crypto_skcipher_init,
+			.exit = hi3515_crypto_skcipher_exit,
+			.setkey = hi3515_crypto_skcipher_setkey_des_cbc,
+			.decrypt = hi3515_crypto_skcipher_decrypt,
+			.encrypt = hi3515_crypto_skcipher_encrypt,
+			.min_keysize = DES_KEY_SIZE,
+			.max_keysize = DES_KEY_SIZE,
+			.ivsize = DES_BLOCK_SIZE,
+		},
+		.op = {
+			.do_one_request = hi3515_cipher_run,
+		},
+	}, 
+	{
+		.base = {
+			.base = {
+				.cra_name = "ecb(des3_ede)",
+				.cra_driver_name = "hi3515_crypto_3des_ecb",
+				.cra_priority = 4001,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_ALLOCATES_MEMORY,
+				.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+				.cra_alignmask = 0,
+				.cra_module = THIS_MODULE,
+			},
+			.init = hi3515_crypto_skcipher_init,
+			.exit = hi3515_crypto_skcipher_exit,
+			.setkey = hi3515_crypto_skcipher_setkey_3des_ecb,
+			.decrypt = hi3515_crypto_skcipher_decrypt,
+			.encrypt = hi3515_crypto_skcipher_encrypt,
+			.min_keysize = DES3_EDE_KEY_SIZE,
+			.max_keysize = DES3_EDE_KEY_SIZE,
+			.ivsize = 0,
+		},
+		.op = {
+			.do_one_request = hi3515_cipher_run,
+		},
+	}, 
+	{
+		.base = {
+			.base = {
+				.cra_name = "cbc(des3_ede)",
+				.cra_driver_name = "hi3515_crypto_3des_cbc",
+				.cra_priority = 4001,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_ALLOCATES_MEMORY,
+				.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct hi3515_crypto_alg_tfm_ctx),
+				.cra_alignmask = 0,
+				.cra_module = THIS_MODULE,
+			},
+			.init = hi3515_crypto_skcipher_init,
+			.exit = hi3515_crypto_skcipher_exit,
+			.setkey = hi3515_crypto_skcipher_setkey_3des_cbc,
+			.decrypt = hi3515_crypto_skcipher_decrypt,
+			.encrypt = hi3515_crypto_skcipher_encrypt,
+			.min_keysize = DES3_EDE_KEY_SIZE,
+			.max_keysize = DES3_EDE_KEY_SIZE,
+			.ivsize = DES3_EDE_BLOCK_SIZE,
+		},
+		.op = {
+			.do_one_request = hi3515_cipher_run,
+		},
+	}
+};
+
+static int hi3515_crypto_probe(struct platform_device *pdev) {
+	struct device *dev = &pdev->dev;
+	struct hi3515_crypto_hwdev* hwdev;
+	struct clk* clock;
+	struct reset_control* rst;
+	int i, j;
+	int irq;
+	int ret;
+	
+	if(_global_dev != NULL){
+		dev_err(dev, "ATTEMPT TO INIT MORE THAN ONE HI3515 CRYPTO!");
+		return -EINVAL;
+	}
+	
+	hwdev = devm_kzalloc(dev, sizeof(*hwdev), GFP_KERNEL);
+	if (IS_ERR(hwdev))
+		return PTR_ERR(hwdev);
+	
+	hwdev->dev = dev;
+	
+	clock = devm_clk_get(dev, "apb_pclk");
+	if(!IS_ERR(clock)) {
+		clk_prepare_enable(clock);
+	} else {
+		dev_err(dev, "NO VALID CLOCK SPECIFIED!");
+		return PTR_ERR(clock);
+	}
+	
+	rst = devm_reset_control_array_get_exclusive(dev);
+	if (IS_ERR(rst)) {
+		dev_err(dev, "NO VALID RST SPECIFIED!");
+		return PTR_ERR(rst);
+	}
+
+	reset_control_assert(rst);
+	usleep_range(10, 20);
+	reset_control_deassert(rst);
+	
+	
+	hwdev->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(hwdev->regs))
+		return PTR_ERR(hwdev->regs);
+	
+	writel(0b11, hwdev->regs + 0x07C); //mask interrupts
+	
+	hwdev->curr_req = NULL;
+	
+	hwdev->engine = crypto_engine_alloc_init(dev, true);
+	if (!hwdev->engine) {
+		return -ENOMEM;
+	}
+
+	crypto_engine_start(hwdev->engine);
+	
+	_global_dev = hwdev;
+
+	ret = crypto_engine_register_skciphers(hi3515_crypto_algs, ARRAY_SIZE(hi3515_crypto_algs));
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void hi3515_crypto_remove(struct platform_device *pdev) {
+	crypto_engine_unregister_skciphers(hi3515_crypto_algs, ARRAY_SIZE(hi3515_crypto_algs));
+	if(_global_dev) {
+		crypto_engine_exit(_global_dev->engine);
+		_global_dev = NULL;
+	}
+}
+
+static const __maybe_unused struct of_device_id hi3515_crypto_match[] = {
+	{ .compatible = "hisilicon,hi3515cipher" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, hi3515_crypto_match);
+
+static struct platform_driver hi3515_crypto_driver = {
+	.probe = hi3515_crypto_probe,
+	.remove_new = hi3515_crypto_remove,
+	.driver = {
+		.name = "hi3515_crypto_platform_driver",
+		.of_match_table = hi3515_crypto_match,
+	},
+};
+
+module_platform_driver(hi3515_crypto_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("HiSilicon HI3515 Security Accelerators");
+MODULE_AUTHOR("Indir Wolf");
diff --no-dereference -ruN linux-master/drivers/crypto/hisilicon/Makefile linux-master-mod/drivers/crypto/hisilicon/Makefile
--- linux-master/drivers/crypto/hisilicon/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/crypto/hisilicon/Makefile	2024-10-21 16:32:32.493003704 +0300
@@ -6,3 +6,4 @@
 hisi_qm-objs = qm.o sgl.o debugfs.o
 obj-$(CONFIG_CRYPTO_DEV_HISI_ZIP) += zip/
 obj-$(CONFIG_CRYPTO_DEV_HISI_TRNG) += trng/
+obj-$(CONFIG_ARCH_HI3515V100) += hi3515-crypto.o
diff --no-dereference -ruN linux-master/drivers/dma/amba-pl08x.c linux-master-mod/drivers/dma/amba-pl08x.c
--- linux-master/drivers/dma/amba-pl08x.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/dma/amba-pl08x.c	2024-11-09 14:07:38.894496381 +0300
@@ -90,6 +90,13 @@
 	BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
 	BIT(DMA_SLAVE_BUSWIDTH_4_BYTES)
 
+// #undef dev_dbg
+// #undef dev_vdbg
+// 	
+// #define dev_dbg dev_info
+// 
+// #define dev_vdbg dev_info
+	
 static struct amba_driver pl08x_amba_driver;
 struct pl08x_driver_data;
 
@@ -2306,6 +2313,8 @@
 			struct pl08x_phy_chan *phychan = &pl08x->phy_chans[i];
 			struct pl08x_dma_chan *plchan = phychan->serving;
 			struct pl08x_txd *tx;
+			
+			// dev_dbg(&pl08x->adev->dev, "TCI0x%x\n", i);
 
 			if (!plchan) {
 				dev_err(&pl08x->adev->dev,
@@ -2762,7 +2771,8 @@
 	pl08x->memcpy.src_addr_widths = PL80X_DMA_BUSWIDTHS;
 	pl08x->memcpy.dst_addr_widths = PL80X_DMA_BUSWIDTHS;
 	pl08x->memcpy.directions = BIT(DMA_MEM_TO_MEM);
-	pl08x->memcpy.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;
+	// pl08x->memcpy.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;
+	pl08x->slave.residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR;
 	if (vd->ftdmac020)
 		pl08x->memcpy.copy_align = DMAENGINE_ALIGN_4_BYTES;
 
@@ -2791,8 +2801,9 @@
 		pl08x->slave.dst_addr_widths = PL80X_DMA_BUSWIDTHS;
 		pl08x->slave.directions =
 			BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
-		pl08x->slave.residue_granularity =
-			DMA_RESIDUE_GRANULARITY_SEGMENT;
+		// pl08x->slave.residue_granularity =
+			// DMA_RESIDUE_GRANULARITY_SEGMENT;
+		pl08x->slave.residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR;
 	}
 
 	/* Get the platform data */
@@ -2845,6 +2856,10 @@
 	else
 		writel(0x000000FF, pl08x->base + PL080_ERR_CLEAR);
 	writel(0x000000FF, pl08x->base + PL080_TC_CLEAR);
+	
+	dev_dbg(&adev->dev, "SYNCREG BEFORE: 0x%x\n", readl(pl08x->base + PL080_SYNC));
+	writel(0xff, pl08x->base + PL080_SYNC);
+	dev_dbg(&adev->dev, "SYNCREG AFTER: 0x%x\n", readl(pl08x->base + PL080_SYNC));
 
 	/* Attach the interrupt handler */
 	ret = request_irq(adev->irq[0], pl08x_irq, 0, DRIVER_NAME, pl08x);
@@ -3023,7 +3038,11 @@
 	{
 		.id	= 0x0a141080,
 		.mask	= 0xffffffff,
+#ifndef CONFIG_ARCH_HI3515V100
 		.data	= &vendor_pl080s,
+#else
+		.data	= &vendor_pl080,
+#endif
 	},
 	/* PL080 */
 	{
diff --no-dereference -ruN linux-master/drivers/dma/hi3515-dmac.c linux-master-mod/drivers/dma/hi3515-dmac.c
--- linux-master/drivers/dma/hi3515-dmac.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/dma/hi3515-dmac.c	2024-10-20 20:38:16.220722428 +0300
@@ -0,0 +1,571 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Copyright(c) 2024 Indir Wolf */
+
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/of_platform.h>
+
+#include <dt-bindings/clock/hi3515-clock.h>
+
+struct hi3515_dmac_dev {
+	struct device *dev;
+	struct dma_device dma_device;
+	void __iomem *regs;
+	// struct virt_dma_chan *chans;
+	struct hi3515_dmac_chan* chans;
+};
+
+struct hi3515_dmac_desc {
+	u32 src_addr;
+	u32 dst_addr;
+	u32 nxt_desc;
+	u32 ctrl_reg;
+};
+
+struct hi3515_dmac_chan {
+	struct dma_chan chan;
+	struct dma_async_tx_descriptor	desc;
+	int hw_req_line;
+	int chan_num;
+	int desc_num;
+	enum dma_transfer_direction dir;
+	struct hi3515_dmac_dev* dev;
+	enum dma_status status;
+	hi3515_dmac_desc *phys_desc;
+	dma_addr_t phys_desc_phys_addr;
+	struct dma_slave_config slave_cfg;
+};
+
+#define to_hi3515_dmac_chan(_chan) container_of((_chan), struct hi3515_dmac_chan, chan)
+
+static dma_cookie_t hi3515_dmac_tx_submit(struct dma_async_tx_descriptor *tx) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(tx->chan);
+
+	writel(dchan->phys_desc->src_addr , dchan->dev->regs + 0x100 + (dchan->chan_num * 0x20));
+	writel(dchan->phys_desc->dst_addr , dchan->dev->regs + 0x104 + (dchan->chan_num * 0x20));
+	writel(dchan->phys_desc->nxt_desc , dchan->dev->regs + 0x108 + (dchan->chan_num * 0x20));
+	writel(dchan->phys_desc->ctrl_reg , dchan->dev->regs + 0x10C + (dchan->chan_num * 0x20));
+
+	return 0;
+}
+
+int hi3515_dmac_alloc_chan_res(struct dma_chan *chan) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	int ret;
+
+	dma_async_tx_descriptor_init(&dchan->desc, chan);
+	dchan->desc.tx_submit = hi3515_dmac_tx_submit;
+
+	return 1;
+}
+
+void hi3515_dmac_free_chan_res(struct dma_chan *chan) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	int size = dchan->desc_num * sizeof(struct hi3515_dmac_desc);
+
+	if (dchan->phys_desc) {
+		dma_unmap_single(dchan->dev->dev, dchan->phys_desc_phys_addr, size, (dchan->dir == DMA_MEM_TO_DEV) ? DMA_TO_DEVICE : ((dchan->dir == DMA_DEV_TO_MEM) ? DMA_FROM_DEVICE : DMA_BIDIRECTIONAL));
+		// gen_pool_free(gpool, (unsigned long)tdmac->desc_arr,
+				// size);
+		kfree(dchan->phys_desc);
+	}
+	dchan->phys_desc = NULL;
+	if (dchan->status == DMA_ERROR)
+		dchan->status = DMA_COMPLETE;
+}
+
+static int hi3515_dmac_alloc_descriptor(struct hi3515_dmac_chan *dchan) {
+	struct hi3515_dmac_desc* descrs;
+	int size = dchan->desc_num * sizeof(struct hi3515_dmac_desc);
+	
+	descrs = kzalloc(size, GFP_DMA | GFP_NOWAIT);
+	if(!descrs) {
+		pr_err("DMA DESCRS ALLOC FAILED %d\n", descrs);
+		return -ENOMEM;
+	}
+	
+	dchan->phys_desc = descrs;
+	dchan->phys_desc_phys_addr = dma_map_single(dchan->dev->dev, descrs, size, (dchan->dir == DMA_MEM_TO_DEV) ? DMA_TO_DEVICE : ((dchan->dir == DMA_DEV_TO_MEM) ? DMA_FROM_DEVICE : DMA_BIDIRECTIONAL));
+	if(!dchan->phys_desc_phys_addr) {
+		pr_err("DMA PHYS DESCRS ALLOC FAILED %d\n", dchan->phys_desc_phys_addr);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static int hi3515_dmac_config_write(struct hi3515_dmac_chan *dchan, enum dma_transfer_direction direction) {
+	u32 maxburst = 0, addr = 0;
+	u32 buswidth_raw, maxburst_raw;
+	enum dma_slave_buswidth width;
+	bool tomem = false;
+
+	switch (direction) {
+		case DMA_DEV_TO_MEM:
+			maxburst = dchan->slace_cfg.src_maxburst;
+			width = dchan->slace_cfg.src_addr_width;
+			addr = dchan->slace_cfg.src_addr;
+			tomem = true;
+			break;
+
+		case DMA_MEM_TO_DEV:
+			maxburst = dchan->slace_cfg.dst_maxburst;
+			width = dchan->slace_cfg.dst_addr_width;
+			addr = dchan->slace_cfg.dst_addr;
+			tomem = false;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	switch (width) {
+		case DMA_SLAVE_BUSWIDTH_1_BYTE:
+			buswidth_raw = 0b000;
+			break;
+
+		case DMA_SLAVE_BUSWIDTH_2_BYTES:
+			buswidth_raw = 0b001;
+			break;
+		
+		case DMA_SLAVE_BUSWIDTH_4_BYTES:
+			buswidth_raw = 0b010;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	
+	switch (maxburst) {
+		case 0:
+		case 1:
+			maxburst_raw = 0b000;
+			break;
+		case 4:
+			maxburst_raw = 0b001;
+			break;
+		case 8:
+			maxburst_raw = 0b010;
+			break;
+		case 16:
+			maxburst_raw = 0b011;
+			break;
+		case 32:
+			maxburst_raw = 0b100;
+			break;
+		case 64:
+			maxburst_raw = 0b101;
+			break;
+		case 128:
+			maxburst_raw = 0b110;
+			break;
+		case 256:
+			maxburst_raw = 0b111;
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	
+	for(int i = 0; i < dchan->desc_num; i++) {
+		dchan->phys_desc[i].ctrl_reg |= (
+			(maxburst) << 12 |
+			(maxburst) << 15 |
+			(tomem ? buswidth_raw : 0) << 18 |
+			(tomem ? 0 : buswidth_raw) << 21
+		);
+	}
+
+	return 0;
+}
+
+
+struct dma_async_tx_descriptor* hi3515_dmac_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dst, dma_addr_t src, size_t len, unsigned long flags) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	
+	if (dchan->status != DMA_COMPLETE) {
+		pr_err("DMA channel %d busy\n", dchan->chan_num);
+		return NULL;
+	}
+	
+	if(len > 0xFFF) {
+		return NULL;
+	}
+	
+	dchan->dir = DMA_MEM_TO_MEM;
+	dchan->desc_num = 1;
+	
+	if(hi3515_dmac_alloc_descriptor(dchan)) {
+		dchan->status = DMA_ERROR;
+		return NULL;
+	}
+	
+	dchan->phys_desc[0].src_addr = src;
+	dchan->phys_desc[0].dst_addr = dst;
+	dchan->phys_desc[0].nxt_desc = 0;
+	dchan->phys_desc[0].ctrl_reg = len | (0b000 << 12) | (0b000 << 15) | (0b000 << 18) | (0b000 << 21) | (1 << 24) | (1 << 25) | (1 << 26) | (1 << 27) | (0b000 << 28) | (1 << 31);
+	
+	dchan->status = DMA_IN_PROGRESS;
+	
+	dchan->hw_req_line = 0;
+	
+	return &dchan->desc;
+}
+
+struct dma_async_tx_descriptor* hi3515_dmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len, enum dma_transfer_direction direction, unsigned long flags, void *context) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	
+	if (dchan->status != DMA_COMPLETE) {
+		pr_err("DMA channel %d busy\n", dchan->chan_num);
+		return NULL;
+	}
+	
+	for(int i = 0; i < sg_len; i++) {
+		if(sg_dma_len(sgl[i]) > 0xFFF) {
+			return NULL;
+		}
+	}
+	
+	dchan->desc_num = sg_len;
+	dchan->dir = direction;
+	
+	if(hi3515_dmac_alloc_descriptor(dchan)) {
+		dchan->status = DMA_ERROR;
+		return NULL;
+	}
+	
+	if(hi3515_dmac_config_write(dchan, direction)) {
+		dchan->status = DMA_ERROR;
+		return NULL;
+	}
+	
+	for_each_sg(sgl, sg, sg_len, i) {
+		struct hi3515_dmac_desc* desc = &dchan->phys_desc[i];
+		desc->nxt_desc = (i==sg_len-1) ? 0 : (dchan->phys_desc_phys_addr + sizeof(struct hi3515_dmac_desc)*i);
+		if (direction == DMA_MEM_TO_DEV)
+			desc->src_addr = sg_dma_address(sg);
+		else
+			desc->dst_addr = sg_dma_address(sg);
+		desc->ctrl_reg = sg_dma_len(sg) | (0b000 << 12) | (0b000 << 15) | (0b000 << 18) | (0b000 << 21) | ((direction == DMA_MEM_TO_DEV) << 24) | ((direction != DMA_MEM_TO_DEV) << 25) | ((direction == DMA_MEM_TO_DEV) << 26) | ((direction != DMA_MEM_TO_DEV) << 27) | (0b000 << 28) | ((desc->nxt_desc == 0) << 31);
+	}
+	
+	dchan->status = DMA_IN_PROGRESS;
+	
+	return &dchan->desc;
+}
+
+struct dma_async_tx_descriptor* hi3515_dmac_prep_dma_cyclic(struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len, size_t period_len, enum dma_transfer_direction direction, unsigned long flags) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	int sg_len;
+	
+	if (dchan->status != DMA_COMPLETE) {
+		pr_err("DMA channel %d busy\n", dchan->chan_num);
+		return NULL;
+	}
+	
+	/* the buffer length must be a multiple of period_len */
+	if (buf_len % period_len != 0) {
+		pr_err("DMA len is not multiple of period\n");
+		return NULL;
+	}
+	
+	sg_len = buf_len / period_len;
+	
+	if(period_len > 0xFFF) {
+		return NULL;
+	}
+	
+	dchan->desc_num = sg_len;
+	dchan->dir = direction;
+	
+	if(hi3515_dmac_alloc_descriptor(dchan)) {
+		dchan->status = DMA_ERROR;
+		return NULL;
+	}
+	
+	if(hi3515_dmac_config_write(dchan, direction)) {
+		dchan->status = DMA_ERROR;
+		return NULL;
+	}
+	
+	for (int i = 0; i < sg_len; i++) {
+		struct hi3515_dmac_desc* desc = &dchan->phys_desc[i];
+		
+		desc->nxt_desc = (i==sg_len-1) ? dchan->phys_desc_phys_addr : (dchan->phys_desc_phys_addr + sizeof(struct hi3515_dmac_desc)*i);
+		
+		if (direction == DMA_MEM_TO_DEV)
+			desc->src_addr = buf_addr + (i * period_len);
+		else
+			desc->dst_addr = buf_addr + (i * period_len);
+		
+		
+		desc->ctrl_reg = period_len | (0b000 << 12) | (0b000 << 15) | (0b000 << 18) | (0b000 << 21) | ((direction == DMA_MEM_TO_DEV) << 24) | ((direction != DMA_MEM_TO_DEV) << 25) | ((direction == DMA_MEM_TO_DEV) << 26) | ((direction != DMA_MEM_TO_DEV) << 27) | (0b000 << 28) | (1 << 31);
+	}
+	
+	dchan->status = DMA_IN_PROGRESS;
+	
+	return &dchan->desc;
+	
+}
+	
+enum dma_status hi3515_dmac_tx_status(struct dma_chan *chan, dma_cookie_t cookie, struct dma_tx_state *txstate) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+
+	dma_set_tx_state(txstate, chan->completed_cookie, chan->cookie, 0);
+
+	return dchan->status;
+}
+
+void hi3515_dmac_issue_pending(struct dma_chan *chan) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	
+	//clr interrupts
+	writel(1<<dchan->chan_num, dchan->dev->regs + 0x008);
+	writel(1<<dchan->chan_num, dchan->dev->regs + 0x010);
+	
+	writel( (0 << 0) | (dchan->hw_req_line << 1) | (dchan->hw_req_line << 6) | ((dchan->dir == DMA_MEM_TO_MEM ? 0b000 : (dchan->dir == DMA_MEM_TO_DEV ? 0b001 : (dchan->dir == DMA_DEV_TO_MEM ? 0b010 : 0b011))) << 11) | (1<<14) | (1<<15) | (0<<16) | (0<<17) | (1<<19) | (1<<20)  ,
+	       dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20);
+	
+	//enable channel
+	writel( (1 << 0) | readl( dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20) ),
+		dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20);
+		
+	dchan->status = DMA_IN_PROGRESS;
+}
+
+int hi3515_dmac_config(struct dma_chan *chan, struct dma_slave_config *config) {
+	struct dma_chan *dchan = to_hi3515_dmac_chan(chan);
+
+	memcpy(&dchan->slave_cfg, slave_cfg, sizeof(fchan->slave_cfg));
+	return 0;
+}
+
+int hi3515_dmac_pause(struct dma_chan *chan) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	
+	writel( readl( dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20) ) & 0xFFFFFFFE, dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20);
+	
+	dchan->status = DMA_PAUSED;
+}
+
+int hi3515_dmac_resume(struct dma_chan *chan) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	
+	writel( (1 << 0) | readl( dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20) ), dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20);
+		
+	dchan->status = DMA_IN_PROGRESS;
+}
+
+int hi3515_dmac_terminate_all(struct dma_chan *chan) {
+	struct hi3515_dmac_chan *dchan = to_hi3515_dmac_chan(chan);
+	
+	writel( readl( dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20) ) & 0xFFFFFFFE, dchan->dev->regs + 0x110 + (dchan->chan_num * 0x20);
+	
+	dchan->status = DMA_COMPLETE;
+}
+
+static struct dma_chan* hi3515_dmac_xlate(struct of_phandle_args *dma_spec, struct of_dma *ofdma) {
+	struct hi3515_dmac_dev *fdev = ofdma->of_dma_data;
+	struct dma_chan *chan = NULL;
+	
+	if (dma_spec->args_count != 1)
+		return NULL;
+	
+	int arg = dma_spec->args[0]; //hw request line
+	if(arg < 0 || arg > 15) {
+		return NULL;
+	}
+	
+	for(int i = 0; i < 8; i++) {
+		if(fdev->chans[i].status == DMA_COMPLETE) {
+			chan = &fdev->chans[i].chan;
+			break;
+		}
+	}
+	if(!chan)
+		return NULL; //everything busy
+	
+	struct dma_chan *dchan = to_hi3515_dmac_chan(chan);
+	dchan->hw_req_line = arg;
+	
+	return chan;
+}
+
+static void hi3515_dmac_irq_chan_handler(struct hi3515_dmac_dev *dmadev, int chanid, bool err) {
+	struct hi3515_dmac_chan *dchan = &dmadev->chans[chanid];
+	
+	if(err)
+		dchan->status = DMA_ERROR;
+	else {
+		bool active = readl(dmadev->regs + 0x110 + (chanid*0x20)) & (1 << 17);
+		if(active) {
+			dchan->status = DMA_IN_PROGRESS;
+		} else {
+			dchan->status = DMA_COMPLETE;
+		}
+	}
+}
+
+static irqreturn_t hi3515_dmac_irq_handler(int irq, void *dev_id) {
+	struct hi3515_dmac_dev *dmadev = dev_id;
+	u32 chid;
+	int interrupts = 0;
+	u32 intstat = readl(dmadev->regs + 0x000);
+	u32 intstat1 = readl(dmadev->regs + 0x040);
+	u32 tcstat = readl(dmadev->regs + 0x004);
+	u32 tcstat1 = readl(dmadev->regs + 0x044);
+	u32 errstat = readl(dmadev->regs + 0x00C);
+	u32 errstat1 = readl(dmadev->regs + 0x048);
+	
+	while (tcstat) {
+		chid = __fls(tcstat);
+		hi3515_dmac_irq_chan_handler(dmadev, chid, false);
+		interrupts++;
+		writel(1<<chid, dmadev->regs + 0x008); //clear
+		tcstat &= ~BIT(chid);
+	}
+	while (tcstat1) {
+		chid = __fls(tcstat1);
+		hi3515_dmac_irq_chan_handler(dmadev, chid, false);
+		interrupts++;
+		writel(1<<chid, dmadev->regs + 0x008); //clear
+		tcstat1 &= ~BIT(chid);
+	}
+	while (errstat) {
+		chid = __fls(errstat);
+		hi3515_dmac_irq_chan_handler(dmadev, chid, true);
+		interrupts++;
+		writel(1<<chid, dmadev->regs + 0x010); //clear
+		errstat &= ~BIT(chid);
+	}
+	while (errstat1) {
+		chid = __fls(errstat1);
+		hi3515_dmac_irq_chan_handler(dmadev, chid, true);
+		interrupts++;
+		writel(1<<chid, dmadev->regs + 0x010); //clear
+		errstat1 &= ~BIT(chid);
+	}
+	
+	if(interrupts)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+
+
+static int hi3515_dmac_probe(struct platform_device *pdev) {
+	struct device_node *node = pdev->dev.of_node;
+	void __iomem *regs;
+	struct hi3515_dmac_dev* dmadev;
+	int irq, ret;
+	
+	if (dma_set_mask_and_coherent(pdev->dev, DMA_BIT_MASK(32))) {
+		dev_err(pdev->dev, "32-bit DMA addressing not available\n");
+		return -EINVAL;
+	}
+	
+	regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+	
+	dmadev = devm_kzalloc(&pdev->dev, sizeof(*dmadev), GFP_KERNEL);
+	if (IS_ERR(dmadev))
+		return PTR_ERR(dmadev);
+	
+	dmadev->chans = devm_kcalloc(&pdev->dev, 8, sizeof(struct hi3515_dmac_chan), GFP_KERNEL);
+	if (!dmadev->chans)
+		return -ENOMEM;
+	
+	dmadev->regs = regs;
+	
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return -EINVAL;
+
+	ret = devm_request_irq(&pdev->dev, irq, hi3515_dmac_irq_handler, 0,
+			       dev_name(&pdev->dev), dmadev);
+	if (ret)
+		return ret;
+	
+	/* Initialise list of DMA channels */
+	INIT_LIST_HEAD(&dmadev->dma_device.channels);
+	for (int i = 0; i < 8; i++) {
+		struct hi3515_dmac_chan* dchan = &dmadev->chans[i];
+		dma_cookie_init(&dchan->chan);
+
+		dchan->dev = dmadev;
+		dchan->chan_num = i;
+		dchan->status = DMA_COMPLETE;
+		
+		dchan->phys_desc = NULL;
+		dchan->hw_req_line = 0;
+		
+		dchan->chan.device = dmadev;
+		list_add_tail(&dchan->chan.device_node, &dmadev->dma_device.channels);
+	// 	struct virt_dma_chan *dchan = &dmadev->chans[i];
+	// 	// dchan->desc_free = st_fdma_free_desc;
+	// 	vchan_init(&dchan, &dmadev->dma_device);
+	}
+	
+	dma_cap_set(DMA_MEMCPY, dmadev->dma_device.cap_mask);
+	dma_cap_set(DMA_SLAVE, dmadev->dma_device.cap_mask);
+	dma_cap_set(DMA_CYCLIC, dmadev->dma_device.cap_mask);
+
+	dmadev->dma_device.dev = &pdev->dev;
+	dmadev->dma_device.device_alloc_chan_resources = hi3515_dmac_alloc_chan_res;
+	dmadev->dma_device.device_free_chan_resources = hi3515_dmac_free_chan_res;
+	dmadev->dma_device.device_prep_dma_cyclic	= hi3515_dmac_prep_dma_cyclic;
+	dmadev->dma_device.device_prep_slave_sg = hi3515_dmac_prep_slave_sg;
+	dmadev->dma_device.device_prep_dma_memcpy = hi3515_dmac_prep_dma_memcpy;
+	dmadev->dma_device.device_tx_status = hi3515_dmac_tx_status;
+	dmadev->dma_device.device_issue_pending = hi3515_dmac_issue_pending;
+	dmadev->dma_device.device_terminate_all = hi3515_dmac_terminate_all;
+	dmadev->dma_device.device_config = hi3515_dmac_config;
+	dmadev->dma_device.device_pause = hi3515_dmac_pause;
+	dmadev->dma_device.device_resume = hi3515_dmac_resume;
+
+	dmadev->dma_device.src_addr_widths = (1<<1)|(1<<2)|(1<<4);
+	dmadev->dma_device.dst_addr_widths = (1<<1)|(1<<2)|(1<<4);
+	dmadev->dma_device.directions = BIT(DMA_MEM_TO_MEM) | BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);
+	dmadev->dma_device.residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR;
+	
+	//dmac_config
+	writel((1<<0) | (0<<1) | (0<<2), regs + 0x030);
+	
+	ret = dmaenginem_async_device_register(&dmadev->dma_device);
+	if(ret) {
+		if (ret) {
+			dev_err(pdev->dev, "failed to register engine\n");
+			return ret;
+		}
+	}
+	
+	ret = of_dma_controller_register(node, hi3515_dmac_xlate, dmadev);
+	
+	return ret;
+}
+
+static const struct of_device_id hi3515_dmac_match[] = {
+	{.compatible = "hisilicon,hi3515dmac"},
+	{},
+};
+
+static struct platform_driver hi3515_dmac_driver = {
+	.driver = {
+		.name = "hi3515-dmac",
+		.of_match_table = hi3515_dmac_match,
+	},
+	.probe	= hi3515_dmac_probe,
+};
+
+static int __init hi3515_dmac_init(void) {
+	return platform_driver_register(&hi3515_dmac_driver);
+}
+
+arch_initcall(hi3515_dmac_init);
diff --no-dereference -ruN linux-master/drivers/dma/Makefile linux-master-mod/drivers/dma/Makefile
--- linux-master/drivers/dma/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/dma/Makefile	2024-10-20 20:47:08.085131569 +0300
@@ -84,6 +84,7 @@
 obj-$(CONFIG_ST_FDMA) += st_fdma.o
 obj-$(CONFIG_FSL_DPAA2_QDMA) += fsl-dpaa2-qdma/
 obj-$(CONFIG_INTEL_LDMA) += lgm/
+# obj-$(CONFIG_ARCH_HI3515V100) += hi3515-dmac.c
 
 obj-y += amd/
 obj-y += mediatek/
diff --no-dereference -ruN linux-master/drivers/i2c/busses/i2c-designware-common.c linux-master-mod/drivers/i2c/busses/i2c-designware-common.c
--- linux-master/drivers/i2c/busses/i2c-designware-common.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/i2c/busses/i2c-designware-common.c	2024-11-20 23:55:38.667890909 +0300
@@ -202,16 +202,17 @@
 	 * Only standard mode at 100kHz, fast mode at 400kHz,
 	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
 	 */
-	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
-		if (t->bus_freq_hz == supported_speeds[i])
-			return 0;
-	}
-
-	dev_err(dev->dev,
-		"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
-		t->bus_freq_hz);
-
-	return -EINVAL;
+	// for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+	// 	if (t->bus_freq_hz == supported_speeds[i])
+	// 		return 0;
+	// }
+ // 
+	// dev_err(dev->dev,
+	// 	"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
+	// 	t->bus_freq_hz);
+ // 
+	// return -EINVAL;
+	return 0;
 }
 
 #ifdef CONFIG_OF
diff --no-dereference -ruN linux-master/drivers/i2c/busses/i2c-designware-master.c linux-master-mod/drivers/i2c/busses/i2c-designware-master.c
--- linux-master/drivers/i2c/busses/i2c-designware-master.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/i2c/busses/i2c-designware-master.c	2024-11-21 00:22:42.720452122 +0300
@@ -22,6 +22,8 @@
 #include <linux/regmap.h>
 #include <linux/reset.h>
 
+#include <linux/math64.h>
+
 #define DEFAULT_SYMBOL_NAMESPACE	I2C_DW
 
 #include "i2c-designware-core.h"
@@ -48,6 +50,7 @@
 	const char *fp_str = "";
 	u32 ic_clk;
 	int ret;
+	int tHI, tLO;
 
 	ret = i2c_dw_acquire_lock(dev);
 	if (ret)
@@ -61,6 +64,9 @@
 	/* Set standard and fast speed dividers for high/low periods */
 	sda_falling_time = t->sda_fall_ns ?: 300; /* ns */
 	scl_falling_time = t->scl_fall_ns ?: 300; /* ns */
+	
+	tHI = div_u64(1000000000ULL, (t->bus_freq_hz * 2ULL));
+	tLO = div_u64(1000000000ULL, (t->bus_freq_hz * 2ULL));
 
 	/* Calculate SCL timing parameters for standard mode if not set */
 	if (!dev->ss_hcnt || !dev->ss_lcnt) {
@@ -69,7 +75,7 @@
 			i2c_dw_scl_hcnt(dev,
 					DW_IC_SS_SCL_HCNT,
 					ic_clk,
-					4000,	/* tHD;STA = tHIGH = 4.0 us */
+					tHI,	/* tHD;STA = tHIGH = 4.0 us */
 					sda_falling_time,
 					0,	/* 0: DW default, 1: Ideal */
 					0);	/* No offset */
@@ -77,11 +83,11 @@
 			i2c_dw_scl_lcnt(dev,
 					DW_IC_SS_SCL_LCNT,
 					ic_clk,
-					4700,	/* tLOW = 4.7 us */
+					tLO,	/* tLOW = 4.7 us */
 					scl_falling_time,
 					0);	/* No offset */
 	}
-	dev_dbg(dev->dev, "Standard Mode HCNT:LCNT = %d:%d\n",
+	dev_info(dev->dev, "Standard Mode tHI:tLO = %d:%d HCNT:LCNT = %d:%d\n", tHI, tLO,
 		dev->ss_hcnt, dev->ss_lcnt);
 
 	/*
@@ -103,7 +109,7 @@
 				i2c_dw_scl_hcnt(dev,
 						DW_IC_FS_SCL_HCNT,
 						ic_clk,
-						260,	/* tHIGH = 260 ns */
+						tHI,	/* tHIGH = 260 ns */
 						sda_falling_time,
 						0,	/* DW default */
 						0);	/* No offset */
@@ -111,7 +117,7 @@
 				i2c_dw_scl_lcnt(dev,
 						DW_IC_FS_SCL_LCNT,
 						ic_clk,
-						500,	/* tLOW = 500 ns */
+						tLO,	/* tLOW = 500 ns */
 						scl_falling_time,
 						0);	/* No offset */
 		}
@@ -127,7 +133,7 @@
 			i2c_dw_scl_hcnt(dev,
 					DW_IC_FS_SCL_HCNT,
 					ic_clk,
-					600,	/* tHD;STA = tHIGH = 0.6 us */
+					tHI,	/* tHD;STA = tHIGH = 0.6 us */
 					sda_falling_time,
 					0,	/* 0: DW default, 1: Ideal */
 					0);	/* No offset */
@@ -135,11 +141,11 @@
 			i2c_dw_scl_lcnt(dev,
 					DW_IC_FS_SCL_LCNT,
 					ic_clk,
-					1300,	/* tLOW = 1.3 us */
+					tLO,	/* tLOW = 1.3 us */
 					scl_falling_time,
 					0);	/* No offset */
 	}
-	dev_dbg(dev->dev, "Fast Mode%s HCNT:LCNT = %d:%d\n",
+	dev_info(dev->dev, "Fast Mode%s HCNT:LCNT = %d:%d\n",
 		fp_str, dev->fs_hcnt, dev->fs_lcnt);
 
 	/* Check is high speed possible and fall back to fast mode if not */
@@ -159,7 +165,7 @@
 				i2c_dw_scl_hcnt(dev,
 						DW_IC_HS_SCL_HCNT,
 						ic_clk,
-						160,	/* tHIGH = 160 ns */
+						tHI,	/* tHIGH = 160 ns */
 						sda_falling_time,
 						0,	/* DW default */
 						0);	/* No offset */
@@ -167,11 +173,11 @@
 				i2c_dw_scl_lcnt(dev,
 						DW_IC_HS_SCL_LCNT,
 						ic_clk,
-						320,	/* tLOW = 320 ns */
+						tLO,	/* tLOW = 320 ns */
 						scl_falling_time,
 						0);	/* No offset */
 		}
-		dev_dbg(dev->dev, "High Speed Mode HCNT:LCNT = %d:%d\n",
+		dev_info(dev->dev, "High Speed Mode HCNT:LCNT = %d:%d\n",
 			dev->hs_hcnt, dev->hs_lcnt);
 	}
 
@@ -179,7 +185,7 @@
 	if (ret)
 		return ret;
 
-	dev_dbg(dev->dev, "Bus speed: %s\n", i2c_freq_mode_string(t->bus_freq_hz));
+	dev_info(dev->dev, "Bus speed: %s(%d)\n", i2c_freq_mode_string(t->bus_freq_hz), t->bus_freq_hz);
 	return 0;
 }
 
diff --no-dereference -ruN linux-master/drivers/i2c/busses/i2c-designware-platdrv.c linux-master-mod/drivers/i2c/busses/i2c-designware-platdrv.c
--- linux-master/drivers/i2c/busses/i2c-designware-platdrv.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/i2c/busses/i2c-designware-platdrv.c	2024-11-01 22:39:58.176341570 +0300
@@ -233,6 +233,11 @@
 	if (IS_ERR(dev->rst))
 		return PTR_ERR(dev->rst);
 
+	
+	reset_control_assert(dev->rst);
+	
+	udelay(100);
+	
 	reset_control_deassert(dev->rst);
 
 	ret = i2c_dw_fw_parse_and_configure(dev);
diff --no-dereference -ruN linux-master/drivers/input/keyboard/avtech_keyboard.c linux-master-mod/drivers/input/keyboard/avtech_keyboard.c
--- linux-master/drivers/input/keyboard/avtech_keyboard.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/input/keyboard/avtech_keyboard.c	2024-11-23 15:39:15.277242499 +0300
@@ -0,0 +1,364 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-direction.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+
+#define AVT_KBD_PRESS_MS 50
+#define AVT_KBD_RELEASE_MS 200
+#define AVT_KBD_KEY_CNT 20
+
+struct avtech_kbd {
+	struct device *dev;
+	// struct regmap *regmap;
+	struct i2c_client *client;
+	struct gpio_desc *gpio_trigger;
+	struct gpio_desc *gpio_ce;
+	struct work_struct kbd_check_work;
+	struct hrtimer press_timer;
+	struct hrtimer release_timer;
+	struct input_dev *input;
+	uint16_t *keymap;
+	bool key_pressed;
+	uint32_t lastkey;
+};
+
+static const struct regmap_config avtech_kbd_regmap_config = {
+	.val_bits = 8,
+	.reg_bits = 8,
+
+	.max_register = 0xff,
+
+	.cache_type = REGCACHE_NONE,
+};
+
+struct avtech_kbd_keymap {
+	uint8_t rawkbd_keycode;
+	uint16_t linux_keycode;
+};
+
+static const struct avtech_kbd_keymap avtech_kbd_keymaps[] = {
+	{0x89, KEY_MENU},
+	{0x19, KEY_TAB}, //QUAD
+	{0x31, KEY_BACKSPACE}, //SEQ
+	{0x0A, KEY_1},
+	{0x1A, KEY_2},
+	{0x22, KEY_3},
+	{0x32, KEY_4},
+	{0x4A, KEY_5},
+	{0x52, KEY_6},
+	{0x5A, KEY_7},
+	{0x62, KEY_8},
+	{0x59, KEY_SLOW},
+	{0x81, KEY_ZOOM},
+	{0x99, KEY_UP},
+	{0x21, KEY_LEFT},
+	{0xA1, KEY_RIGHT},
+	{0x09, KEY_DOWN},
+	{0x69, KEY_ENTER},
+	{0x49, KEY_PLAY},
+	{0x71, KEY_LIST}
+};
+
+static void avtech_kbd_write_reg(struct avtech_kbd* kbd, uint8_t reg, uint8_t val) {
+	int ret;
+	gpiod_set_value_cansleep(kbd->gpio_ce, 0);
+	udelay(100);
+	// regmap_write(kbd->regmap, reg, val);
+	ret = i2c_smbus_write_byte_data(kbd->client, reg, val);
+	gpiod_set_value_cansleep(kbd->gpio_ce, 1);
+	udelay(100);
+	if(ret < 0)
+		dev_err(kbd->dev, "I2C write failed: %d", ret);
+}
+
+static uint8_t avtech_kbd_read_reg(struct avtech_kbd* kbd, uint8_t reg) {
+	uint32_t val;
+	gpiod_set_value_cansleep(kbd->gpio_ce, 0);
+	udelay(100);
+	// regmap_read(kbd->regmap, reg, &val);
+	val = i2c_smbus_read_byte_data(kbd->client, reg);
+	gpiod_set_value_cansleep(kbd->gpio_ce, 1);
+	udelay(100);
+	return val;
+}
+
+static void avtech_kbd_read_st_regs(struct avtech_kbd* kbd, uint8_t* regs) {
+	int ret;
+	
+	gpiod_set_value_cansleep(kbd->gpio_ce, 0);
+	udelay(100);
+	ret = i2c_smbus_read_i2c_block_data(kbd->client, 0x02, 5, regs);
+	gpiod_set_value_cansleep(kbd->gpio_ce, 1);
+	udelay(100);
+	if(ret < 0)
+		dev_err(kbd->dev, "I2C read failed: %d", ret);
+	
+}
+
+static unsigned char reverse(unsigned char b) {
+   b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
+   b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
+   b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
+   return b;
+}
+
+static void avtech_keyboard_slow_interrupt_handler(struct work_struct *work) {
+// static enum hrtimer_restart avtech_keyboard_slow_interrupt_handler (struct hrtimer *t) {
+	struct avtech_kbd *kbd = container_of(work, struct avtech_kbd, kbd_check_work);
+	// struct avtech_kbd *kbd = container_of(t, struct avtech_kbd, press_timer);
+	uint8_t regs[5];
+	uint8_t key = 0;
+	// for(int i = 0; i < 5; i++) {
+		// regs[i] = avtech_kbd_read_reg(kbd, 0x02);
+	// }
+	avtech_kbd_read_st_regs(kbd, regs);
+	
+	if(regs[0] != 0xff) {
+		key = (regs[0]&0xf8) | 0x01;
+	}
+	if(regs[1] != 0xff) {
+		key = (regs[1]&0xf8) | 0x02;
+	}
+	if(regs[2] != 0xff || regs[3] != 0xff || regs[4] != 0xff) {
+		//TODO: pass IR codes to LIRC
+	}
+	
+	if(key != 0) {
+		if(kbd->key_pressed) {
+			if(key == kbd->lastkey) {
+				hrtimer_cancel(&kbd->release_timer);
+				hrtimer_start(&kbd->release_timer, ms_to_ktime(AVT_KBD_RELEASE_MS), HRTIMER_MODE_REL_HARD);
+			}
+		} else {
+			dev_dbg(kbd->dev, "RAW REGS: 0x%x 0x%x 0x%x 0x%x 0x%x", regs[0], regs[1], regs[2], regs[3], regs[4]);
+			dev_dbg(kbd->dev, "KEY PRESS: 0x%x", key);
+			input_report_key(kbd->input, kbd->keymap[key], 1);
+			input_sync(kbd->input);
+			kbd->key_pressed = true;
+			kbd->lastkey = key;
+			hrtimer_start(&kbd->release_timer, ms_to_ktime(AVT_KBD_RELEASE_MS), HRTIMER_MODE_REL_HARD);
+		}
+	}
+}
+
+static enum hrtimer_restart avtech_keyboard_timer_interrupt_handler (struct hrtimer *t) {
+	struct avtech_kbd *kbd = container_of(t, struct avtech_kbd, press_timer);
+	schedule_work(&kbd->kbd_check_work);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t avtech_kbd_isr(int irq, void *dev_id) {
+	struct avtech_kbd* kbd = dev_id;
+	// schedule_work(&kbd->kbd_check_work);
+	hrtimer_start(&kbd->press_timer, ms_to_ktime(AVT_KBD_PRESS_MS), HRTIMER_MODE_REL_HARD);
+	return IRQ_HANDLED;
+}
+
+static enum hrtimer_restart avtech_keyboard_rel_timer_irq (struct hrtimer *t) {
+	struct avtech_kbd *kbd = container_of(t,
+						struct avtech_kbd,
+						release_timer);
+	// struct input_dev *input = bdata->input;
+
+	if (kbd->key_pressed) {
+		input_report_key(kbd->input, kbd->keymap[kbd->lastkey], 0);
+		input_sync(kbd->input);
+		// input_report_key(input, *bdata->code, 0);
+		// input_sync(input);
+		// bdata->key_pressed = false;
+		dev_dbg(kbd->dev, "KEY RELEASE 0x%x", kbd->lastkey);
+		kbd->key_pressed = false;
+	}
+
+	return HRTIMER_NORESTART;
+	
+}
+
+static int avtech_kbd_probe(struct i2c_client *client) {
+	struct device *dev = &client->dev;
+	struct avtech_kbd* kbd;
+	int irq;
+	
+	dev_info(dev, "Initializing...");
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_info(dev, "Deferring probe");
+		return -EPROBE_DEFER;  // This will cause probe to be retried later
+	}
+
+	kbd = devm_kzalloc(dev, sizeof(*kbd), GFP_KERNEL);
+	if (!kbd) {
+		dev_err(dev, "NO MEMORY FOR KBD!");
+		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(client, kbd);
+	kbd->dev = dev;
+
+	// kbd->regmap = devm_regmap_init_i2c(client, &avtech_kbd_regmap_config);
+	// if (IS_ERR(kbd->regmap)) {
+		// dev_err(dev, "REGMAP INIT ERROR %d!", PTR_ERR(kbd->regmap));
+		// return PTR_ERR(kbd->regmap);
+	// }
+	kbd->client = client;
+	
+	kbd->gpio_trigger = devm_fwnode_gpiod_get_index(dev, of_fwnode_handle(dev->of_node), "trigger", 0, GPIOD_IN,fwnode_get_name(of_fwnode_handle(dev->of_node)));
+	if(IS_ERR(kbd->gpio_trigger)) {
+		dev_err(dev, "GPIO TRIGGER INIT ERROR %d!", PTR_ERR(kbd->gpio_trigger));
+		return PTR_ERR(kbd->gpio_trigger);
+	}
+	
+	kbd->gpio_ce = devm_fwnode_gpiod_get_index(dev, of_fwnode_handle(dev->of_node), "ce", 0, GPIOD_OUT_HIGH,fwnode_get_name(of_fwnode_handle(dev->of_node)));
+	if(IS_ERR(kbd->gpio_ce)) {
+		dev_err(dev, "GPIO CE INIT ERROR %d!", PTR_ERR(kbd->gpio_ce));
+		return PTR_ERR(kbd->gpio_ce);
+	}
+	
+	INIT_WORK(&kbd->kbd_check_work, avtech_keyboard_slow_interrupt_handler);
+	
+	kbd->input = devm_input_allocate_device(dev);
+	if (!kbd->input) {
+		dev_err(dev, "failed to allocate input device\n");
+		return -ENOMEM;
+	}
+	
+	kbd->input->name = "avtech_kbd";
+	kbd->input->phys = "avtech_kbd/input0";
+	kbd->input->dev.parent = dev;
+
+	kbd->input->id.bustype = BUS_I2C;
+	
+	kbd->keymap = devm_kcalloc(dev, 0xff, sizeof(kbd->keymap[0]), GFP_KERNEL);
+	if (!kbd->keymap)
+		return -ENOMEM;
+
+	kbd->input->keycode = kbd->keymap;
+	kbd->input->keycodesize = sizeof(kbd->keymap[0]);
+	kbd->input->keycodemax = 0xff;
+	
+	input_set_drvdata(kbd->input, kbd);
+	
+	irq = input_register_device(kbd->input);
+	if (irq) {
+		dev_err(dev, "Unable to register input device, error: %d\n",
+			irq);
+		return irq;
+	}
+	
+	for(int i = 0; i <= 0x2ff; i++) {
+		uint8_t kbdkey = 0;
+		for(int k = 0; k < AVT_KBD_KEY_CNT; k++) {
+			if(avtech_kbd_keymaps[k].linux_keycode == i) {
+				kbdkey = avtech_kbd_keymaps[k].rawkbd_keycode;
+			}
+		}
+		if(!kbdkey)
+			continue;
+		kbd->keymap[kbdkey] = i;
+		input_set_capability(kbd->input, EV_KEY, kbd->keymap[kbdkey]);
+	}
+	
+	hrtimer_init(&kbd->press_timer, CLOCK_REALTIME, HRTIMER_MODE_REL_HARD);
+	kbd->press_timer.function = avtech_keyboard_timer_interrupt_handler;
+	
+	
+	hrtimer_init(&kbd->release_timer, CLOCK_REALTIME, HRTIMER_MODE_REL_HARD);
+	kbd->release_timer.function = avtech_keyboard_rel_timer_irq;
+	kbd->key_pressed = false;
+	
+	
+	// for(int i = 0; i < 0x100; i++) {
+	// 	dev_info(dev, "REG 0x%x => 0x%x", i, avtech_kbd_read_reg(kbd, i));
+	// }
+	
+	dev_dbg(dev, "Sending init sequence");
+	
+	avtech_kbd_write_reg(kbd, 0x07, 0x55);
+	if(avtech_kbd_read_reg(kbd, 0x07) != 0x55)
+		dev_warn(dev, "Wrong value of reg 0x07: 0x%x/0x55", avtech_kbd_read_reg(kbd, 0x07));
+	if(avtech_kbd_read_reg(kbd, 0x00) != 0x68)
+		dev_warn(dev, "Wrong value of reg 0x00: 0x%x/0x68", avtech_kbd_read_reg(kbd, 0x00));
+	avtech_kbd_write_reg(kbd, 0x08, 0x70);
+	avtech_kbd_write_reg(kbd, 0x09, 0xf0);
+	avtech_kbd_write_reg(kbd, 0x07, 0x55);
+	if(avtech_kbd_read_reg(kbd, 0x07) != 0x55)
+		dev_warn(dev, "Wrong value of reg 0x07: 0x%x/0x55", avtech_kbd_read_reg(kbd, 0x07));
+	if(avtech_kbd_read_reg(kbd, 0x00) != 0x68)
+		dev_warn(dev, "Wrong value of reg 0x00: 0x%x/0x68", avtech_kbd_read_reg(kbd, 0x00));
+	
+	
+	// while(1) {
+	// 	avtech_kbd_write_reg(kbd, 0x07, 0x55);
+	// 	// gpiod_set_value_cansleep(kbd->gpio_ce, 0);
+	// 	// gpiod_set_value_cansleep(kbd->gpio_trigger, 0);
+	// 	msleep(100);
+	// 	// gpiod_set_value_cansleep(kbd->gpio_ce, 1);
+	// 	// gpiod_set_value_cansleep(kbd->gpio_trigger, 1);
+	// 	// msleep(10);
+	// }
+	
+	
+	irq = gpiod_to_irq(kbd->gpio_trigger);
+	if (irq < 0) {
+		dev_err(dev, "Unable to get irq number for GPIO");
+		return irq;
+	}
+	
+	irq = devm_request_any_context_irq(dev, irq, avtech_kbd_isr, IRQF_TRIGGER_FALLING | IRQF_SHARED, "avtechkbd", kbd);
+	if (irq < 0) {
+		dev_err(dev, "Unable to claim irq: %d\n", irq);
+		return irq;
+	}
+	
+
+	return 0;
+}
+
+static const struct of_device_id avtech_kbd_of_match[] = {
+	{ .compatible = "avtech,kbd" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, avtech_kbd_of_match);
+
+static struct i2c_driver avtech_kbd_driver = {
+	.probe		= avtech_kbd_probe,
+	.driver		= {
+		.name		= "avtechkbd",
+		.of_match_table = avtech_kbd_of_match,
+	},
+};
+module_i2c_driver(avtech_kbd_driver);
+
+MODULE_AUTHOR("Indir Wolf");
+MODULE_DESCRIPTION("AVTech DVR Keyboard + IR Driver");
+MODULE_LICENSE("GPL");
diff --no-dereference -ruN linux-master/drivers/input/keyboard/Makefile linux-master-mod/drivers/input/keyboard/Makefile
--- linux-master/drivers/input/keyboard/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/input/keyboard/Makefile	2024-11-18 16:43:07.737698585 +0300
@@ -70,3 +70,4 @@
 obj-$(CONFIG_KEYBOARD_TM2_TOUCHKEY)	+= tm2-touchkey.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
+obj-$(CONFIG_ARCH_HI3515V100)		+= avtech_keyboard.o
diff --no-dereference -ruN linux-master/drivers/irqchip/irq-hi3515v100-intc.c linux-master-mod/drivers/irqchip/irq-hi3515v100-intc.c
--- linux-master/drivers/irqchip/irq-hi3515v100-intc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/irqchip/irq-hi3515v100-intc.c	2024-10-17 22:57:40.377362747 +0300
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Author: IndirWolf
+//
+// HI3515b100 Interrupt Controller  driver
+
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip/irq-hi3515v100-intc.h>
+
+#include <asm/exception.h>
+
+static void __iomem *hi3515_intc_base;
+static struct irq_domain *hi3515_intc_irq_domain;
+
+static inline unsigned int hi3515_intc_read(unsigned int offset)
+{
+	return readl_relaxed(hi3515_intc_base + offset);
+}
+
+static inline void hi3515_intc_write(unsigned long value,
+					 unsigned int offset)
+{
+	writel_relaxed(value, hi3515_intc_base + offset);
+}
+
+static void hi3515_intc_ack_irq(struct irq_data *d)
+{
+	hi3515_intc_write(1<<d->hwirq, REG_HI3515_INTC_INTENCLEAR);
+}
+
+static void hi3515_intc_mask_irq(struct irq_data *d)
+{
+	hi3515_intc_write(1<<d->hwirq, REG_HI3515_INTC_INTENCLEAR);
+}
+
+static void hi3515_intc_unmask_irq(struct irq_data *d)
+{
+	hi3515_intc_write(1<<d->hwirq, REG_HI3515_INTC_INTENABLE);
+}
+
+static struct irq_chip hi3515_intc_irq_chip = {
+	.name		= "hi3515_intc",
+	.irq_ack	= hi3515_intc_ack_irq,
+	.irq_mask	= hi3515_intc_mask_irq,
+	.irq_unmask	= hi3515_intc_unmask_irq,
+	.irq_disable 	= hi3515_intc_mask_irq,
+};
+
+static void __exception_irq_entry hi3515_intc_handle_irq(struct pt_regs *regs)
+{
+	u32 gpir, irqnr;
+
+	/*
+	 * The interrupt number is in first ten bits. The NONE field set to 1
+	 * indicates a spurious irq.
+	 */
+
+	gpir= hi3515_intc_read(REG_HI3515_INTC_IRQSTATUS) | hi3515_intc_read(REG_HI3515_INTC_FIQSTATUS);
+
+	if (unlikely(!gpir)) {
+		pr_err_once("%s: spurious irq!\n", __func__);
+		return;
+	}
+
+	while (gpir) {
+		irqnr = __fls(gpir);
+
+		generic_handle_domain_irq(hi3515_intc_irq_domain, irqnr);
+		gpir &= ~BIT(irqnr);
+	}
+	hi3515_intc_write(~0, REG_HI3515_INTC_SOFTINTCLEAR);
+}
+
+static int hi3515_intc_host_map(struct irq_domain *h, unsigned int virq,
+			  irq_hw_number_t hw)
+{
+	pr_debug("hi3515_intc_host_map(%d, 0x%lx)\n", virq, hw);
+
+	irq_set_chip(virq, &hi3515_intc_irq_chip);
+	irq_set_probe(virq);
+	irq_set_handler(virq, handle_level_irq);
+	irq_set_status_flags(virq, IRQ_LEVEL);
+
+	return 0;
+}
+
+static const struct irq_domain_ops hi3515_intc_irq_domain_ops = {
+	.map = hi3515_intc_host_map,
+	.xlate = irq_domain_xlate_onecell
+};
+
+int __init hi3515_intc_init(struct resource res, struct device_node *node)
+{
+	int irq_base;
+	void __iomem *req;
+
+	req = request_mem_region(res.start,
+				 resource_size(&res),
+				 "hi3515-intc");
+	if (!req) {
+		pr_err("%s: register range busy\n", __func__);
+		return -EBUSY;
+	}
+
+	hi3515_intc_base = ioremap(res.start,
+				       resource_size(&res));
+	if (!hi3515_intc_base) {
+		pr_err("%s: unable to ioremap register range\n", __func__);
+		return -EINVAL;
+	}
+	
+	hi3515_intc_write(~0, REG_HI3515_INTC_INTENCLEAR);
+	hi3515_intc_write(0, REG_HI3515_INTC_INTSELECT); //set all interrupts as IRQ
+	hi3515_intc_write(~0, REG_HI3515_INTC_SOFTINTCLEAR);
+	hi3515_intc_write(1, REG_HI3515_INTC_PROTECTION); //enable int reg protection; now they can be accessed only in priveleged mode
+	
+	irq_base = irq_alloc_descs(-1, 0, NR_IRQS, 0);
+	if (irq_base < 0) {
+		pr_err("%s: unable to allocate interrupt descriptors: %d\n",
+		       __func__, irq_base);
+		return irq_base;
+	}
+	
+	hi3515_intc_irq_domain = irq_domain_add_linear(node, NR_IRQS, &hi3515_intc_irq_domain_ops, NULL);
+	
+	for (int i = irq_base; i < irq_base+NR_IRQS; i++) {
+		irq_domain_associate(hi3515_intc_irq_domain, i, i);
+	}
+
+	if (!hi3515_intc_irq_domain) {
+		pr_err("%s: unable to create an interrupt domain\n", __func__);
+		return -EINVAL;
+	}
+
+	set_handle_irq(hi3515_intc_handle_irq);
+
+	return 0;
+}
+
+
+static int __init hi3515_intc_of_init(struct device_node *node,
+					  struct device_node *parent)
+{
+	struct resource res;
+	int ret;
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret) {
+		pr_err("%s: unable to get the register range from device-tree\n",
+		       __func__);
+		return ret;
+	}
+
+	return hi3515_intc_init(res, node);
+}
+
+
+
+
+
+
+
+IRQCHIP_DECLARE(hi3515intc, "hisilicon,hi3515intc", hi3515_intc_of_init);
diff --no-dereference -ruN linux-master/drivers/irqchip/Makefile linux-master-mod/drivers/irqchip/Makefile
--- linux-master/drivers/irqchip/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/irqchip/Makefile	2024-10-17 21:56:12.976252175 +0300
@@ -126,3 +126,4 @@
 obj-$(CONFIG_APPLE_AIC)			+= irq-apple-aic.o
 obj-$(CONFIG_MCHP_EIC)			+= irq-mchp-eic.o
 obj-$(CONFIG_SUNPLUS_SP7021_INTC)	+= irq-sp7021-intc.o
+obj-$(CONFIG_ARCH_HI3515V100)		+= irq-hi3515v100-intc.o
diff --no-dereference -ruN linux-master/drivers/mfd/Kconfig linux-master-mod/drivers/mfd/Kconfig
--- linux-master/drivers/mfd/Kconfig	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/mfd/Kconfig	2024-10-17 23:13:12.677668311 +0300
@@ -2402,5 +2402,9 @@
 	  Additional drivers must be enabled in order to use the functionality
 	  of the device.
 
+config MFD_HI3515_SYSCON
+        bool
+        default n
+	
 endmenu
 endif
diff --no-dereference -ruN linux-master/drivers/mtd/maps/hi3515-smi.c linux-master-mod/drivers/mtd/maps/hi3515-smi.c
--- linux-master/drivers/mtd/maps/hi3515-smi.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/mtd/maps/hi3515-smi.c	2024-10-27 17:55:17.802752047 +0300
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+
+#include <linux/crypto.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include <crypto/algapi.h>
+#include <linux/kfifo.h>
+
+#include <linux/acpi.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-direction.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <crypto/aes.h>
+#include <crypto/algapi.h>
+#include <crypto/internal/des.h>
+#include <crypto/skcipher.h>
+#include <crypto/xts.h>
+#include <crypto/internal/skcipher.h>
+#include <crypto/engine.h>
+
+#include <crypto/engine.h>
+#include <crypto/internal/hash.h>
+#include <crypto/internal/skcipher.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+
+//placeholder driver to hold CLK&RESET lines
+//SMI controls TODO
+
+
+static int hi3515_smi_probe(struct platform_device *pdev) {
+	struct device *dev = &pdev->dev;
+	struct clk* clock0;
+	struct reset_control* rst0;
+	int i, j;
+	int irq;
+	int ret;
+
+	clock0 = devm_clk_get(dev, "smi0-clk");
+	if(!IS_ERR(clock0)) {
+		clk_prepare_enable(clock0);
+	} else {
+		dev_err(dev, "NO VALID CLOCK smi0-clk SPECIFIED!");
+		return PTR_ERR(clock0);
+	}
+	
+	rst0 = devm_reset_control_get_by_index(dev, 0);
+	if (IS_ERR(rst0)) {
+		dev_err(dev, "NO VALID RST 0 SPECIFIED!");
+		return PTR_ERR(rst0);
+	}
+
+	reset_control_deassert(rst0);
+	
+	dev_info(dev, "SMI initialized");
+
+	return 0;
+}
+
+static const __maybe_unused struct of_device_id hi3515_smi_match[] = {
+	{ .compatible = "hisilicon,hi3515smi" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, hi3515_smi_match);
+
+static struct platform_driver hi3515_smi_driver = {
+	.probe = hi3515_smi_probe,
+	.driver = {
+		.name = "hi3515_smi_driver",
+		.of_match_table = hi3515_smi_match,
+	},
+};
+
+module_platform_driver(hi3515_smi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("HiSilicon HI3515 SMI driver");
+MODULE_AUTHOR("Indir Wolf");
diff --no-dereference -ruN linux-master/drivers/mtd/maps/Makefile linux-master-mod/drivers/mtd/maps/Makefile
--- linux-master/drivers/mtd/maps/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/mtd/maps/Makefile	2024-10-25 20:54:42.605157836 +0300
@@ -41,3 +41,4 @@
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_LANTIQ)	+= lantiq-flash.o
+obj-$(CONFIG_ARCH_HI3515V100)	+= hi3515-smi.o
diff --no-dereference -ruN linux-master/drivers/video/fbdev/hi3515-fb.c linux-master-mod/drivers/video/fbdev/hi3515-fb.c
--- linux-master/drivers/video/fbdev/hi3515-fb.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/drivers/video/fbdev/hi3515-fb.c	2024-11-24 18:58:35.882713859 +0300
@@ -0,0 +1,529 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-direction.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <linux/fb.h>
+
+#include <linux/pm_runtime.h>
+
+struct hi3515_fbdev {
+	struct device *dev;
+	struct clk* clock_bus;
+	struct clk* clock_vohd;
+	struct clk* clock_vdac0;
+	struct clk* clock_vdac1;
+	struct clk* clock_vpll1;
+	struct reset_control* rst_bus;
+	struct reset_control* rst_vohd;
+	void __iomem *regs;
+	int irq;
+	wait_queue_head_t irq_wq;
+	int irq_return_code;
+	unsigned int pseudo_palette[16];
+};
+
+static int hi3515_fb_wait_irq(struct hi3515_fbdev* fbdev) {
+	fbdev->irq_return_code = 0;
+	wait_event_interruptible_timeout(fbdev->irq_wq, fbdev->irq_return_code != 0, msecs_to_jiffies(500));
+	if(fbdev->irq_return_code != 0) {
+		return -1;
+	}
+	return fbdev->irq_return_code;
+}
+
+static void hi3515_fb_configure_vo(struct hi3515_fbdev* fbdev, u32 pixelclk, u32 width, u32 height, u32 fps, bool vsync_rev, bool hsync_rev, u32 vb_fp, u32 vb_bp, u32 hb_bp, u32 hb_fp, u32 hsync_pw, u32 vsync_pw, dma_addr_t buf) {
+	u32 realclk, reg;
+	/*steps to configure:
+	 1. set VO_CTRL and interrupt cfg
+	 2. set VHDLMHSP - VHDCHMVSP
+	 3. set G0CTRL - G0DLPOS
+	 4. set CBMBKG1 - CBCFG
+	 5. set DHDCTRL - DHDCLIPH
+	 6. should be working?
+	 
+	 */
+	writel(0x000000EC, fbdev->regs + 0x0C00);
+	udelay(10);
+	
+	clk_set_rate(fbdev->clock_vpll1, pixelclk);
+	
+	realclk = clk_get_rate(fbdev->clock_vpll1);
+	
+	reg = (1 << 0) | (0b0010 << 8) | (0b0010 << 16);
+	writel(reg, fbdev->regs + 0x0000);
+	
+	reg = 0xffffffff;
+	writel(reg, fbdev->regs + 0x0004); //clear all interrupts
+	
+	reg = (1 << 22) | (1 << 23); //enable G0 and VHD register update interrupts
+	writel(reg, fbdev->regs + 0x0008);
+	
+	udelay(10);
+	
+	//config for WI/WO = 1, HI/HO = 1, phases = 0
+	reg = (0b0001000000000000 << 0) | (0 << 16);
+	writel(reg, fbdev->regs + 0x0158);
+	writel(reg, fbdev->regs + 0x015C);
+	writel(reg, fbdev->regs + 0x0160);
+	writel(reg, fbdev->regs + 0x0164);
+	
+	udelay(10);
+	
+	//using G0 only
+	reg = (0x49 << 0) | (1 << 29) | (1 << 30) | (1 << 31);
+	writel(reg, fbdev->regs + 0x0400);
+	reg = buf;
+	writel(reg, fbdev->regs + 0x0408);
+	// reg = (width << 0); //row stride = rowsize * px_size in bytes
+	reg = (width*2 << 0);
+	writel(reg, fbdev->regs + 0x040C);
+	reg = 0x80; //GLOBAL ALPHA = MAX
+	writel(reg, fbdev->regs + 0x0410);
+	reg = 0;
+	writel(reg, fbdev->regs + 0x0414);
+	writel(reg, fbdev->regs + 0x0418);
+	reg = ((width-1) << 0) | ((height-1) << 16);
+	writel(reg, fbdev->regs + 0x041C);
+	writel(reg, fbdev->regs + 0x0420);
+	writel(reg, fbdev->regs + 0x042C);
+	reg = (0 << 0) | (0 << 16);
+	writel(reg, fbdev->regs + 0x0424);
+	writel(reg, fbdev->regs + 0x0428);
+	
+	udelay(10);
+	
+	//Configuring CB
+	reg = (0x42 << 0) | (0x3a << 8) | (0x4d << 16);
+	writel(reg, fbdev->regs + 0x0B00);
+	writel(reg, fbdev->regs + 0x0B04);
+	reg = (0b001 << 0) | (0b011 << 3) | (0b100 << 6) | (0b010 << 9) | (0b000 << 12) | (0 << 15) | (0 << 24) | (1 << 25) | (0 << 26) | (0 << 27) | (1 << 28) | (1 << 29);
+	writel(reg, fbdev->regs + 0x0B0C);
+	
+	udelay(10);
+	
+	//configuring DHD
+	reg = ((height-1) << 0) | ((vb_bp + vsync_pw-1) << 12) | (vb_fp << 20);
+	writel(reg, fbdev->regs + 0x0C04);
+	udelay(10);
+	reg = ((width-1) << 0) | ((hb_bp+hsync_pw-1) << 16);
+	writel(reg, fbdev->regs + 0x0C08);
+	udelay(10);
+	reg = (hb_fp-1);
+	writel(reg, fbdev->regs + 0x0C0C);
+	udelay(10);
+	reg = 0;
+	writel(reg, fbdev->regs + 0x0C10);
+	udelay(10);
+	reg = ((hsync_pw - 1) << 0) | ((vsync_pw - 1) << 16);
+	writel(reg, fbdev->regs + 0x0C14);
+	udelay(10);
+	reg = 0;
+	writel(reg, fbdev->regs + 0x0C18);
+	udelay(10);
+	reg = 1;
+	writel(reg, fbdev->regs + 0x0C1C);
+	udelay(10);
+	
+	reg = (0xC << 0) | (0b10 << 4) | (1 << 6) | (1 << 7) | (vsync_rev << 8) | (hsync_rev << 9) | (0 << 10) | (0 << 13) | (0 << 14) | (1 << 15) | (0 << 16) | (0b00 << 28) | (0 << 30) | (1 << 31);
+	writel(reg, fbdev->regs + 0x0C00);
+	
+	udelay(10);
+	
+	writel( 1, fbdev->regs + 0x0404);
+	hi3515_fb_wait_irq(fbdev);
+	
+	writel( 1, fbdev->regs + 0x0104);
+	hi3515_fb_wait_irq(fbdev);
+	
+	wmb();
+	
+	dev_dbg(fbdev->dev, "FB CONFIGURED, PIXELCLOCK %d(REAL %d)", pixelclk, realclk);
+	
+}
+
+static irqreturn_t hi3515_fb_irq(int irq, void *data) {
+	struct hi3515_fbdev *fbdev = data;
+	int int_status = readl(fbdev->regs + 0x0004);
+	int_status &= readl(fbdev->regs + 0x0008);
+	
+	if(int_status) {
+		int_status = __fls(int_status);
+		fbdev->irq_return_code = int_status + 1;
+		wake_up_interruptible(&fbdev->irq_wq);
+		writel((1<<int_status), fbdev->regs + 0x0004);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf) {
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+static int hi3515_fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int trans, struct fb_info *info) {
+	struct hi3515_fbdev *fbdev = info->par;
+	u32 val;
+
+	val =  chan_to_field(red,   &info->var.red);
+	val |= chan_to_field(green, &info->var.green);
+	val |= chan_to_field(blue , &info->var.blue);
+	val |= chan_to_field(trans , &info->var.transp);
+	fbdev->pseudo_palette[regno] = val;
+
+	return 0;
+}
+
+static int hi3515_fb_setpar(struct fb_info *info) {
+	struct hi3515_fbdev *fbdev = info->par;
+	
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+	info->fix.line_length = info->var.xres_virtual * info->var.bits_per_pixel / 8;
+	info->screen_size = info->fix.line_length * info->var.yres_virtual;
+	
+	u32 linelen = info->var.xres + info->var.left_margin + info->var.right_margin + info->var.hsync_len;
+	u32 pixclk_hz = div_u64(1000000000000ULL, info->var.pixclock);
+	//dev,pixclk,hor_res,vert_res,fps,vsync_inv,hsync_inv,vert_fp,vert_bp,hor_bp,hor_fp,hor_sync,vert_sync,buff
+	
+	hi3515_fb_configure_vo(fbdev, pixclk_hz, info->var.xres, info->var.yres, 60, !(info->var.sync&FB_SYNC_VERT_HIGH_ACT), (!info->var.sync&FB_SYNC_HOR_HIGH_ACT), info->var.lower_margin / (linelen), info->var.upper_margin / (linelen), info->var.left_margin, info->var.right_margin, info->var.hsync_len, info->var.vsync_len / (linelen), info->fix.smem_start);
+	
+	dev_dbg(fbdev->dev, "Configured FB %dx%d", info->var.xres, info->var.yres);
+	
+	return 0;
+}
+
+
+static int hi3515_fb_mmap(struct fb_info *info, struct vm_area_struct *vma) {
+	unsigned long mmio_pgoff;
+	unsigned long start;
+
+	if (!info)
+		return -ENODEV;
+
+	return vm_iomap_memory(vma, info->fix.smem_start, info->fix.smem_len);
+}
+
+static struct fb_ops hi3515_fb_ops = {
+    .owner        = THIS_MODULE,
+    .fb_read	= fb_sys_read,
+    .fb_write	= fb_sys_write,
+    .fb_mmap	= hi3515_fb_mmap,
+    .fb_fillrect	= sys_fillrect,
+    .fb_copyarea	= sys_copyarea,
+    .fb_imageblit	= sys_imageblit,
+    .fb_setcolreg	= hi3515_fb_setcolreg,
+    .fb_set_par		= hi3515_fb_setpar,
+};
+
+struct hi3515_fb_videomode {
+	const char *name;
+	u32 refresh;		/* optional */
+	u32 xres;
+	u32 yres;
+	u32 vert_back_porch;
+	u32 vert_front_porch;
+	u32 hor_back_porch;
+	u32 hor_front_porch;
+	u32 vert_sync;
+	u32 hor_sync;
+	bool vsync_pos;
+	bool hsync_pos;
+};
+
+static const struct hi3515_fb_videomode hi3515_fb_videomodes[] = {
+	{"1440x900@60", 60, 1440, 900, 17, 3, 80, 48, 6, 32, false, true},
+	{"800x600@60", 60, 800, 600, 23, 1, 88, 40, 4, 128, true, true},
+	{"640x480@60", 60, 640, 480, 25, 2, 40, 8, 2, 96, false, false},
+};
+
+static int hi3515_fb_probe(struct platform_device *pdev) {
+	struct device *dev = &pdev->dev;
+	struct clk* clock_bus;
+	struct clk* clock_vohd;
+	struct clk* clock_vdac0;
+	struct clk* clock_vdac1;
+	struct clk* clock_vpll1;
+	struct reset_control* rst_bus;
+	struct reset_control* rst_vohd;
+	void __iomem *regs;
+	struct hi3515_fbdev* fbdev;
+	int irq;
+	struct fb_info *info;
+	void* buffer;
+	dma_addr_t buff_dma_addr;
+	struct fb_videomode *videomodes;
+	int videomode_num;
+	u32 linelen;
+	
+	clock_bus = devm_clk_get(dev, "bus");
+	if(!IS_ERR(clock_bus)) {
+		clk_prepare_enable(clock_bus);
+	} else {
+		dev_err(dev, "NO VALID BUS CLOCK SPECIFIED!");
+		return PTR_ERR(clock_bus);
+	}
+	
+	clock_vohd = devm_clk_get(dev, "vohd");
+	if(!IS_ERR(clock_vohd)) {
+		clk_prepare_enable(clock_vohd);
+	} else {
+		dev_err(dev, "NO VALID VOHD CLOCK SPECIFIED!");
+		return PTR_ERR(clock_vohd);
+	}
+	
+	clock_vdac0 = devm_clk_get(dev, "vdac0");
+	if(!IS_ERR(clock_vdac0)) {
+		clk_prepare_enable(clock_vdac0);
+	} else {
+		dev_err(dev, "NO VALID VDAC0 CLOCK SPECIFIED!");
+		return PTR_ERR(clock_vdac0);
+	}
+	
+	clock_vdac1 = devm_clk_get(dev, "vdac1");
+	if(!IS_ERR(clock_vdac1)) {
+		clk_prepare_enable(clock_vdac1);
+	} else {
+		dev_err(dev, "NO VALID VDAC1 CLOCK SPECIFIED!");
+		return PTR_ERR(clock_vdac1);
+	}
+	
+	clock_vpll1 = devm_clk_get(dev, "vpll1");
+	if(!IS_ERR(clock_vpll1)) {
+		clk_prepare_enable(clock_vpll1);
+	} else {
+		dev_err(dev, "NO VALID VPLL1 CLOCK SPECIFIED!");
+		return PTR_ERR(clock_vpll1);
+	}
+	
+	rst_bus = devm_reset_control_get_by_index(dev, 0);
+	if (IS_ERR(rst_bus)) {
+		dev_err(dev, "NO VALID RST BUS SPECIFIED!");
+		return PTR_ERR(rst_bus);
+	}
+	
+	rst_vohd = devm_reset_control_get_by_index(dev, 1);
+	if (IS_ERR(rst_vohd)) {
+		dev_err(dev, "NO VALID RST VOHD SPECIFIED!");
+		return PTR_ERR(rst_vohd);
+	}
+	
+	regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+	
+	
+
+	reset_control_assert(rst_bus);
+	reset_control_assert(rst_vohd);
+	mdelay(10);
+	reset_control_deassert(rst_bus);
+	reset_control_deassert(rst_vohd);
+	
+	info = framebuffer_alloc(sizeof(struct hi3515_fbdev), dev);
+	if(!info)
+		return -ENOMEM;
+	
+	fbdev = info->par;
+	
+	fbdev->dev = dev;
+	fbdev->clock_bus = clock_bus;
+	fbdev->clock_vohd = clock_vohd;
+	fbdev->clock_vdac0 = clock_vdac0;
+	fbdev->clock_vdac1 = clock_vdac1;
+	fbdev->clock_vpll1 = clock_vpll1;
+	fbdev->rst_bus = rst_bus;
+	fbdev->rst_vohd = rst_vohd;
+	fbdev->regs = regs;
+	
+	init_waitqueue_head(&fbdev->irq_wq);
+	
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+	
+	if(devm_request_irq(dev, irq, hi3515_fb_irq, 0, "hi3515_fb", fbdev))
+		return -EINVAL;
+	
+	fbdev->irq = irq;
+	
+	info->device = dev;
+	
+	info->fbops = &hi3515_fb_ops;
+	
+	info->flags |= FBINFO_VIRTFB;
+	
+	info->var.bits_per_pixel = 16;
+	info->var.red.offset = 10;
+	info->var.red.length = 5;
+	info->var.green.offset = 5;
+	info->var.green.length = 5;
+	info->var.blue.offset = 0;
+	info->var.blue.length = 5;
+	info->var.transp.offset = 15;
+	info->var.transp.length = 1;
+	
+	videomode_num = ARRAY_SIZE(hi3515_fb_videomodes);
+	
+	videomodes = kcalloc(videomode_num, sizeof(struct fb_videomode),
+			     GFP_KERNEL);
+	if (!videomodes)
+		return -ENOMEM;
+	
+	for(int i = 0; i < videomode_num; i++) {
+		videomodes[i].name = hi3515_fb_videomodes[i].name;
+		videomodes[i].refresh = hi3515_fb_videomodes[i].refresh;
+		videomodes[i].xres = hi3515_fb_videomodes[i].xres;
+		videomodes[i].yres = hi3515_fb_videomodes[i].yres;
+		
+		videomodes[i].left_margin = hi3515_fb_videomodes[i].hor_back_porch;
+		videomodes[i].right_margin = hi3515_fb_videomodes[i].hor_front_porch;
+		videomodes[i].hsync_len = hi3515_fb_videomodes[i].hor_sync;
+		
+		linelen = videomodes[i].xres + videomodes[i].left_margin + videomodes[i].right_margin + videomodes[i].hsync_len;
+		
+		videomodes[i].upper_margin = hi3515_fb_videomodes[i].vert_back_porch * (linelen);
+		videomodes[i].lower_margin = hi3515_fb_videomodes[i].vert_front_porch * (linelen);
+		videomodes[i].vsync_len = hi3515_fb_videomodes[i].vert_sync * (linelen);
+		videomodes[i].pixclock = div_u64(1000000000000ULL, (videomodes[i].refresh * (linelen) * (videomodes[i].yres + ((videomodes[i].upper_margin + videomodes[i].lower_margin + videomodes[i].vsync_len) / (linelen)))));
+		videomodes[i].sync = (hi3515_fb_videomodes[i].hsync_pos ? FB_SYNC_HOR_HIGH_ACT : 0) | (hi3515_fb_videomodes[i].vsync_pos ? FB_SYNC_VERT_HIGH_ACT : 0);
+		videomodes[i].vmode = FB_VMODE_NONINTERLACED;
+		videomodes[i].flag = 0;
+	}
+	
+	fb_videomode_to_modelist(videomodes, videomode_num, &info->modelist);
+	
+	fb_videomode_to_var(&info->var, &videomodes[2]);
+
+	/* Allocate framebuffer memory: size = modes xy *4 */
+	info->fix.smem_len = 1440 * 900 * 16 / 8;
+			
+	buffer = dma_alloc_coherent(dev, PAGE_ALIGN(info->fix.smem_len), &buff_dma_addr, GFP_KERNEL);
+	if (buffer == NULL) {
+		dev_err(dev, "can't alloc framebuffer\n");
+		return -ENOMEM;
+	}
+	
+	info->node = -1;
+	
+	strcpy(info->fix.id, "HI3515_VGA");
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+	info->fix.accel = FB_ACCEL_NONE;
+	info->fix.line_length = info->var.xres_virtual * info->var.bits_per_pixel / 8;
+	info->fix.smem_start = buff_dma_addr;
+	
+	info->pseudo_palette = fbdev->pseudo_palette;
+	
+	info->screen_buffer = buffer;
+	info->screen_size = info->fix.line_length * info->var.yres_virtual;
+	
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0)
+		return -ENOMEM;
+	
+	dev_dbg(dev, "FRAMEBUFFER ADDR 0x%x - 0x%lx VIRT 0x%x - 0x%lx SZ 0x%lx", buff_dma_addr, buff_dma_addr+info->screen_size, (uint32_t)info->screen_buffer, ((uint32_t)info->screen_buffer)+info->screen_size, info->screen_size);
+	
+	for(int i = 0; i < info->screen_size/2; i++) {
+		((uint16_t*)info->screen_buffer)[i] = ((i/8)%2) ? 0xffff : 0x0000;
+	}
+	
+	dev_set_drvdata(dev, info);
+	
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_autosuspend_delay(dev, 500);
+
+	irq = pm_runtime_set_active(dev);
+	if (irq)
+		return irq;
+	pm_runtime_enable(dev);
+	
+	if(register_framebuffer(info) < 0) {
+		dev_err(dev, "FAILED TO REG FRAMEBUFFER");
+		return -EINVAL;
+	}
+	
+	dev_info(dev, "VGA VO initialized");
+	
+	return 0;
+}
+
+static int hi3515_fb_suspend(struct device *dev) {
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct hi3515_fbdev* fbdev = info->par;
+	reset_control_assert(fbdev->rst_bus);
+	reset_control_assert(fbdev->rst_vohd);
+	mdelay(10);
+	reset_control_deassert(fbdev->rst_bus);
+	reset_control_deassert(fbdev->rst_vohd);
+	mdelay(10);
+	clk_disable_unprepare(fbdev->clock_bus);
+	clk_disable_unprepare(fbdev->clock_vdac0);
+	clk_disable_unprepare(fbdev->clock_vdac1);
+	clk_disable_unprepare(fbdev->clock_vohd);
+	clk_disable_unprepare(fbdev->clock_vpll1);
+	return 0;
+}
+
+static int hi3515_fb_resume(struct device *dev) {
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct hi3515_fbdev* fbdev = info->par;
+	clk_prepare_enable(fbdev->clock_bus);
+	clk_prepare_enable(fbdev->clock_vdac0);
+	clk_prepare_enable(fbdev->clock_vdac1);
+	clk_prepare_enable(fbdev->clock_vohd);
+	clk_prepare_enable(fbdev->clock_vpll1);
+	reset_control_assert(fbdev->rst_bus);
+	reset_control_assert(fbdev->rst_vohd);
+	mdelay(10);
+	reset_control_deassert(fbdev->rst_bus);
+	reset_control_deassert(fbdev->rst_vohd);
+	mdelay(10);
+	hi3515_fb_setpar(info);
+	return 0;
+}
+
+static const struct dev_pm_ops hi3515_fb_pm_ops = {
+	SET_RUNTIME_PM_OPS(hi3515_fb_suspend, hi3515_fb_resume, NULL)
+};
+
+static const __maybe_unused struct of_device_id hi3515_fb_match[] = {
+	{ .compatible = "hisilicon,hi3515vgafb" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, hi3515_fb_match);
+
+static struct platform_driver hi3515_fb_driver = {
+	.probe = hi3515_fb_probe,
+	.driver = {
+		.name = "hi3515_fb_platform_driver",
+		.of_match_table = hi3515_fb_match,
+		.pm = &hi3515_fb_pm_ops,
+	},
+};
+
+module_platform_driver(hi3515_fb_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("HiSilicon HI3515 VGA Framebuffer");
+MODULE_AUTHOR("Indir Wolf");
diff --no-dereference -ruN linux-master/drivers/video/fbdev/Makefile linux-master-mod/drivers/video/fbdev/Makefile
--- linux-master/drivers/video/fbdev/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/drivers/video/fbdev/Makefile	2024-10-26 20:45:07.077299542 +0300
@@ -115,6 +115,8 @@
 obj-$(CONFIG_FB_OPENCORES)	  += ocfb.o
 obj-$(CONFIG_FB_SM712)		  += sm712fb.o
 
+obj-$(CONFIG_ARCH_HI3515V100)     += hi3515-fb.o
+
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
 obj-$(CONFIG_FB_VESA)             += vesafb.o
diff --no-dereference -ruN linux-master/.hil_config linux-master-mod/.hil_config
--- linux-master/.hil_config	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/.hil_config	2024-10-15 01:42:58.215606228 +0300
@@ -0,0 +1,4 @@
+ARCH=arm
+CROSS_COMPILE=arm-linux-gnueabi-
+INSTALL_PATH=
+INSTALL_MOD_PATH=
diff --no-dereference -ruN linux-master/include/dt-bindings/clock/hi3515-clock.h linux-master-mod/include/dt-bindings/clock/hi3515-clock.h
--- linux-master/include/dt-bindings/clock/hi3515-clock.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/include/dt-bindings/clock/hi3515-clock.h	2024-10-20 20:54:19.521225812 +0300
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2024 Indir Wolf
+ */
+
+#ifndef __DTS_HI3515_CLOCK_H
+#define __DTS_HI3515_CLOCK_H
+
+#define HI3515_PER_CLK_SATA 1
+#define HI3515_PER_CLK_CIPHER 2
+#define HI3515_PER_CLK_SMI 3
+#define HI3515_PER_CLK_UART0 4
+#define HI3515_PER_CLK_UART1 5
+#define HI3515_PER_CLK_UART2 6
+#define HI3515_PER_CLK_UART3 7
+#define HI3515_PER_CLK_SIO0 8
+#define HI3515_PER_CLK_SIO1 9
+#define HI3515_PER_CLK_IR 11
+#define HI3515_PER_CLK_MMC 14
+#define HI3515_PER_CLK_TDE 15
+#define HI3515_PER_CLK_VIBUS 16
+#define HI3515_PER_CLK_VI0 17
+#define HI3515_PER_CLK_VI1 18
+#define HI3515_PER_CLK_VI2 19
+#define HI3515_PER_CLK_VI3 20
+#define HI3515_PER_CLK_ETH 21
+#define HI3515_PER_CLK_USB 22
+#define HI3515_PER_CLK_VOBUS 23
+#define HI3515_PER_CLK_VOSD 24
+#define HI3515_PER_CLK_VOHD 25
+#define HI3515_PER_CLK_NANDC 27
+#define HI3515_PER_CLK_SSP 29
+#define HI3515_PER_CLK_VDAC0 30
+#define HI3515_PER_CLK_VDAC1 31
+
+#define HI3515_PER_CLK_CNT 32
+
+#define HI3515_SOFTRST_SSMC 4
+#define HI3515_SOFTRST_CIPHER 5
+#define HI3515_SOFTRST_UART0 6
+#define HI3515_SOFTRST_UART1 7
+#define HI3515_SOFTRST_UART2 8
+#define HI3515_SOFTRST_UART3 9
+#define HI3515_SOFTRST_IR 10
+#define HI3515_SOFTRST_RTC 11
+#define HI3515_SOFTRST_I2C 12
+#define HI3515_SOFTRST_MMC 14
+#define HI3515_SOFTRST_SIO0 15
+#define HI3515_SOFTRST_SIO1 16
+#define HI3515_SOFTRST_ETH 18
+#define HI3515_SOFTRST_VIBUS 21
+#define HI3515_SOFTRST_VI0 22
+#define HI3515_SOFTRST_VI1 23
+#define HI3515_SOFTRST_VI2 24
+#define HI3515_SOFTRST_VI3 25
+#define HI3515_SOFTRST_VOBUS 26
+#define HI3515_SOFTRST_VOSD 28
+#define HI3515_SOFTRST_VOHD 29
+#define HI3515_SOFTRST_USB 30
+#define HI3515_SOFTRST_USBPORT 31
+
+#define HI3515_SOFTRST_TDEBUS 32
+#define HI3515_SOFTRST_TDE 33
+#define HI3515_SOFTRST_NANDC 34
+#define HI3515_SOFTRST_SPI 36
+#define HI3515_SOFTRST_DDR 37
+#define HI3515_SOFTRST_DMA 38
+#define HI3515_SOFTRST_SATA 49
+#define HI3515_SOFTRST_SATABUS 50
+#define HI3515_SOFTRST_SATAPHY 51
+#define HI3515_SOFTRST_SATATX0 52
+#define HI3515_SOFTRST_SATATX1 53
+#define HI3515_SOFTRST_SATARX0 54
+#define HI3515_SOFTRST_SATARX1 55
+#define HI3515_SOFTRST_SATAALIVE 56
+
+#define HI3515_SOFTRST_CNT 57
+
+#define HI3515_DMAREQ_SIO0_RX 0
+#define HI3515_DMAREQ_SIO0_TX 1
+#define HI3515_DMAREQ_SIO1_RX 2
+#define HI3515_DMAREQ_SIO1_TX 3
+#define HI3515_DMAREQ_UART_RX 4
+#define HI3515_DMAREQ_UART_TX 5
+#define HI3515_DMAREQ_SPI_RX 6
+#define HI3515_DMAREQ_SPI_TX 7
+#define HI3515_DMAREQ_MMC_RX 8
+#define HI3515_DMAREQ_MMC_TX 9
+#define HI3515_DMAREQ_UART0_RX 10
+#define HI3515_DMAREQ_UART0_TX 11
+#define HI3515_DMAREQ_UART1_RX 12
+#define HI3515_DMAREQ_UART1_TX 13
+#define HI3515_DMAREQ_UART2_RX 14
+#define HI3515_DMAREQ_UART2_TX 15
+
+#endif	/* __DTS_HI3515_CLOCK_H */
diff --no-dereference -ruN linux-master/include/linux/himedia.h linux-master-mod/include/linux/himedia.h
--- linux-master/include/linux/himedia.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/include/linux/himedia.h	2024-10-15 01:41:03.217560567 +0300
@@ -0,0 +1,28 @@
+#ifndef _LINUX_HIMEDIA_DEVICE_H
+#define _LINUX_HIMEDIA_DEVICE_H
+#include <linux/module.h>
+#include <linux/major.h>
+
+#define HIMEDIA_DEVICE_MAJOR 218
+#define HIMEDIA_DYNAMIC_MINOR 255
+
+struct device;
+struct class_device;
+
+struct himedia_device  {
+	int minor;
+	const char *name;
+	const struct file_operations *fops;
+	struct list_head list;
+	struct device *parent;
+	struct device *this_device;
+};
+
+extern int himedia_register(struct himedia_device *);
+extern int himedia_deregister(struct himedia_device *);
+
+#define MODULE_ALIAS_HIMEDIA(minor)				\
+	MODULE_ALIAS("himedia-char-major-" __stringify(HIMEDIA_DEVICE_MAJOR)	\
+	"-" __stringify(minor))
+#endif
+
diff --no-dereference -ruN linux-master/include/linux/irqchip/irq-hi3515v100-intc.h linux-master-mod/include/linux/irqchip/irq-hi3515v100-intc.h
--- linux-master/include/linux/irqchip/irq-hi3515v100-intc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/include/linux/irqchip/irq-hi3515v100-intc.h	2024-10-17 21:57:59.434400921 +0300
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2024 Indir Wolf
+ */
+
+#ifndef _LINUX_IRQ_HI3515_INTC_
+#define _LINUX_IRQ_HI3515_INTC_
+
+#include <linux/ioport.h>
+
+#define REG_HI3515_INTC_IRQSTATUS  	0x000
+#define REG_HI3515_INTC_FIQSTATUS  	0x004
+#define REG_HI3515_INTC_RAWINTR    	0x008
+#define REG_HI3515_INTC_INTSELECT  	0x00C
+#define REG_HI3515_INTC_INTENABLE  	0x010
+#define REG_HI3515_INTC_INTENCLEAR 	0x014
+#define REG_HI3515_INTC_SOFTINT    	0x018
+#define REG_HI3515_INTC_SOFTINTCLEAR 	0x01C
+#define REG_HI3515_INTC_PROTECTION 	0x020
+
+int hi3515_intc_init(struct resource res, struct device_node *node);
+
+#endif /* _LINUX_IRQ_HI3515_INTC_ */
diff --no-dereference -ruN linux-master/init/main.c linux-master-mod/init/main.c
--- linux-master/init/main.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/init/main.c	2024-11-02 20:52:27.542019176 +0300
@@ -1538,7 +1538,7 @@
 	struct file *file = filp_open("/dev/console", O_RDWR, 0);
 
 	if (IS_ERR(file)) {
-		pr_err("Warning: unable to open an initial console.\n");
+		pr_err("Warning: unable to open an initial console: %d\n", PTR_ERR(file));
 		return;
 	}
 	init_dup(file);
diff --no-dereference -ruN linux-master/kernel/irq/handle.c linux-master-mod/kernel/irq/handle.c
--- linux-master/kernel/irq/handle.c	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/kernel/irq/handle.c	2024-10-16 22:56:15.492765823 +0300
@@ -214,6 +214,8 @@
 	return ret;
 }
 
+#include <mach/early-debug.h>
+
 #ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER
 int __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
 {
@@ -231,12 +233,17 @@
  */
 asmlinkage void noinstr generic_handle_arch_irq(struct pt_regs *regs)
 {
+	// edb_putstr("IA\n");
 	struct pt_regs *old_regs;
-
+	// edb_putstr("IB\n");
 	irq_enter();
+	// edb_putstr("IC\n");
 	old_regs = set_irq_regs(regs);
+	// edb_putstr("ID\n");
 	handle_arch_irq(regs);
+	// edb_putstr("IE\n");
 	set_irq_regs(old_regs);
+	// edb_putstr("IF\n");
 	irq_exit();
 }
 #endif
diff --no-dereference -ruN linux-master/Makefile linux-master-mod/Makefile
--- linux-master/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/Makefile	2024-10-15 01:46:37.171882755 +0300
@@ -5,6 +5,8 @@
 EXTRAVERSION = -rc3
 NAME = Baby Opossum Posse
 
+HIL_CONFIG_FILE=.hil_config
+
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
 # More info can be located in ./README
@@ -378,7 +380,14 @@
 # Alternatively CROSS_COMPILE can be set in the environment.
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
-ARCH		?= $(SUBARCH)
+ARCH		?= $(shell if [ -f $(HIL_CONFIG_FILE) ]; then \
+				cat $(HIL_CONFIG_FILE) | grep ARCH= | sed -n s/ARCH=//p; \
+			else \
+				echo $(SUBARCH); \
+			fi)
+CROSS_COMPILE	?= $(shell if [ -f $(HIL_CONFIG_FILE) ]; then \
+				cat $(HIL_CONFIG_FILE) | grep CROSS_COMPILE= | sed -n s/CROSS_COMPILE=//p; \
+			fi)
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -673,9 +682,11 @@
 export KBUILD_DEFCONFIG KBUILD_KCONFIG CC_VERSION_TEXT RUSTC_VERSION_TEXT
 
 config: outputmakefile scripts_basic FORCE
+	$(Q)mkdir -p include/linux include/config
 	$(Q)$(MAKE) $(build)=scripts/kconfig $@
 
 %config: outputmakefile scripts_basic FORCE
+	$(Q)mkdir -p include/linux include/config
 	$(Q)$(MAKE) $(build)=scripts/kconfig $@
 
 else #!config-build
@@ -1078,7 +1089,9 @@
 #
 # INSTALL_PATH specifies where to place the updated kernel and system map
 # images. Default is /boot, but you can set it to other values
-export	INSTALL_PATH ?= /boot
+export	INSTALL_PATH ?= $(shell if [ -f $(HIL_CONFIG_FILE) ]; then \
+				cat $(HIL_CONFIG_FILE) | grep INSTALL_PATH= | sed -n s/INSTALL_PATH=//p; \
+			fi)
 
 #
 # INSTALL_DTBS_PATH specifies a prefix for relocations required by build roots.
@@ -1093,6 +1106,10 @@
 # makefile but the argument can be passed to make if needed.
 #
 
+INSTALL_MOD_PATH := $(shell if [ -f $(HIL_CONFIG_FILE) ]; then \
+				cat $(HIL_CONFIG_FILE) | grep INSTALL_MOD_PATH= | sed -n s/INSTALL_MOD_PATH=//p; \
+			fi)
+
 MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
 export MODLIB
 
Файл linux-master/scripts/dtc/include-prefixes/dt-bindings это обычный файл, тогда как файл linux-master-mod/scripts/dtc/include-prefixes/dt-bindings ? символьная ссылка
diff --no-dereference -ruN linux-master/sound/soc/codecs/Kconfig linux-master-mod/sound/soc/codecs/Kconfig
--- linux-master/sound/soc/codecs/Kconfig	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/sound/soc/codecs/Kconfig	2024-10-30 18:35:22.493878230 +0300
@@ -2097,6 +2097,14 @@
 	help
 	  Add support for Tempo Semiconductor's TSCS454 audio CODEC.
 
+config SND_SOC_TW2868
+	tristate "TW2868 CODEC"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  Add support for TW2868 audio CODEC.
+
+
 config SND_SOC_TWL4030
 	tristate
 	depends on TWL4030_CORE
diff --no-dereference -ruN linux-master/sound/soc/codecs/Makefile linux-master-mod/sound/soc/codecs/Makefile
--- linux-master/sound/soc/codecs/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/sound/soc/codecs/Makefile	2024-10-30 18:36:25.022442235 +0300
@@ -316,6 +316,7 @@
 snd-soc-tscs42xx-y := tscs42xx.o
 snd-soc-tscs454-y := tscs454.o
 snd-soc-ts3a227e-y := ts3a227e.o
+snd-soc-tw2868-y := tw2868.o
 snd-soc-twl4030-y := twl4030.o
 snd-soc-twl6040-y := twl6040.o
 snd-soc-uda1334-y := uda1334.o
@@ -720,6 +721,7 @@
 obj-$(CONFIG_SND_SOC_TSCS42XX)	+= snd-soc-tscs42xx.o
 obj-$(CONFIG_SND_SOC_TSCS454)	+= snd-soc-tscs454.o
 obj-$(CONFIG_SND_SOC_TS3A227E)	+= snd-soc-ts3a227e.o
+obj-$(CONFIG_SND_SOC_TW2868)	+= snd-soc-tw2868.o
 obj-$(CONFIG_SND_SOC_TWL4030)	+= snd-soc-twl4030.o
 obj-$(CONFIG_SND_SOC_TWL6040)	+= snd-soc-twl6040.o
 obj-$(CONFIG_SND_SOC_UDA1334)	+= snd-soc-uda1334.o
diff --no-dereference -ruN linux-master/sound/soc/codecs/tw2868.c linux-master-mod/sound/soc/codecs/tw2868.c
--- linux-master/sound/soc/codecs/tw2868.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/sound/soc/codecs/tw2868.c	2024-11-23 19:16:53.255932528 +0300
@@ -0,0 +1,343 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Indir Wolf
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/acpi.h>
+
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/soc.h>
+
+#include <linux/io-mapping.h>
+#include <linux/proc_fs.h>
+#include <linux/pm_runtime.h>
+
+struct tw2868 {
+	struct device *dev;
+	struct regmap *regmap;
+	struct gpio_desc *gpio_amp_en;
+	bool curr_page;
+};
+
+static inline void tw2868_write_reg(struct tw2868* tw2868, bool page, uint8_t reg, uint8_t val) {
+	if(page != tw2868->curr_page) {
+		tw2868->curr_page = page;
+		regmap_write(tw2868->regmap, 0x00, page);
+	}
+	regmap_write(tw2868->regmap, reg, val);
+}
+
+static inline uint8_t tw2868_read_reg(struct tw2868* tw2868, bool page, uint8_t reg) {
+	uint32_t val;
+	if(page != tw2868->curr_page) {
+		tw2868->curr_page = page;
+		regmap_write(tw2868->regmap, 0x00, page);
+	}
+	regmap_read(tw2868->regmap, reg, &val);
+	return val;
+}
+
+static void tw2868_config_generic(struct tw2868* tw2868) {
+	//reset
+	tw2868_write_reg(tw2868, 0, 0x80, 0x7f);
+	
+	tw2868_write_reg(tw2868, 0, 0xce, 0x00);
+	
+}
+
+static void tw2868_config_video(struct tw2868* tw2868) {
+	//TODO
+}
+
+static void tw2868_config_audio(struct tw2868* tw2868, uint8_t again, uint32_t dgain, uint8_t aogain) {
+	tw2868_write_reg(tw2868, 0, 0xcf, 0x00);
+	
+	again = again & 0b1111;
+	tw2868_write_reg(tw2868, 0, 0xd0, again | (again << 4));
+	tw2868_write_reg(tw2868, 0, 0xd1, again | (again << 4));
+	tw2868_write_reg(tw2868, 0, 0x7f, 0);
+	
+	tw2868_write_reg(tw2868, 0, 0xd2, (0b00 << 0) | (0b00 << 2) | (0b00 << 4) | (0 << 6) | (0 << 7));
+	tw2868_write_reg(tw2868, 0, 0xd3, (0 << 0) | (0 << 4));
+	tw2868_write_reg(tw2868, 0, 0xdb, (0 << 0) | (1 << 1) | (0 << 2) | (0 << 3) | (0 << 4) | (0 << 5) | (0b11 << 6));
+	tw2868_write_reg(tw2868, 0, 0xdc, (0b0000 << 0) | (1 << 5) | (0 << 6));
+	tw2868_write_reg(tw2868, 0, 0x7e, 0b10100011);
+	
+	dgain = dgain & 0b1111;
+	tw2868_write_reg(tw2868, 0, 0x72, dgain | (0<<4) | (1<<5) | (0<<6) | (0 << 7));
+	
+	tw2868_write_reg(tw2868, 0, 0xdd, 0b00001111);
+	tw2868_write_reg(tw2868, 0, 0xde, 0);
+	
+	aogain = aogain & 0b1111;
+	tw2868_write_reg(tw2868, 0, 0xdf, 0b1000 | (aogain << 4));
+	
+	tw2868_write_reg(tw2868, 0, 0xe0, 0x10);
+	tw2868_write_reg(tw2868, 0, 0x70, 0b00001100);
+	tw2868_write_reg(tw2868, 0, 0x71, 0b01000000);
+	tw2868_write_reg(tw2868, 0, 0x7b, 0x10);
+	tw2868_write_reg(tw2868, 0, 0x7c, 0x00);
+	tw2868_write_reg(tw2868, 0, 0x89, 0b00000001);
+	tw2868_write_reg(tw2868, 0, 0x50, 0b00000000);
+	tw2868_write_reg(tw2868, 0, 0x51, 0x00);
+	tw2868_write_reg(tw2868, 0, 0x52, 0x00);
+	
+	tw2868_write_reg(tw2868, 0, 0xf3, 0x00);
+	tw2868_write_reg(tw2868, 0, 0xf4, 0x01);
+	tw2868_write_reg(tw2868, 0, 0xf5, 0x00);
+	//page0 done?
+	
+}
+
+static const struct regmap_config tw2868_regmap_config = {
+	.val_bits = 8,
+	.reg_bits = 8,
+
+	.max_register = 0xff,
+
+	.cache_type = REGCACHE_NONE,
+};
+
+static struct snd_soc_dai_driver tw2868_dai = {
+	.name		= "tw2868",
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_U16_LE,
+	},
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_U16_LE,
+	},
+};
+
+
+static const struct snd_soc_component_driver tw2868_soc_driver = {
+	.name = "renesas,tw2868",
+};
+
+struct tw2868 *_gtw2868;
+
+static ssize_t write_proc(struct file *file, const char __user * buffer, size_t count, loff_t * ppos) {
+	struct tw2868 *tw2868 = _gtw2868;
+	uint8_t in_arr[7];
+	uint8_t reg = 0;
+	uint8_t val = 0;
+	pr_info("proc file write %d\n", count);
+	if(count != 2+1+2+1) return -EINVAL;
+	
+	copy_from_user(in_arr,buffer,count);
+	
+	if(in_arr[0] >= '0' && in_arr[0] <= '9') {
+		reg |= (in_arr[0] - '0') << 4;
+	} else if(in_arr[0] >= 'a' && in_arr[0] <= 'f') {
+		reg |= (10 + in_arr[0] - 'a') << 4;
+	} else if(in_arr[0] >= 'A' && in_arr[0] <= 'F') {
+		reg |= (10 + in_arr[0] - 'A') << 4;
+	} else {
+		pr_err("Wrong char: %c\n", in_arr[0]);
+		return -EINVAL;
+	}
+	
+	if(in_arr[1] >= '0' && in_arr[1] <= '9') {
+		reg |= (in_arr[1] - '0');
+	} else if(in_arr[1] >= 'a' && in_arr[1] <= 'f') {
+		reg |= (10 + in_arr[1] - 'a');
+	} else if(in_arr[1] >= 'A' && in_arr[1] <= 'F') {
+		reg |= (10 + in_arr[1] - 'A');
+	} else {
+		pr_err("Wrong char: %c\n", in_arr[1]);
+		return -EINVAL;
+	}
+	
+	if(in_arr[3] >= '0' && in_arr[3] <= '9') {
+		val |= (in_arr[3] - '0') << 4;
+	} else if(in_arr[3] >= 'a' && in_arr[3] <= 'f') {
+		val |= (10 + in_arr[3] - 'a') << 4;
+	} else if(in_arr[3] >= 'A' && in_arr[3] <= 'F') {
+		val |= (10 + in_arr[3] - 'A') << 4;
+	} else {
+		pr_err("Wrong char: %c\n", in_arr[3]);
+		return -EINVAL;
+	}
+	
+	if(in_arr[4] >= '0' && in_arr[4] <= '9') {
+		val |= (in_arr[4] - '0');
+	} else if(in_arr[4] >= 'a' && in_arr[4] <= 'f') {
+		val |= (10 + in_arr[4] - 'a');
+	} else if(in_arr[4] >= 'A' && in_arr[4] <= 'F') {
+		val |= (10 + in_arr[4] - 'A');
+	} else {
+		pr_err("Wrong char: %c\n", in_arr[4]);
+		return -EINVAL;
+	}
+	
+	regmap_write(tw2868->regmap, reg, val);
+	
+	pr_info("WRITTEN REG 0x%x => 0x%x\n", reg, val);
+	
+	return count;
+}
+
+static struct proc_ops procfops = {
+    .proc_write = write_proc,
+};
+
+static int tw2868_i2c_probe(struct i2c_client *i2c) {
+	struct tw2868 *tw2868;
+	struct device *dev = &i2c->dev;
+	int ret;
+	
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_info(dev, "Deferring probe");
+		return -EPROBE_DEFER;  // This will cause probe to be retried later
+	}
+
+	tw2868 = devm_kzalloc(&i2c->dev, sizeof(*tw2868), GFP_KERNEL);
+	if (!tw2868)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, tw2868);
+	tw2868->dev = dev;
+	
+	dev_set_drvdata(dev, tw2868);
+
+	tw2868->regmap = devm_regmap_init_i2c(i2c, &tw2868_regmap_config);
+	if (IS_ERR(tw2868->regmap))
+		return PTR_ERR(tw2868->regmap);
+	
+	tw2868->curr_page = 0;
+	
+	tw2868->gpio_amp_en = devm_fwnode_gpiod_get_index(dev, of_fwnode_handle(dev->of_node), "amp-en", 0, GPIOD_OUT_LOW,fwnode_get_name(of_fwnode_handle(dev->of_node)));
+	if(IS_ERR(tw2868->gpio_amp_en)) {
+		dev_info(dev, "GPIO_AMP_EN is missing: %d", PTR_ERR(tw2868->gpio_amp_en));
+		tw2868->gpio_amp_en = NULL;
+	} else {
+		gpiod_set_value_cansleep(tw2868->gpio_amp_en, 0);
+	}
+	
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_autosuspend_delay(dev, 500);
+
+	ret = pm_runtime_set_suspended(dev);
+	if (ret)
+		return ret;
+	pm_runtime_enable(dev);
+	
+	
+	// printk("Registers initial values PAGE 1:\n");
+	// regmap_write(tw2868->regmap, 0x00, 1);
+	// for(int i = 0; i < 16; i++) {
+	// 	printk("REG 0x%x-0x%x:    ", i*16, (i+1)*16-1);
+	// 	for(int k = 0; k < 16; k++) {
+	// 		u32 x;
+	// 		regmap_read(tw2868->regmap, i*16+k, &x);
+	// 		printk(KERN_CONT " 0x%x", x);
+	// 	}
+	// }
+	// printk("Registers initial values PAGE 0:\n");
+	regmap_write(tw2868->regmap, 0x00, 0x00);
+	// for(int i = 0; i < 16; i++) {
+	// 	printk("REG 0x%x-0x%x:    ", i*16, (i+1)*16-1);
+	// 	for(int k = 0; k < 16; k++) {
+	// 		u32 x;
+	// 		regmap_read(tw2868->regmap, i*16+k, &x);
+	// 		printk(KERN_CONT " 0x%x", x);
+	// 	}
+	// }
+	
+	tw2868_config_generic(tw2868);
+	
+	tw2868_config_video(tw2868);
+	
+	tw2868_config_audio(tw2868, 0b1111, 0b1111, 0b1111);
+	
+	// printk("Registers configured values PAGE 0:\n");
+	// regmap_write(tw2868->regmap, 0x00, 0x00);
+	// for(int i = 0; i < 16; i++) {
+	// 	printk("REG 0x%x-0x%x:    ", i*16, (i+1)*16-1);
+	// 	for(int k = 0; k < 16; k++) {
+	// 		u32 x;
+	// 		regmap_read(tw2868->regmap, i*16+k, &x);
+	// 		printk(KERN_CONT " 0x%x", x);
+	// 	}
+	// }
+	
+	_gtw2868 = tw2868;
+	
+	proc_create("tw2868_debug",0666,NULL,&procfops);
+	
+	ret = devm_snd_soc_register_component(dev, &tw2868_soc_driver, &tw2868_dai, 1);
+	
+	if (ret != 0) {
+		dev_err(dev, "Failed to register CODEC: %d\n", ret);
+		return ret;
+	}
+	
+	dev_info(dev, "TW2868 driver initialized");
+	
+	return 0;
+}
+
+static int tw2868_suspend(struct device *dev) {
+	struct tw2868 *tw2868 = dev_get_drvdata(dev);
+	if(tw2868->gpio_amp_en) {
+		gpiod_set_value_cansleep(tw2868->gpio_amp_en, 0);
+	}
+	//TODO
+	return 0;
+}
+
+static int tw2868_resume(struct device *dev) {
+	struct tw2868 *tw2868 = dev_get_drvdata(dev);
+	if(tw2868->gpio_amp_en) {
+		gpiod_set_value_cansleep(tw2868->gpio_amp_en, 1);
+	}
+	//TODO
+	return 0;
+}
+
+static const struct dev_pm_ops tw2868_pm_ops = {
+	SET_RUNTIME_PM_OPS(tw2868_suspend, tw2868_resume, NULL)
+};
+
+static const struct of_device_id tw2868_of_match[] = {
+	{ .compatible = "renesas,tw2868", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tw2868_of_match);
+
+static const struct i2c_device_id tw2868_i2c_ids[] = {
+	{ "tw2868" },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tw2868_i2c_ids);
+
+static struct i2c_driver tw2868_driver = {
+	.driver = {
+		.name = "tw2868",
+		.of_match_table = of_match_ptr(tw2868_of_match),
+		.pm = &tw2868_pm_ops,
+	},
+	.probe = tw2868_i2c_probe,
+	.id_table = tw2868_i2c_ids,
+};
+module_i2c_driver(tw2868_driver);
+
+MODULE_DESCRIPTION("ASoC TW2868 driver");
+MODULE_AUTHOR("Indir Wolf");
+MODULE_LICENSE("GPL");
diff --no-dereference -ruN linux-master/sound/soc/hisilicon/hi3515-i2s.c linux-master-mod/sound/soc/hisilicon/hi3515-i2s.c
--- linux-master/sound/soc/hisilicon/hi3515-i2s.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-master-mod/sound/soc/hisilicon/hi3515-i2s.c	2024-11-23 19:08:51.261090812 +0300
@@ -0,0 +1,420 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Indir Wolf
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <linux/interrupt.h>
+#include <linux/reset.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/mfd/syscon.h>
+#include <linux/reset-controller.h>
+
+#include <linux/pm_runtime.h>
+
+#define CH_PLAYBACK 0
+#define CH_RECORD 1
+
+struct hi3515_i2s {
+	struct device *dev;
+	struct reset_control *rc;
+	struct clk *clk;
+	void __iomem *regs;
+	struct resource *regs_res;
+	struct snd_soc_dai_driver dai;
+	struct snd_dmaengine_dai_dma_data dma_data[2];
+	u32 format;
+};
+
+static int hi3515_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt) {
+	struct hi3515_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+
+	/*
+	 * We don't actually set the hardware until the hw_params
+	 * call, but we need to validate the user input here.
+	 */
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
+	case SND_SOC_DAIFMT_BC_FC:
+	case SND_SOC_DAIFMT_BP_FP:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	i2s->format = fmt;
+
+	return 0;
+}
+
+static int hi3515_i2s_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *cpu_dai)
+{
+	struct hi3515_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+	
+	reset_control_deassert(i2s->rc);
+	
+	if(clk_prepare_enable(i2s->clk)) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void hi3515_i2s_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *cpu_dai)
+{
+	struct hi3515_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+	
+	clk_disable_unprepare(i2s->clk);
+	
+}
+
+static int hi3515_i2s_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params, struct snd_soc_dai *cpu_dai)
+{
+	struct hi3515_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+	// struct snd_pcm_runtime *runtime = substream->runtime;
+	u32 bits = 0, rate = 0, signed_data = 0;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+	bool master = true;
+	uint8_t fifo_thres = 0xf;
+	
+	// runtime->sample_bits = 32;
+	// runtime->byte_align = 4;
+	
+	dma_data = snd_soc_dai_get_dma_data(cpu_dai, substream);
+	
+	
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		signed_data = 1;
+		fallthrough;
+	case SNDRV_PCM_FORMAT_U16_LE:
+		bits = 0b001;
+		dma_data->addr_width = 2;
+		dma_data->maxburst = 2;
+		dma_data->fifo_size = fifo_thres*2;
+		break;
+	default:
+		dev_err(cpu_dai->dev, "Bad format %d\n", params_format(params));
+		return -EINVAL;
+	}
+
+
+	// switch (params_rate(params)) {
+	// case 8000:
+	// 	rate = 8000;
+	// 	break;
+	// case 16000:
+	// 	rate = 16000;
+	// 	break;
+	// case 32000:
+	// 	rate = 32000;
+	// 	break;
+	// case 48000:
+	// 	rate = 48000;
+	// 	break;
+	// case 96000:
+	// 	rate = 96000;
+	// 	break;
+	// case 192000:
+	// 	rate = 192000;
+	// 	break;
+	// default:
+	// 	dev_err(cpu_dai->dev, "Bad rate: %d\n", params_rate(params));
+	// 	return -EINVAL;
+	// }
+	
+	rate = params_rate(params);
+
+	if (params_channels(params) != 2) {
+		dev_err(cpu_dai->dev, "Bad channels: %d\n", params_channels(params));
+		return -EINVAL;
+	}
+
+	switch (i2s->format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
+	case SND_SOC_DAIFMT_BC_FC:
+		master = false;
+		break;
+	case SND_SOC_DAIFMT_BP_FP:
+		master = true;
+		break;
+	default:
+		WARN_ONCE(1, "Invalid i2s->fmt CLOCK_PROVIDER_MASK. This shouldn't happen\n");
+		return -EINVAL;
+	}
+
+	if((i2s->format & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S) {
+		WARN_ONCE(1, "Invalid i2s->fmt FORMAT_MASK. This shouldn't happen\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == CH_RECORD) {
+		writel((1<<13), i2s->regs + 0x060);
+		dma_data->addr = i2s->regs_res->start + 0x0A0;
+	} else {
+		writel((1<<12), i2s->regs + 0x060);
+		dma_data->addr = i2s->regs_res->start + 0x0C0;
+	}
+	
+
+	// writel((1<<12) | (1<<13), i2s->regs + 0x060);
+	udelay(10);
+	writel((0<<0) | (0<<1) | (0<<3) | (0 << 4) | (0 << 6), i2s->regs + 0x040);
+	udelay(10);
+	
+	if (master) {
+		clk_set_rate(i2s->clk, rate);
+		dev_dbg(cpu_dai->dev, "Real SR: %lu\n", clk_get_rate(i2s->clk));
+	}
+	
+	writel(signed_data, i2s->regs + 0x084);
+	udelay(10);
+	writel((bits << 0) | (bits << 3),  i2s->regs + 0x078);
+	udelay(10);
+	writel(0xff | (1<<14) | (1<<8) | (1<<9)|(1<<14),  i2s->regs + 0x060); //clear
+	udelay(10);
+	writel((fifo_thres) | (fifo_thres << 4) | (0 << 8) | (0<<9) | (1<<14),  i2s->regs + 0x05C);
+	udelay(10);
+	writel(0b00, i2s->regs + 0x07C);
+	udelay(10);
+	writel(1, i2s->regs + 0x088);
+	udelay(10);
+	writel((1<<10) | (1<<11), i2s->regs + 0x05C);
+	udelay(10);
+	writel((1<<10) | (1<<11), i2s->regs + 0x060);
+	udelay(10);
+	
+	for(int i = 0; i < 0x10; i++) {
+		writel(0, i2s->regs + 0x0C0); //R
+		udelay(10);
+		writel(0, i2s->regs + 0x0C0); //L
+		udelay(10);
+	}
+	
+	
+	
+	// dev_info(cpu_dai->dev, "REGSA:");
+	// for(unsigned int i = 0; i <= 0x0C0; i+= 4) {
+	// 	dev_info(cpu_dai->dev, "	REG 0x%x => 0x%x", i, readl(i2s->regs + i));
+	// }
+
+	return 0;
+}
+
+static int hi3515_i2s_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *cpu_dai) {
+	struct hi3515_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+	pr_debug("%s\n", __func__);
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == CH_RECORD) {
+				writel(1<<13, i2s->regs + 0x05C);
+			} else {
+				writel(1<<12, i2s->regs + 0x05C);
+			}
+			writel((0b11), i2s->regs + 0x08c);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == CH_RECORD) {
+				writel(1<<13, i2s->regs + 0x060);
+			} else {
+				writel(1<<12, i2s->regs + 0x060);
+			}
+			writel((0b111111), i2s->regs + 0x08c);
+			break;
+		default:
+			dev_err(cpu_dai->dev, "unknown cmd %d\n", cmd);
+			return -EINVAL;
+	}
+	// dev_info(cpu_dai->dev, "REGSB:");
+	// for(unsigned int i = 0; i <= 0x0C0; i+= 4) {
+	// 	dev_info(cpu_dai->dev, "	REG 0x%x => 0x%x", i, readl(i2s->regs + i));
+	// }
+	return 0;
+}
+
+static int hi3515_i2s_dai_probe(struct snd_soc_dai *dai) {
+	struct hi3515_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai,
+				  &i2s->dma_data[CH_PLAYBACK], //playback
+				  &i2s->dma_data[CH_RECORD]); //capture
+
+	return 0;
+}
+
+static irqreturn_t hi3515_i2s_irq(int irq, void *data) {
+	struct hi3515_i2s *i2s = data;
+	u32 ints = readl(i2s->regs + 0x044);
+	
+	if(ints&(1<<2))
+		dev_err(i2s->dev, "RX_R_FIFO_OVF");
+	if(ints&(1<<3))
+		dev_err(i2s->dev, "RX_L_FIFO_OVF");
+	if(ints&(1<<4))
+		dev_err(i2s->dev, "TX_R_FIFO_UDF");
+	if(ints&(1<<5))
+		dev_err(i2s->dev, "TX_L_FIFO_UDF");
+	
+	writel(ints, i2s->regs + 0x048);
+	
+	writel((0b111111), i2s->regs + 0x08c);
+
+	return IRQ_HANDLED;
+}
+
+static const struct snd_soc_dai_ops hi3515_i2s_dai_ops = {
+	.probe		= hi3515_i2s_dai_probe,
+	.trigger	= hi3515_i2s_trigger,
+	.hw_params	= hi3515_i2s_hw_params,
+	.set_fmt	= hi3515_i2s_set_fmt,
+	.startup	= hi3515_i2s_startup,
+	.shutdown	= hi3515_i2s_shutdown,
+};
+
+static const struct snd_soc_dai_driver hi3515_i2s_dai = {
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_U16_LE,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_U16_LE,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+	},
+	.ops = &hi3515_i2s_dai_ops,
+	.symmetric_rate = 1,
+};
+
+static const struct snd_soc_component_driver hi3515_i2s_i2s_comp = {
+	.name = "hi31515_i2s-i2s",
+	.legacy_dai_naming = 1,
+};
+
+static int hi3515_i2s_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct hi3515_i2s *i2s;
+	int ret;
+	int irq;
+
+	i2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	i2s->dev = dev;
+
+	i2s->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &i2s->regs_res);
+	if (IS_ERR(i2s->regs))
+		return PTR_ERR(i2s->regs);
+
+
+	i2s->clk = devm_clk_get(dev, "bus");
+	if (IS_ERR(i2s->clk))
+		return PTR_ERR(i2s->clk);
+	
+	i2s->rc = devm_reset_control_get_by_index(dev, 0);
+	if (IS_ERR(i2s->rc))
+		return PTR_ERR(i2s->rc);
+	
+	reset_control_assert(i2s->rc);
+	mdelay(10);
+	reset_control_deassert(i2s->rc);
+	
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+	
+	if(devm_request_irq(dev, irq, hi3515_i2s_irq, IRQF_SHARED, "hi3515_i2s", i2s))
+		return -EINVAL;
+	
+	i2s->dai = hi3515_i2s_dai;
+	
+	dev_set_drvdata(dev, i2s);
+	
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_autosuspend_delay(dev, 500);
+
+	ret = pm_runtime_set_suspended(dev);
+	if (ret)
+		return ret;
+	pm_runtime_enable(dev);
+
+	ret = devm_snd_dmaengine_pcm_register(dev, NULL, 0);
+	if (ret)
+		return ret;
+
+	ret = devm_snd_soc_register_component(dev, &hi3515_i2s_i2s_comp, &i2s->dai, 1);
+	
+	if (ret)
+		return ret;
+	
+	dev_info(dev, "I2S initialized");
+	
+	return 0;
+}
+
+static int hi3515_i2s_suspend(struct device *dev) {
+	struct hi3515_i2s *i2s = dev_get_drvdata(dev);
+	reset_control_assert(i2s->rc);
+	return 0;
+}
+
+static int hi3515_i2s_resume(struct device *dev) {
+	struct hi3515_i2s *i2s = dev_get_drvdata(dev);
+	reset_control_deassert(i2s->rc);
+	return 0;
+}
+
+static const struct dev_pm_ops hi3515_i2s_pm_ops = {
+	SET_RUNTIME_PM_OPS(hi3515_i2s_suspend, hi3515_i2s_resume, NULL)
+};
+
+static const struct of_device_id hi3515_i2s_dts[] = {
+	{ .compatible = "hisilicon,hi3515sio" },
+};
+
+MODULE_DEVICE_TABLE(of, hi3515_i2s_dts);
+
+static struct platform_driver hi3515_i2s_driver = {
+	.probe = hi3515_i2s_probe,
+	.driver = {
+		.name = "hi3515_i2s",
+		.of_match_table = hi3515_i2s_dts,
+		.pm = &hi3515_i2s_pm_ops,
+	},
+};
+
+module_platform_driver(hi3515_i2s_driver);
+
+MODULE_DESCRIPTION("Hisilicon HI3515 I2S driver");
+MODULE_AUTHOR("Indir Wolf");
+MODULE_LICENSE("GPL");
diff --no-dereference -ruN linux-master/sound/soc/hisilicon/Makefile linux-master-mod/sound/soc/hisilicon/Makefile
--- linux-master/sound/soc/hisilicon/Makefile	2024-10-13 14:33:32.000000000 +0300
+++ linux-master-mod/sound/soc/hisilicon/Makefile	2024-10-27 17:59:11.079123895 +0300
@@ -1,2 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_SND_I2S_HI6210_I2S) += hi6210-i2s.o
+obj-$(CONFIG_ARCH_HI3515V100) += hi3515-i2s.o
